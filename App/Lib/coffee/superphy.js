// Generated by CoffeeScript 1.8.0

/*


 File: superphy.coffee
 Desc: Objects & functions for managing views in Superphy
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 7th, 2013
 */
var GenomeController, GroupView, ListView, LocusController, SelectionView, StxController, SuperphyError, ViewController, ViewTemplate, cmp, escapeRegExp, parseHeader, root, superphyAlert, superphyMetaOntology, trimInput, typeIsArray,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

root = typeof exports !== "undefined" && exports !== null ? exports : this;


/*
 CLASS SuperphyError
 
 Error object for this library
 */

SuperphyError = (function(_super) {
  __extends(SuperphyError, _super);

  function SuperphyError(message, name) {
    this.message = message != null ? message : '';
    this.name = name != null ? name : 'Superphy Error';
  }

  return SuperphyError;

})(Error);


/*
 CLASS ViewController
  
 Captures events. Updates data and views
 */

ViewController = (function() {
  function ViewController() {
    if (typeof jQuery === "undefined" || jQuery === null) {
      throw new SuperphyError('jQuery must be loaded before the SuperPhy libary');
    }
    if (typeof URL === "undefined" || URL === null) {
      throw new SuperphyError('SuperPhy library requires the URL library');
    }
    if (typeof Blob === "undefined" || Blob === null) {
      throw new SuperphyError('SuperPhy library requires the Blob library');
    }
  }

  ViewController.prototype.views = [];

  ViewController.prototype.groups = [];

  ViewController.prototype.tickers = [];

  ViewController.prototype.selectedBox = null;

  ViewController.prototype.actionMode = false;

  ViewController.prototype.action = false;

  ViewController.prototype.maxGroups = 10;

  ViewController.prototype.genomeController = void 0;

  ViewController.prototype.init = function(publicGenomes, privateGenomes, actionMode, action, subset) {
    this.actionMode = actionMode;
    this.action = action;
    if (subset == null) {
      subset = null;
    }
    if (!(this.actionMode === 'single_select' || this.actionMode === 'multi_select' || this.actionMode === 'two_groups')) {
      throw new SuperphyError('Unrecognized actionMode in ViewController init() method.');
    }
    this.genomeController = new GenomeController(publicGenomes, privateGenomes, subset);
    this.views = [];
    this.groups = [];
    return this.tickers = [];
  };

  ViewController.prototype.createView = function() {
    var clickStyle, downloadElem, downloadElemDiv, e, elem, listView, mapView, matView, msaView, sumView, tableView, treeView, vNum, viewArgs, viewType;
    viewType = arguments[0], elem = arguments[1], viewArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    clickStyle = 'select';
    vNum = this.views.length + 1;
    if (this.actionMode === 'single_select') {
      clickStyle = 'redirect';
    }
    try {
      if (viewType === 'list') {
        listView = new ListView(elem, clickStyle, vNum, viewArgs);
        listView.update(this.genomeController);
        this.views.push(listView);
      } else if (viewType === 'tree') {
        treeView = new TreeView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        treeView.update(this.genomeController);
        this.views.push(treeView);
      } else if (viewType === 'msa') {
        msaView = new MsaView(elem, clickStyle, vNum, viewArgs);
        msaView.update(this.genomeController);
        this.views.push(msaView);
      } else if (viewType === 'matrix') {
        matView = new MatrixView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        matView.update(this.genomeController);
        this.views.push(matView);
      } else if (viewType === 'map') {
        mapView = new MapView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        this.views.push(mapView);
      } else if (viewType === 'selmap') {
        mapView = new SelectionMapView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        this.views.push(mapView);
      } else if (viewType === 'table') {
        tableView = new TableView(elem, clickStyle, vNum, viewArgs);
        tableView.update(this.genomeController);
        this.views.push(tableView);
      } else if (viewType === 'summary') {
        sumView = new SummaryView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        sumView.update(this.genomeController);
        this.views.push(sumView);
      } else if (viewType === 'jump2table') {
        tableView = new TableView(elem, clickStyle, vNum, viewArgs);
        tableView.update(this.genomeController);
        this.views.push(tableView);
        return;
      } else {
        throw new SuperphyError('Unrecognized viewType <' + viewType + '> in ViewController createView() method.');
        return false;
      }
      downloadElemDiv = jQuery("<div class='download-view'></div>");
      downloadElem = jQuery("<a class='download-view-link' href='#' data-genome-view='" + vNum + "'>Download <i class='fa fa-download'></a>");
      downloadElem.click(function(e) {
        var data, viewNum;
        viewNum = parseInt(this.dataset.genomeView);
        data = viewController.downloadViews(viewNum);
        this.href = data.href;
        this.download = data.file;
        return true;
      });
      downloadElemDiv.append(downloadElem);
      downloadElemDiv.prependTo(elem);
    } catch (_error) {
      e = _error;
      this.viewError(e, elem);
      return false;
    }
    return true;
  };

  ViewController.prototype.viewError = function(e, elem) {
    elem.append("<div class='superphy-error'><p>Superphy Error! View failed to load.</p></div>");
    alert("Superphy error: " + e.message + "\nLine: " + e.line);
    return true;
  };

  ViewController.prototype.introOptions = function() {
    var intros, v, _i, _len, _ref;
    intros = [];
    intros.push({
      element: document.querySelector('#search-utilities'),
      intro: "Any genome search can be further specified to include various meta-data by checking the corresponding boxes.  This will show more information for each genome on the list, tree, and map, but it will not affect the data.  Searches can also be filtered by keyword or by selection to limit the number of genomes displayed on the list, tree, and map.",
      position: 'right'
    });
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      intros = intros.concat(v.intro());
    }
    return intros;
  };

  ViewController.prototype.createGroup = function(boxEl, buttonEl, clearButtonEl) {
    var gNum, grpView;
    gNum = this.groups.length + 1;
    if (gNum > this.maxGroups) {
      return false;
    }
    grpView = new GroupView(boxEl, gNum);
    grpView.update(this.genomeController);
    this.groups.push(grpView);
    buttonEl.click(function(e) {
      e.preventDefault();
      return viewController.addToGroup(gNum);
    });
    clearButtonEl.click(function(e) {
      e.preventDefault();
      return viewController.clearFromGroup(gNum);
    });
    return true;
  };

  ViewController.prototype.addToGroup = function(grp) {
    var i, selected, v, _i, _len, _ref;
    selected = this.genomeController.selected();
    this.genomeController.assignGroup(selected, grp);
    this.genomeController.unselectAll();
    i = grp - 1;
    this.groups[i].add(selected, this.genomeController);
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.update(this.genomeController);
    }
    if (this.selectedBox != null) {
      return this.selectedBox.update(this.genomeController);
    }
  };

  ViewController.prototype.createTicker = function() {
    var alTicker, elem, matTicker, metaTicker, stxTicker, tNum, tickerArgs, tickerType;
    tickerType = arguments[0], elem = arguments[1], tickerArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    tNum = this.tickers.length + 1;
    if (tickerType === 'meta') {
      metaTicker = new MetaTicker(elem, tNum, tickerArgs);
      metaTicker.update(this.genomeController);
      this.tickers.push(metaTicker);
    } else if (tickerType === 'stx') {
      stxTicker = new StxTicker(elem, tNum, tickerArgs);
      stxTicker.update(this.genomeController);
      this.tickers.push(stxTicker);
    } else if (tickerType === 'matrix') {
      matTicker = new MatrixTicker(elem, tNum, this.genomeController, tickerArgs);
      matTicker.update(this.genomeController);
      this.tickers.push(matTicker);
    } else if (tickerType === 'allele') {
      alTicker = new AlleleTicker(elem, tNum, tickerArgs);
      alTicker.update(this.genomeController);
      this.tickers.push(alTicker);
    } else {
      throw new SuperphyError('Unrecognized tickerType in ViewController createTicker() method.');
      return false;
    }
    return true;
  };

  ViewController.prototype.select = function(g, checked) {
    var v, _i, _len, _ref;
    if (this.actionMode === 'single_select') {
      this.redirect(g);
    } else {
      this.genomeController.select(g, checked);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.select(g, checked);
      }
      if (this.selectedBox != null) {
        this.selectedBox.select(g, this.genomeController, checked);
      }
    }
    return true;
  };

  ViewController.prototype.redirect = function(g) {
    var buttonCloseEl, buttonSubmitEl, displayName, modalView, _ref, _ref1;
    displayName = (_ref = (_ref1 = this.genomeController.private_genomes[g]) != null ? _ref1.displayname : void 0) != null ? _ref : this.genomeController.public_genomes[g].displayname;
    modalView = jQuery('<div class="modal fade" id="view-redirect-modal" tabindex="-1" role="dialog" aria-labelledby="viewRedirectModalLabel" aria-hidden="true"> <div class="modal-dialog modal-sm"> <div class="modal-content"> <div class="modal-header"> <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button> <h4 class="modal-title" id="viewRedirectModalLabel">Retrieve selected genome?</h4> </div> <div class="modal-body"> Would you like to retrieve genome information for the selected genome: <form id="view-redirect-form"> <div class="well well-sm">' + displayName + '</div> <input type="hidden" name="genome" value="' + g + '"/> </form> </div> <div class="modal-footer"> </div> </div> </div> </div>');
    buttonCloseEl = jQuery('<button type="button" class="btn btn-danger" data-dismiss="modal" form="view-redirect-form" value="Cancel">Cancel</button>');
    buttonSubmitEl = jQuery('<button type="submit" id="view-redirect-submit" class="btn btn-success" value="Submit" form="view-redirect-form" formmethod="post" formaction="' + viewController.action + '"> Submit </button>');
    buttonSubmitEl.click(function() {
      return modalView.find('.modal-body').append('<div class="alert alert-success"> <p style="text-align:center">Retrieving genome</p> <div class="loader"> <span></span> </div> </div>');
    });
    modalView.find('.modal-footer').append(buttonCloseEl);
    modalView.find('.modal-footer').append(buttonSubmitEl);
    modalView.modal('show');
    return true;
  };

  ViewController.prototype.removeFromGroup = function(genomeID, grp) {
    var gset, i, v, _i, _len, _ref;
    gset = this.genomeController.genomeSet([genomeID]);
    this.genomeController.deleteGroup(gset);
    i = grp - 1;
    this.groups[i].remove(genomeID);
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.update(this.genomeController);
    }
    return true;
  };

  ViewController.prototype.clearFromGroup = function(grp) {
    var actionEl;
    actionEl = jQuery("a[data-genome-group='" + grp + "']");
    return actionEl.click();
  };

  ViewController.prototype.groupForm = function(elem, addMoreBool, submitBool, filterBool) {
    var addEl, blockEl, buttEl, buttonEl, clearFormEl, divEl, hiddenFormEl, submitEl;
    blockEl = jQuery("<div id='group-form-block'></div>").appendTo(elem);
    this.addGroupFormRow(blockEl);
    if (addMoreBool) {
      addEl = jQuery("<div class='add-genome-groups row'></div>");
      divEl = jQuery("<div class='col-md-12'></div>").appendTo(addEl);
      buttEl = jQuery("<button class='btn' type='button'>More Genome Groups...</button>").appendTo(divEl);
      buttEl.click(function(e) {
        var reachedMax;
        reachedMax = viewController.addGroupFormRow(jQuery("#group-form-block"));
        if (!reachedMax) {
          jQuery(this).text('Max groups reached').css('color', 'darkgrey');
          return e.preventDefault();
        }
      });
      elem.append(addEl);
    }
    if (submitBool) {
      submitEl = jQuery("<div class='compare-genome-groups row'></div>");
      divEl = jQuery("<div class='col-md-12'></div>").appendTo(submitEl);
      clearFormEl = jQuery("<button class='btn btn-danger' onclick='location.reload()'><span class='fa fa-times'></span> Reset Form</button>").appendTo(divEl);
      if (filterBool) {
        buttonEl = jQuery("<button type='submit' class='btn btn-primary' value='Submit' form='groups-compare-form'><span class='fa fa-check'></span> Filter Groups</button>").appendTo(divEl);
      }
      if (!filterBool) {
        buttonEl = jQuery("<button type='submit' class='btn btn-primary' value='Submit' form='groups-compare-form'><span class='fa fa-check'></span> Analyze Groups</button>").appendTo(divEl);
      }
      hiddenFormEl = jQuery("<form class='form' id='groups-compare-form' method='post' action='" + this.action + "' enctype='application/x-www-form-urlencoded'></form>").appendTo(divEl);
      buttonEl.click((function(_this) {
        return function(e) {
          var alert, genome, groupGenomes, i, _i, _j, _len, _ref;
          e.preventDefault();
          alert = jQuery('<div class="alert alert-danger"> <button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button> You must have at least one genome in either of the groups to compare to. </div>');
          if (!(jQuery('#genome_group1 li').length > 0 || jQuery('#genome_group2 li').length > 0)) {
            blockEl.prepend(alert);
            return false;
          }
          for (i = _i = 1, _ref = _this.groups.length; _i <= _ref; i = _i += 1) {
            groupGenomes = jQuery("#genome_group" + i + " .genome_group_item");
            for (_j = 0, _len = groupGenomes.length; _j < _len; _j++) {
              genome = groupGenomes[_j];
              jQuery("<input type='hidden' name='group" + i + "-genome' value='" + (jQuery(genome).find('a').data('genome')) + "'>").appendTo(hiddenFormEl);
            }
          }
          jQuery("<input type='hidden' name='num-groups' value='" + _this.groups.length + "'>").appendTo(hiddenFormEl);
          return jQuery('#groups-compare-form').submit();
        };
      })(this));
      elem.append(submitEl);
    }
    return true;
  };

  ViewController.prototype.addGroupFormRow = function(elem) {
    var buttEl, clearButtEl, divEl, formEl, gNum, i, listEl, ok, rowEl, _i, _len, _ref;
    if (typeof elem === 'string') {
      elem = jQuery(elem);
    }
    gNum = this.groups.length + 1;
    if (gNum > this.maxGroups) {
      return false;
    }
    rowEl = jQuery("<div class='group-form-row row'></div>").appendTo(elem);
    ok = true;
    _ref = [gNum, gNum + 1];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      formEl = jQuery("<div id='genome-group-form" + i + "' class='genome-group-form col-md-6'></div>");
      listEl = jQuery("<div id='genome-group-list" + i + "' class='genome-group'></div>").appendTo(formEl);
      divEl = jQuery("<div class='genome-group-add-controller'></div>").appendTo(listEl);
      buttEl = jQuery("<button id='genome-group-add" + i + "' class='btn btn-primary' type='button' title='Add genome(s) to Group " + i + "'><span class='fa fa-plus'></span> <span class='input-lg' id='genome-group" + i + "-heading'>Group " + i + "</span></button>").appendTo(divEl);
      clearButtEl = jQuery("<button id='genome-group-clear" + i + "' class='btn btn-primary pull-right' type='button' title='Clear all genome(s) from Group " + i + "'><span class='fa fa-times'></span> <span class='input-lg' id='genome-group" + i + "-heading'></span></button>").appendTo(divEl);
      rowEl.append(formEl);
      ok = this.createGroup(listEl, buttEl, clearButtEl);
    }
    return ok;
  };

  ViewController.prototype.viewAction = function() {
    var vNum, viewArgs;
    vNum = arguments[0], viewArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.views[vNum].viewAction(this.genomeController, viewArgs);
    return true;
  };

  ViewController.prototype.getView = function(vNum) {
    return this.views[vNum];
  };

  ViewController.prototype.updateViews = function(option, checked) {
    var t, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    this.genomeController.updateMeta(option, checked);
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.update(this.genomeController);
    }
    _ref1 = this.groups;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      v = _ref1[_j];
      v.update(this.genomeController);
    }
    _ref2 = this.tickers;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      t = _ref2[_k];
      t.update(this.genomeController);
    }
    if (this.selectedBox != null) {
      this.selectedBox.update(this.genomeController);
    }
    return true;
  };

  ViewController.prototype.downloadViews = function(viewNum) {
    var blob, dump, file, href, url;
    url = window.URL || window.webkitURL;
    blob = window.Blob;
    dump = this.views[viewNum - 1].dump(this.genomeController);
    file = new blob([dump.data], {
      type: dump.type
    });
    href = url.createObjectURL(file);
    file = "superphy_download." + dump.ext;
    return {
      href: href,
      file: file
    };
  };

  ViewController.prototype.sideBar = function(elem) {
    var form1, form2, form3, parentTarget, wrapper;
    parentTarget = 'sidebar-group';
    wrapper = jQuery('<div class="panel-group" id="' + parentTarget + '"></div>');
    elem.append(wrapper);
    form1 = jQuery('<div class="panel panel-default"></div>');
    wrapper.append(form1);
    this.metaForm(form1, parentTarget);
    form3 = jQuery('<div id="user-groups" class="panel panel-default"></div>');
    wrapper.append(form3);
    this.groupForm(form3, parentTarget);
    form2 = jQuery('<div class="panel panel-default"></div>');
    wrapper.append(form2);
    this.filterForm(form2, parentTarget);
    return true;
  };

  ViewController.prototype.groupForm = function(elem, parentStr) {
    var group_form, panel_body, panel_header, panel_main, panel_title;
    panel_header = $('<div class="panel-heading"></div>');
    panel_title = $('<div class="panel_title"> <a data-toggle="collapse" href="#group-form"> User Groups <span class="caret"></span></a></div>').appendTo(panel_header);
    panel_main = $('<div id="group-form" class="collapse in"></div>');
    panel_body = $('<div class="panel-body"></div>').appendTo(panel_main);
    group_form = $('<div class="user-groups-menu"></div>').appendTo(panel_body);
    elem.append(panel_header);
    elem.append(panel_main);
    return true;
  };

  ViewController.prototype.sideBarGroupManager = function(elem) {
    var form, parentTarget, wrapper;
    parentTarget = 'sidebar-accordion';
    wrapper = jQuery('#sidebar-accordion');
    form = jQuery('<div class="panel panel-default"></div>');
    wrapper.append(form);
    this.groupsSideForm(form, parentTarget);
    return true;
  };

  ViewController.prototype.createGroupsForm = function(elem, addMoreBool, submitBool, filterBool) {
    var form, parentTarget, wrapper;
    parentTarget = 'groups-compare-panel-body';
    wrapper = jQuery('<div class="panel panel-default" id="groups-compare-panel"></div>');
    elem.append(wrapper);
    form = jQuery('<div class="panel-body" id="' + parentTarget + '"></div>');
    wrapper.append(form);
    this.groupForm(form, addMoreBool, submitBool, filterBool);
    return true;
  };

  ViewController.prototype.metaForm = function(elem, parentStr) {
    var form;
    form = '<div class="panel-heading">' + '<div class="panel-title">' + '<a data-toggle="collapse" href="#meta-form"><i class="fa fa-eye"></i> Meta-data ' + '<span class="caret"></span></a>' + '</div></div>' + '<div id="meta-form" class="collapse in">' + '<div class="panel-body">' + '<p>Select meta-data displayed:</p>' + '<form class="form-inline">' + '<fieldset>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="accession"> Accession # </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="strain"> Strain </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="serotype"> Serotype </label><div id="meta-option_serotype" style="display:none;width:12px;height:12px;background:#004D11;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_host"> Isolation Host </label><div id="meta-option_isolation_host" style="display:none;width:12px;height:12px;background:#9E0015;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_source"> Isolation Source </label><div id="meta-option_isolation_source" style="display:none;width:12px;height:12px;background:#000752;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_date"> Isolation Date </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="syndrome"> Symptoms / Diseases </label><div id="meta-option_syndrome" style="display:none;width:12px;height:12px;background:#520042;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="stx1_subtype"> Stx1 Subtype </label><div id="meta-option_stx1_subtype" style="display:none;width:12px;height:12px;background:#F05C00;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="stx2_subtype"> Stx2 Subtype </label><div id="meta-option_stx2_subtype" style="display:none;width:12px;height:12px;background:#006B5C;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '</fieldset>' + '</form>' + '</div></div>';
    elem.append(form);
    jQuery('input[name="meta-option"]').change(function() {
      return viewController.updateViews(this.value, this.checked);
    });
    return true;
  };

  ViewController.prototype.filterViews = function(filterForm) {
    var searchTerms, t, term, v, _i, _j, _len, _len1, _ref, _ref1;
    if (filterForm === 'selection') {
      this.genomeController.filterBySelection();
    } else {
      searchTerms = null;
      if (filterForm === 'fast') {
        term = jQuery("#fast-filter > input").val().toLowerCase();
        if ((term != null) && term.length) {
          searchTerms = [];
          searchTerms.push({
            searchTerm: term,
            dataField: 'viewname',
            negate: false
          });
        }
      } else {
        searchTerms = this._parseFilterForm();
        if (searchTerms == null) {
          return false;
        }
      }
      this.genomeController.filter(searchTerms);
    }
    this._toggleFilterStatus(true);
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.update(this.genomeController);
    }
    _ref1 = this.tickers;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      t = _ref1[_j];
      t.update(this.genomeController);
    }
    return true;
  };

  ViewController.prototype.resetFilter = function() {
    var t, v, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.genomeController.filter();
    this._toggleFilterStatus();
    this._clearFilterForm();
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.update(this.genomeController);
    }
    _ref1 = this.tickers;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      t = _ref1[_j];
      _results.push(t.update(this.genomeController));
    }
    return _results;
  };

  ViewController.prototype.filterForm = function(elem, parentStr) {
    var advDiv, advForm, advGroup, advLab, advRadio, container, delButton, fastDiv, fastGroup, fastLab, fastRadio, fbg, fbs, filtButton, filtType, filterOff, filterOn, filterStatus, findButton, header, numVisible, selDiv, selGroup, selLab, selRadio, sf, ugpDiv, ugpGroup, ugpLab, ugpRadio;
    header = jQuery('<div class="panel-heading">' + '<div class="panel-title">' + '<a data-toggle="collapse" href="#filter-form"><i class="fa fa-filter"></i> Filter ' + '<span class="caret"></span></a>' + '</div></div>').appendTo(elem);
    container = jQuery('<div id="filter-form" class="panel-collapse collapse in"></div>');
    numVisible = this.genomeController.filtered;
    filterStatus = jQuery('<div id="filter-status"></div>');
    filterOn = jQuery("<div id='filter-on'><div id='filter-on-text' class='alert alert-warning'>Filter active. " + numVisible + " genomes visible.</div></div>");
    filterOff = jQuery('<div id="filter-off"></div>');
    delButton = jQuery('<button id="remove-filter" type="button" class="btn btn-sm">Clear</button>');
    delButton.click(function(e) {
      e.preventDefault();
      return viewController.resetFilter();
    });
    delButton.appendTo(filterOn);
    if (numVisible > 0) {
      filterOn.show();
      filterOff.hide();
    } else {
      filterOn.hide();
      filterOff.show();
    }
    filterStatus.append(filterOn);
    filterStatus.append(filterOff);
    container.append(filterStatus);
    container.append('<p>Limit genomes displayed in views by:</p>');
    filtType = jQuery('<form id="select-filter-form" class="form-horizontal"></form>');
    fastGroup = jQuery('<div class="form-group"></div>');
    fastDiv = jQuery('<div class="col-xs-1"></div>').appendTo(fastGroup);
    fastRadio = jQuery('<input id="fast" type="radio" name="filter-form-type" value="fast" checked>').appendTo(fastDiv);
    fastLab = jQuery('<label class="col-xs-10" for="fast">Basic</label>').appendTo(fastGroup);
    fastRadio.change(function(e) {
      if (this.checked != null) {
        jQuery("#fast-filter").show();
        jQuery("#adv-filter").hide();
        jQuery("#selection-filter").hide();
        jQuery("#group-filter").hide();
      }
      return true;
    });
    filtType.append(fastGroup);
    advGroup = jQuery('<div class="form-group"></div>');
    advDiv = jQuery('<div class="col-xs-1"></div>').appendTo(advGroup);
    advRadio = jQuery('<input type="radio" id="adv" name="filter-form-type" value="advanced">').appendTo(advDiv);
    advLab = jQuery('<label class="col-xs-10" for="adv">Advanced</label>').appendTo(advGroup);
    advRadio.change(function(e) {
      if (this.checked != null) {
        jQuery("#fast-filter").hide();
        jQuery("#adv-filter").show();
        jQuery("#selection-filter").hide();
        jQuery("#group-filter").hide();
      }
      return true;
    });
    filtType.append(advGroup);
    selGroup = jQuery('<div class="form-group"></div>');
    selDiv = jQuery('<div class="col-xs-1"></div>').appendTo(selGroup);
    selRadio = jQuery('<input id="sel" type="radio" name="filter-form-type" value="selection">').appendTo(selDiv);
    selLab = jQuery('<label class="col-xs-10" for="sel">By Selection</label>').appendTo(selGroup);
    selRadio.change(function(e) {
      if (this.checked != null) {
        jQuery("#fast-filter").hide();
        jQuery("#adv-filter").hide();
        jQuery("#selection-filter").show();
        jQuery("#group-filter").hide();
      }
      return true;
    });
    filtType.append(selGroup);
    ugpGroup = jQuery('<div class="form-group"></div>');
    ugpDiv = jQuery('<div class="col-xs-1"></div>').appendTo(ugpGroup);
    ugpRadio = jQuery('<input id="ugp" type="radio" name="filter-form-type" value="selection">').appendTo(ugpDiv);
    ugpLab = jQuery('<label class="col-xs-10" for="ugp">By Group</label>').appendTo(ugpGroup);
    ugpRadio.change(function(e) {
      if (this.checked != null) {
        jQuery("#fast-filter").hide();
        jQuery("#adv-filter").hide();
        jQuery("#selection-filter").hide();
        jQuery("#group-filter").show();
      }
      return true;
    });
    filtType.append(ugpGroup);
    container.append(filtType);
    sf = jQuery("<div id='fast-filter'></div>");
    this.addFastFilter(sf);
    container.append(sf);
    advForm = jQuery("<div id='adv-filter'></div>");
    this.addAdvancedFilter(advForm);
    advForm.hide();
    container.append(advForm);
    fbs = jQuery("<div id='selection-filter'>" + "<p>A selection in one of the views (i.e. genomes selected in a clade or map region)</p>" + "</div>");
    filtButton = jQuery('<button id="filter-selection-button" type="button" class="btn btn-sm">Filter by Selection</button>');
    filtButton.click(function(e) {
      e.preventDefault();
      return viewController.filterViews('selection');
    });
    fbs.append(filtButton);
    fbs.hide();
    container.append(fbs);
    fbg = jQuery("<div class='row' id='group-filter'>" + "<p>A group in one of the views</p>" + "</div>");
    findButton = jQuery('<div class="col-xs-3"><button id="user-groups-submit" class="btn btn btn-sm" type="button">Find</button></div>');
    fbg.append(findButton);
    filtButton = jQuery('<div class="col-xs-3"><button id="filter-group-button" type="button" class="btn btn-sm">Filter</button></div>');
    filtButton.click(function(e) {
      e.preventDefault();
      return viewController.filterViews('selection');
    });
    fbg.append(filtButton);
    fbg.hide();
    container.append(fbg);
    container.appendTo(elem);
    return true;
  };

  ViewController.prototype._toggleFilterStatus = function(attempt) {
    var filterOff, filterOn, numVisible;
    if (attempt == null) {
      attempt = false;
    }
    numVisible = this.genomeController.filtered;
    filterOn = jQuery('#filter-on');
    filterOff = jQuery('#filter-off');
    if (numVisible > 0) {
      filterOn.find('#filter-on-text').text("Filter active. " + numVisible + " genomes visible.");
      filterOn.show();
      filterOff.hide();
    } else if (numVisible === 0 && attempt) {
      filterOn.find('#filter-on-text').text("No genomes match search criteria.");
      filterOn.show();
      filterOff.hide();
    } else {
      filterOn.hide();
      filterOff.show();
    }
    return true;
  };

  ViewController.prototype._toggleSelectAll = function(switchOn, hardLimit) {
    var buttonGp, divEl, numVisible, selectAllButt, selectAllRow, unSelectAllButt;
    numVisible = this.genomeController.filtered;
    selectAllRow = jQuery('.select-all-genomes-row');
    selectAllRow.empty();
    divEl = jQuery('<div class="col-md-6"></div>');
    buttonGp = jQuery('<div class="btn-group"></div>').appendTo(divEl);
    selectAllButt = jQuery('<button id="table-select-all" class="btn btn-link">Select All</button>').appendTo(buttonGp);
    unSelectAllButt = jQuery('<button id="table-unselect-all" class="btn btn-link">Unselect All</button>').appendTo(buttonGp);
    selectAllButt.click((function(_this) {
      return function(e) {
        var g, _i, _j, _len, _len1, _ref, _ref1, _results;
        e.preventDefault();
        _ref = _this.genomeController.pubVisible;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          _this.select(g, true);
        }
        _ref1 = _this.genomeController.pvtVisible;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          _results.push(_this.select(g, true));
        }
        return _results;
      };
    })(this));
    unSelectAllButt.click((function(_this) {
      return function(e) {
        var g, _i, _j, _len, _len1, _ref, _ref1, _results;
        e.preventDefault();
        _ref = _this.genomeController.pubVisible;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          _this.select(g, false);
        }
        _ref1 = _this.genomeController.pvtVisible;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          _results.push(_this.select(g, false));
        }
        return _results;
      };
    })(this));
    if (switchOn && numVisible <= hardLimit) {
      selectAllRow.append(divEl);
    } else {

    }
    return true;
  };

  ViewController.prototype._clearFilterForm = function() {
    var advForm, sf;
    sf = jQuery("#fast-filter");
    sf.empty();
    this.addFastFilter(sf);
    advForm = jQuery("#adv-filter");
    advForm.empty();
    this.addAdvancedFilter(advForm);
    return true;
  };

  ViewController.prototype.addAdvancedFilter = function(elem) {
    var addRow, advButton, advRows;
    elem.append("<p>Boolean keyword search of specified meta-data fields</p>");
    advRows = jQuery("<div id='adv-filter-rows'></div>");
    elem.append(advRows);
    this.addFilterRow(advRows, 1);
    advButton = jQuery('<button id="adv-filter-submit" type="button" class="btn btn-sm">Filter</button>');
    elem.append(advButton);
    advButton.click(function(e) {
      e.preventDefault;
      return viewController.filterViews('advanced');
    });
    addRow = jQuery('<a href="#" class="adv-filter-addition">Add term</a>');
    addRow.click(function(e) {
      var rowI, rows;
      e.preventDefault();
      rows = jQuery('.adv-filter-row');
      rowI = rows.length + 1;
      return viewController.addFilterRow(jQuery('#adv-filter-rows'), rowI);
    });
    elem.append(addRow);
    return true;
  };


  /*  
   * FUNC addFilterRow
   * Adds additional search term row to advanced filter form.
   * Multiple search terms are joined using boolean operators.
   *
   * PARAMS
   * elem - jQuery element object of rows
   * rowNum - sequential number for new row
   * 
   * RETURNS
   * boolean 
   *       
  addFilterRow: (elem, rowNum) ->
    
     * Row wrapper
    row = jQuery('<div class="adv-filter-row" data-filter-row="' + rowNum + '"></div>').appendTo(elem)
    
     * Term join operation
    if rowNum isnt 1
      jQuery('<select name="adv-filter-op" data-filter-row="' + rowNum + '">' +
        '<option value="and" selected="selected">AND</option>' +
        '<option value="or">OR</option>' +
        '<option value="not">NOT</option>' +
        '</select>').appendTo(row)
    
     * Field type
    dropDown = jQuery('<select name="adv-filter-field" data-filter-row="' + rowNum + '"></select>').appendTo(row)
    for k,v of @genomeController.metaMap
        dropDown.append('<option value="' + k + '">' + v + '</option>')
    
    dropDown.append('<option value="displayname" selected="selected">Genome name</option>')
    
     * Change type of search term box depending on field type
    dropDown.change ->
      thisRow = this.dataset.filterRow
      if @.value is 'isolation_date'
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide()
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show()
      else
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show()
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide()
      true
    
     * Keyword-based search wrapper
    keyw = jQuery('<div class="adv-filter-keyword" data-filter-row="' + rowNum + '"></div>)')
    
     * Search term box
    jQuery('<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>').appendTo(keyw)
    keyw.appendTo(row)
    
     * Predefined search term dropdowns
     * Host
    
    
  
     * Date-based search wrapper
    dt = jQuery('<div class="adv-filter-date" data-filter-row="' + rowNum + '"></div>)')
    dt.append('<select name="adv-filter-before" data-filter-row="' + rowNum + '">' +
      '<option value="before" selected="selected">before</option>' +
      '<option value="after">after</option>' +
      '</select>')
    dt.append('<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>')
    dt.append('<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>')
    dt.append('<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>')
    dt.hide()
    dt.appendTo(row)
    
     * Delete button
    if rowNum isnt 1
      delRow = jQuery('<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>')
      delRow.appendTo(row)
  
       * Delete row wrapper
      delRow.click (e) ->
        e.preventDefault()
        thisRow = this.dataset.filterRow
        jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove()
  
    true
   */

  ViewController.prototype.addFilterRow = function(elem, rowNum) {
    var db, delRow, dropDown, dt, fd, fdt, ff, fh, fht, fs, fst, hosts, k, keyw, row, rowObj, sources, syndromes, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
    row = '<div class="adv-filter-row" data-filter-row="' + rowNum + '">';
    row += '<div class="adv-filter-header">';
    if (rowNum !== 1) {
      row += '<select name="adv-filter-op" data-filter-row="' + rowNum + '">' + '<option value="and" selected="selected">AND</option>' + '<option value="or">OR</option>' + '<option value="not">NOT</option>' + '</select>';
    }
    dropDown = '<select name="adv-filter-field" data-filter-row="' + rowNum + '">';
    _ref = this.genomeController.metaMap;
    for (k in _ref) {
      v = _ref[k];
      dropDown += '<option value="' + k + '">' + v + '</option>';
    }
    dropDown += '<option value="displayname" selected="selected">Genome name</option></select>';
    row += dropDown;
    row += '</div><div class="adv-filter-body">';
    keyw = '<div class="adv-filter-keyword" data-filter-row="' + rowNum + '">';
    keyw += '<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>';
    keyw += '</div>';
    row += keyw;
    hosts = '<div class="adv-filter-host-terms" data-filter-row="' + rowNum + '">';
    hosts += '<select name="adv-filter-hosts" data-filter-row="' + rowNum + '">';
    hosts += '<option value="">--Select Host--</option>';
    _ref1 = superphyMetaOntology["hosts"];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      v = _ref1[_i];
      hosts += '<option value="' + v + '">' + v + '</option>';
    }
    hosts += '<option value="other">Other (fill in field below)</option></select>';
    hosts += '<input type="text" name="adv-filter-host-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
    hosts += '</div>';
    row += hosts;
    sources = '<div class="adv-filter-source-terms" data-filter-row="' + rowNum + '">';
    sources += '<select name="adv-filter-sources" data-filter-row="' + rowNum + '">';
    sources += '<option value="">--Select Source--</option>';
    _ref2 = superphyMetaOntology["sources"];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      v = _ref2[_j];
      sources += '<option value="' + v + '">' + v + '</option>';
    }
    sources += '<option value="other">Other (fill in field below)</option></select>';
    sources += '<input type="text" name="adv-filter-source-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
    sources += '</div>';
    row += sources;
    syndromes = '<div class="adv-filter-syndrome-terms" data-filter-row="' + rowNum + '">';
    syndromes += '<select name="adv-filter-syndromes" data-filter-row="' + rowNum + '">';
    syndromes += '<option value="">--Select Syndrome--</option>';
    _ref3 = superphyMetaOntology["syndromes"];
    for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
      v = _ref3[_k];
      syndromes += '<option value="' + v + '">' + v + '</option>';
    }
    syndromes += '<option value="other">Other (fill in field below)</option></select>';
    syndromes += '<input type="text" name="adv-filter-syndrome-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
    syndromes += '</div>';
    row += syndromes;
    dt = '<div class="adv-filter-date" data-filter-row="' + rowNum + '">';
    dt += '<select name="adv-filter-before" data-filter-row="' + rowNum + '">' + '<option value="before" selected="selected">before</option>' + '<option value="after">after</option>' + '</select>';
    dt += '<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>';
    dt += '<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>';
    dt += '<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>';
    dt += '</div>';
    row += dt;
    if (rowNum !== 1) {
      delRow = '<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>';
      row += delRow;
    }
    row += '</div>';
    rowObj = jQuery(row);
    ff = rowObj.find('[name="adv-filter-field"][data-filter-row="' + rowNum + '"]');
    ff.change(function() {
      var thisRow;
      thisRow = this.dataset.filterRow;
      if (this.value === 'isolation_date') {
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show();
        jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
        jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
        jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
      } else if (this.value === 'isolation_host') {
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').show();
        jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
        jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
      } else if (this.value === 'isolation_source') {
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
        jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').show();
        jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
      } else if (this.value === 'syndrome') {
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
        jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
        jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').show();
      } else {
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show();
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
        jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
        jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
      }
      return true;
    });
    fht = rowObj.find('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]');
    fh = fht.find('[name="adv-filter-hosts"]');
    fh.change(function() {
      var thisRow;
      thisRow = this.dataset.filterRow;
      if (this.value === 'other') {
        return jQuery('[name="adv-filter-host-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
      } else {
        return jQuery('[name="adv-filter-host-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
      }
    });
    fht.hide();
    fst = rowObj.find('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]');
    fs = fst.find('[name="adv-filter-sources"]');
    fs.change(function() {
      var thisRow;
      thisRow = this.dataset.filterRow;
      if (this.value === 'other') {
        return jQuery('[name="adv-filter-source-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
      } else {
        return jQuery('[name="adv-filter-source-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
      }
    });
    fst.hide();
    fdt = rowObj.find('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]');
    fd = fdt.find('[name="adv-filter-syndromes"]');
    fd.change(function() {
      var thisRow;
      thisRow = this.dataset.filterRow;
      if (this.value === 'other') {
        return jQuery('[name="adv-filter-syndrome-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
      } else {
        return jQuery('[name="adv-filter-syndrome-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
      }
    });
    fdt.hide();
    fd = rowObj.find('.adv-filter-date[data-filter-row="' + rowNum + '"]');
    fd.hide();
    if (rowNum !== 1) {
      db = rowObj.find('.adv-filter-subtraction[data-filter-row="' + rowNum + '"]');
      db.click(function(e) {
        var thisRow;
        e.preventDefault();
        thisRow = this.dataset.filterRow;
        console.log('del' + thisRow);
        return jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove();
      });
    }
    elem.append(rowObj);
    return true;
  };

  ViewController.prototype.addFastFilter = function(elem) {
    var fastButton, tBox;
    elem.append("<p>Basic genome name filter</p>");
    tBox = jQuery('<input type="text" name="fast-filter-term" placeholder="Filter by..."></input>');
    fastButton = jQuery('<button id="fast-filter-submit" type="button" class="btn btn-sm">Filter</button>');
    fastButton.click(function(e) {
      e.preventDefault;
      return viewController.filterViews('fast');
    });
    tBox.appendTo(elem);
    fastButton.appendTo(elem);
    return true;
  };

  ViewController.prototype._parseFilterForm = function() {
    var bef, date, df, dy, isBefore, isDate, mn, negate, op, row, rowNum, rows, searchTerms, t, term, yr, _i, _len;
    rows = jQuery('.adv-filter-row');
    searchTerms = [];
    for (_i = 0, _len = rows.length; _i < _len; _i++) {
      row = rows[_i];
      t = {};
      rowNum = parseInt(row.dataset.filterRow);
      df = jQuery("[name='adv-filter-field'][data-filter-row='" + rowNum + "']").val();
      t.dataField = df;
      isDate = false;
      if (df === 'isolation_date') {
        isDate = true;
      }
      if (!isDate) {
        if (df === 'isolation_host') {
          term = jQuery("[name='adv-filter-hosts'][data-filter-row='" + rowNum + "']").val();
          if (term === 'other') {
            term = jQuery("[name='adv-filter-host-other'][data-filter-row='" + rowNum + "']").val();
            term = trimInput(term, 'keyword');
          }
          if (!((term != null) && term !== "")) {
            alert('Error: empty field.');
            return null;
          }
          t.searchTerm = term;
        } else if (df === 'isolation_source') {
          term = jQuery("[name='adv-filter-sources'][data-filter-row='" + rowNum + "']").val();
          if (term === 'other') {
            term = jQuery("[name='adv-filter-source-other'][data-filter-row='" + rowNum + "']").val();
            term = trimInput(term, 'keyword');
          }
          if (!((term != null) && term !== "")) {
            alert('Error: empty field.');
            return null;
          }
          t.searchTerm = term;
        } else if (df === 'syndrome') {
          term = jQuery("[name='adv-filter-syndromes'][data-filter-row='" + rowNum + "']").val();
          if (term === 'other') {
            term = jQuery("[name='adv-filter-syndrome-other'][data-filter-row='" + rowNum + "']").val();
            term = trimInput(term, 'keyword');
          }
          if (!((term != null) && term !== "")) {
            alert('Error: empty field.');
            return null;
          }
          t.searchTerm = term;
        } else {
          term = jQuery("[name='adv-filter-term'][data-filter-row='" + rowNum + "']").val();
          term = trimInput(term, 'keyword');
          if (!((term != null) && term !== "")) {
            alert('Error: empty field.');
            return null;
          }
          t.searchTerm = term;
        }
      } else {
        bef = jQuery("[name='adv-filter-before'][data-filter-row='" + rowNum + "']").val();
        if (!(bef === 'before' || bef === 'after')) {
          throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-before" must contain strings "before","after".');
        }
        isBefore = true;
        if (bef === 'after') {
          isBefore = false;
        }
        yr = jQuery("[name='adv-filter-year'][data-filter-row='" + rowNum + "']").val();
        yr = trimInput(yr, 'Year');
        if (yr == null) {
          return null;
        }
        if (!/^[1-9][0-9]{3}$/.test(yr)) {
          alert('Error: invalid Year.');
          return null;
        }
        mn = jQuery("[name='adv-filter-mon'][data-filter-row='" + rowNum + "']").val();
        if (mn != null) {
          mn = jQuery.trim(mn);
        }
        if ((mn != null) && mn.length) {
          if (!/^[0-9]{1,2}$/.test(mn)) {
            alert('Error: invalid Month.');
            return null;
          }
        } else {
          mn = '01';
        }
        dy = jQuery("[name='adv-filter-day'][data-filter-row='" + rowNum + "']").val();
        if (dy != null) {
          dy = jQuery.trim(dy);
        }
        if ((dy != null) && dy.length) {
          if (!/^[0-9]{1,2}$/.test(dy)) {
            alert('Error: invalid Day.');
            return null;
          }
        } else {
          dy = '01';
        }
        date = Date.parse("" + yr + "-" + mn + "-" + dy);
        if (isNaN(date)) {
          alert('Error: invalid date.');
          return null;
        }
        t.date = date;
        t.before = isBefore;
      }
      if (rowNum !== 1) {
        op = jQuery("[name='adv-filter-op'][data-filter-row='" + rowNum + "']").val();
        negate = false;
        if (!(op === 'or' || op === 'and' || op === 'not')) {
          throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-op" must contain strings "and","or","not".');
        }
        if (op === 'not') {
          op = 'and';
          negate = true;
        }
        t.op = op;
        t.negate = negate;
        searchTerms.push(t);
      } else {
        t.negate = false;
        searchTerms.unshift(t);
      }
    }
    return searchTerms;
  };

  ViewController.prototype.createSelectionView = function(boxEl, countEl) {
    var selView;
    if (countEl == null) {
      countEl = null;
    }
    if (this.selectedBox != null) {
      throw new SuperphyError('Existing SelectionView. Cannot create multiple views of this type.');
    }
    selView = new SelectionView(boxEl, countEl);
    selView.update(this.genomeController);
    this.selectedBox = selView;
    return true;
  };

  ViewController.prototype.submitGenomes = function(formEl, paramType) {
    var g, genomes, gset, input, k, v, _i, _len, _ref, _ref1, _results, _results1;
    if (paramType == null) {
      paramType = 'selected';
    }
    if (paramType === 'selected') {
      gset = this.genomeController.selected();
      genomes = gset["public"].concat(gset["private"]);
      _results = [];
      for (_i = 0, _len = genomes.length; _i < _len; _i++) {
        g = genomes[_i];
        input = jQuery('<input></input>');
        input.attr('type', 'hidden');
        input.attr('name', 'genome');
        input.val(g);
        _results.push(formEl.append(input));
      }
      return _results;
    } else if (paramType === 'grouped') {
      _ref = this.genomeController.public_genomes;
      for (k in _ref) {
        v = _ref[k];
        if (!(v.assignedGroup != null)) {
          continue;
        }
        input = jQuery('<input></input>');
        input.attr('type', 'hidden');
        input.attr('name', "group" + v.assignedGroup);
        input.val(g);
        formEl.append(input);
      }
      _ref1 = this.genomeController.private_genomes;
      _results1 = [];
      for (k in _ref1) {
        v = _ref1[k];
        if (!(v.assignedGroup != null)) {
          continue;
        }
        input = jQuery('<input></input>');
        input.attr('type', 'hidden');
        input.attr('name', "group" + v.assignedGroup);
        input.val(g);
        _results1.push(formEl.append(input));
      }
      return _results1;
    } else {
      throw new SuperphyError("Unknown paramType parameter: " + paramType);
    }
  };

  ViewController.prototype.highlightInView = function(searchStr, vNum) {
    var targetList;
    if (!(searchStr && searchStr.length)) {
      return false;
    }
    targetList = this.genomeController.find(searchStr);
    if (targetList && targetList.length) {
      this.views[vNum].highlightGenomes(this.genomeController, targetList);
    } else {
      superphyAlert("Search string " + searchStr + " matches no currently visible genomes.", "None Found");
    }
    return true;
  };

  return ViewController;

})();

if (!root.ViewController) {
  root.viewController = new ViewController;
}


/*
 CLASS ViewTemplate
 
 Template object for views. Defines required and
 common properties/methods. All view objects
 are descendants of the ViewTemplate.
 */

ViewTemplate = (function() {
  function ViewTemplate(parentElem, style, elNum) {
    this.parentElem = parentElem;
    this.style = style != null ? style : 'select';
    this.elNum = elNum != null ? elNum : 1;
    this.elID = this.elName + this.elNum;
  }

  ViewTemplate.prototype.type = void 0;

  ViewTemplate.prototype.elNum = 1;

  ViewTemplate.prototype.elName = 'view';

  ViewTemplate.prototype.elID = void 0;

  ViewTemplate.prototype.parentElem = void 0;

  ViewTemplate.prototype.style = 'select';

  ViewTemplate.prototype.update = function(genomes) {
    throw new SuperphyError("ViewTemplate method update() must be defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.updateCSS = function(gset, genomes) {
    throw new SuperphyError("ViewTemplate method updateCSS() must be defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.select = function(genome, isSelected) {
    throw new SuperphyError("ViewTemplate method select() must be defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.dump = function(genomes) {
    throw new SuperphyError("ViewTemplate method dump() must be defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.viewAction = function() {
    var args, genomes;
    genomes = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    throw new SuperphyError("viewAction method has not been defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.highlightGenomes = function() {
    var args, genomes, targetList;
    genomes = arguments[0], targetList = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    throw new SuperphyError("highlightGenomes method has not been defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.cssClass = function() {
    return this.elName + '_item';
  };

  return ViewTemplate;

})();


/*
 CLASS ListView
 
 Genome list
 
 Always genome-based
 Returns genome ID to redirect/select when genome list item is clicked
 */

ListView = (function(_super) {
  __extends(ListView, _super);

  function ListView(parentElem, style, elNum, listArgs) {
    this.parentElem = parentElem;
    this.style = style;
    this.elNum = elNum;
    if ((listArgs != null) && (listArgs[0] != null)) {
      this.locusData = listArgs[0];
    }
    ListView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
  }

  ListView.prototype.type = 'list';

  ListView.prototype.elName = 'genome_list';

  ListView.prototype.locusData = null;

  ListView.prototype.update = function(genomes) {
    var ft, listElem, t1, t2;
    listElem = jQuery("#" + this.elID);
    if (listElem.length) {
      listElem.empty();
    } else {
      listElem = jQuery("<ul id='" + this.elID + "'/>");
      jQuery(this.parentElem).append(listElem);
    }
    t1 = new Date();
    this._appendGenomes(listElem, genomes.pubVisible, genomes.public_genomes, this.style, false);
    this._appendGenomes(listElem, genomes.pvtVisible, genomes.private_genomes, this.style, true);
    t2 = new Date();
    ft = t2 - t1;
    console.log('ListView update elapsed time: ' + ft);
    return true;
  };

  ListView.prototype._appendGenomes = function(el, visibleG, genomes, style, priv) {
    var actionEl, checked, cls, g, labEl, listEl, name, thiscls, _i, _len;
    cls = this.cssClass();
    if (priv && visibleG.length) {
      el.append("<li class='genome_list_spacer'>---- USER-SUBMITTED GENOMES ----</li>");
    }
    for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
      g = visibleG[_i];
      thiscls = cls;
      if (genomes[g].cssClass != null) {
        thiscls = cls + ' ' + genomes[g].cssClass;
      }
      name = genomes[g].viewname;
      if (this.locusData != null) {
        name += this.locusData.genomeString(g);
      }
      if (style === 'redirect') {
        listEl = jQuery("<li class='" + thiscls + "'>" + name + "</li>");
        actionEl = jQuery("<a href='#' data-genome='" + g + "'> <span class='fa fa-search'></span>info</a>");
        actionEl.click(function(e) {
          var gid;
          e.preventDefault();
          gid = this.dataset.genome;
          return viewController.select(gid, true);
        });
        listEl.append(actionEl);
        el.append(listEl);
      } else if (style === 'select') {
        checked = '';
        if (genomes[g].isSelected) {
          checked = 'checked';
        }
        listEl = jQuery("<li class='" + thiscls + "'></li>");
        labEl = jQuery("<label class='checkbox'>" + name + "</label>");
        actionEl = jQuery("<input class='checkbox' type='checkbox' value='" + g + "' " + checked + "/>");
        actionEl.change(function(e) {
          e.preventDefault();
          return viewController.select(this.value, this.checked);
        });
        labEl.append(actionEl);
        listEl.append(labEl);
        el.append(listEl);
      } else {
        return false;
      }
    }
    return true;
  };

  ListView.prototype.updateCSS = function(gset, genomes) {
    var listEl;
    listEl = jQuery("#" + this.elID);
    if (!((listEl != null) && listEl.length)) {
      throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call ListView method updateCSS().");
    }
    if (gset["public"] != null) {
      this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
    }
    if (gset["private"] != null) {
      this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
    }
    return true;
  };

  ListView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
    var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
    cls = this.cssClass();
    for (_i = 0, _len = changedG.length; _i < _len; _i++) {
      g = changedG[_i];
      thiscls = cls;
      if (genomes[g].cssClass != null) {
        thiscls = cls + ' ' + genomes[g].cssClass;
      }
      liEl = null;
    }
    if (this.style === 'redirect') {
      descriptor = "td > a[data-genome='" + g + "']";
      itemEl = el.find(descriptor);
      if (!((itemEl != null) && itemEl.length)) {
        throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
        return false;
      }
      liEl = itemEl.parent();
    } else if (this.style === 'select') {
      descriptor = "td input[value='" + g + "']";
      itemEl = el.find(descriptor);
      if (!((itemEl != null) && itemEl.length)) {
        throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
        return false;
      }
      liEl = itemEl.parents().eq(1);
    } else {
      return false;
    }
    liEl.attr('class', thiscls);
    return true;
  };

  ListView.prototype.select = function(genome, isSelected) {
    var descriptor, itemEl;
    itemEl = null;
    if (this.style === 'select') {
      descriptor = "li input[value='" + genome + "']";
      itemEl = jQuery(descriptor);
    } else {
      return false;
    }
    if (!((itemEl != null) && itemEl.length)) {
      throw new SuperphyError("List element for genome " + genome + " not found in ListView " + this.elID);
      return false;
    }
    itemEl.prop('checked', isSelected);
    return true;
  };

  ListView.prototype.dump = function(genomes) {
    var fullMeta, g, header, id, k, output, _ref, _ref1;
    fullMeta = {};
    for (k in genomes.visibleMeta) {
      fullMeta[k] = true;
    }
    output = '';
    header = (function() {
      var _i, _len, _ref, _results;
      _ref = genomes.mtypes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        k = _ref[_i];
        _results.push(genomes.metaMap[k]);
      }
      return _results;
    })();
    header.unshift("Genome name");
    output += "#" + header.join("\t") + "\n";
    _ref = genomes.public_genomes;
    for (id in _ref) {
      g = _ref[id];
      output += genomes.label(g, fullMeta, "\t") + "\n";
    }
    _ref1 = genomes.private_genomes;
    for (id in _ref1) {
      g = _ref1[id];
      output += genomes.label(g, fullMeta, "\t") + "\n";
    }
    return {
      ext: 'csv',
      type: 'text/plain',
      data: output
    };
  };

  return ListView;

})(ViewTemplate);


/*
 CLASS GroupView
 
 A special type of genome list that is used to temporarily store the user's
 selected genomes.
 
 Only one 'style' which provides a remove button to remove group from group.
 Will be updated by changes to the meta-display options but not by filtering.
 */

GroupView = (function() {
  function GroupView(parentElem, elNum) {
    this.parentElem = parentElem;
    this.elNum = elNum != null ? elNum : 1;
    this.elID = this.elName + this.elNum;
  }

  GroupView.prototype.type = 'group';

  GroupView.prototype.elNum = 1;

  GroupView.prototype.elName = 'genome_group';

  GroupView.prototype.elID = void 0;

  GroupView.prototype.update = function(genomes) {
    var ingrp, listElem;
    listElem = jQuery("#" + this.elID);
    if (listElem.length) {
      listElem.empty();
    } else {
      listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
      jQuery(this.parentElem).append(listElem);
    }
    ingrp = genomes.grouped(this.elNum);
    this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
    this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
    return true;
  };

  GroupView.prototype.add = function(genomeSet, genomes) {
    var listElem;
    listElem = jQuery("#" + this.elID);
    if (!listElem.length) {
      listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
      jQuery(this.parentElem).append(listElem);
    }
    if (genomeSet["public"] != null) {
      this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
    }
    if (genomeSet["private"] != null) {
      return this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
    }
  };

  GroupView.prototype._appendGenomes = function(el, visibleG, genomes) {
    var actionEl, cls, g, listEl, _i, _len;
    cls = this.cssClass();
    for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
      g = visibleG[_i];
      listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
      actionEl = jQuery("<a href='#' data-genome='" + g + "' data-genome-group='" + this.elNum + "'> <i class='fa fa-times'></a>");
      actionEl.click(function(e) {
        var gid, grp;
        e.preventDefault();
        gid = this.dataset.genome;
        grp = this.dataset.genomeGroup;
        console.log('clicked remove on ' + gid);
        return viewController.removeFromGroup(gid, grp);
      });
      listEl.append(actionEl);
      el.append(listEl);
    }
    return true;
  };

  GroupView.prototype.remove = function(gid) {
    var descriptor, linkEl, listEl;
    listEl = jQuery("#" + this.elID);
    if (!((listEl != null) && listEl.length)) {
      throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call GroupView method remove().");
    }
    descriptor = "li > a[data-genome='" + gid + "']";
    linkEl = listEl.find(descriptor);
    if (!((linkEl != null) && linkEl.length)) {
      throw new SuperphyError("List item element for genome " + gid + " not found in GroupView " + this.elID);
      return false;
    }
    linkEl.parent('li').remove();
    return true;
  };

  GroupView.prototype.cssClass = function() {
    return this.elName + '_item';
  };

  return GroupView;

})();


/*
 CLASS GenomeController
 
 Manages private/public genome list
 */

GenomeController = (function() {
  var mtypesDisplayed;

  function GenomeController(public_genomes, private_genomes, subset) {
    var countPri, countPub, g, i, id, newPri, newPub, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    this.public_genomes = public_genomes;
    this.private_genomes = private_genomes;
    if (subset == null) {
      subset = null;
    }
    if (subset != null) {
      newPub = {};
      newPri = {};
      for (_i = 0, _len = subset.length; _i < _len; _i++) {
        i = subset[_i];
        if (this.public_genomes[i] != null) {
          newPub[i] = this.public_genomes[i];
        } else if (this.private_genomes[i] != null) {
          newPri[i] = this.private_genomes[i];
        }
      }
      this.public_genomes = newPub;
      this.private_genomes = newPri;
    }
    this.update();
    this.filter();
    _ref = this.public_genomes;
    for (g = _j = 0, _len1 = _ref.length; _j < _len1; g = ++_j) {
      id = _ref[g];
      countPub = this.countMeta(g);
    }
    _ref1 = this.private_genomes;
    for (g = _k = 0, _len2 = _ref1.length; _k < _len2; g = ++_k) {
      id = _ref1[g];
      countPri = this.countMeta(g);
    }
    this.genomeSetId = 0;
  }

  GenomeController.prototype.pubVisible = [];

  GenomeController.prototype.pvtVisible = [];

  GenomeController.prototype.visibleMeta = {
    strain: false,
    serotype: false,
    isolation_host: false,
    isolation_source: false,
    isolation_date: false,
    accession: false,
    syndrome: false,
    stx1_subtype: false,
    stx2_subtype: false
  };

  GenomeController.prototype.metaMap = {
    'strain': 'Strain',
    'serotype': 'Serotype',
    'isolation_host': 'Host',
    'isolation_source': 'Source',
    'isolation_date': 'Date of isolation',
    'accession': 'Accession ID',
    'syndrome': 'Symptom / Disease',
    'stx1_subtype': 'Stx1 Subtype',
    'stx2_subtype': 'Stx2 Subtype'
  };

  GenomeController.prototype.mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype', 'accession'];

  GenomeController.prototype.publicRegexp = new RegExp('^public_');

  GenomeController.prototype.privateRegexp = new RegExp('^private_');

  GenomeController.prototype.meta_option = '';

  GenomeController.prototype.filtered = 0;

  mtypesDisplayed = ['serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype'];

  GenomeController.prototype.update = function() {
    var g, id, ma, _ref, _ref1;
    _ref = this.public_genomes;
    for (id in _ref) {
      g = _ref[id];
      ma = this.label(g, this.visibleMeta, null);
      g.viewname = ma.join('|');
      g.meta_array = ma;
    }
    _ref1 = this.private_genomes;
    for (id in _ref1) {
      g = _ref1[id];
      ma = this.label(g, this.visibleMeta, null);
      g.viewname = ma.join('|');
      g.meta_array = ma;
    }
    return true;
  };

  GenomeController.prototype.filter = function(searchTerms) {
    var g, i, pubGenomeIds, pvtGenomeIds, results, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (searchTerms == null) {
      searchTerms = null;
    }
    pubGenomeIds = [];
    pvtGenomeIds = [];
    if (searchTerms != null) {
      results = this._runFilter(searchTerms);
      pubGenomeIds = results["public"];
      pvtGenomeIds = results["private"];
      this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
      if (this.filtered !== 0) {
        _ref = this.public_genomes;
        for (i in _ref) {
          g = _ref[i];
          g.visible = false;
        }
        _ref1 = this.private_genomes;
        for (i in _ref1) {
          g = _ref1[i];
          g.visible = false;
        }
        for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
          g = pubGenomeIds[_i];
          this.public_genomes[g].visible = true;
        }
        for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
          g = pvtGenomeIds[_j];
          this.private_genomes[g].visible = true;
        }
        this.pubVisible = pubGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
          };
        })(this));
        this.pvtVisible = pvtGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
          };
        })(this));
      }
    } else {
      pubGenomeIds = Object.keys(this.public_genomes);
      pvtGenomeIds = Object.keys(this.private_genomes);
      this.filtered = 0;
      _ref2 = this.public_genomes;
      for (i in _ref2) {
        g = _ref2[i];
        g.visible = true;
      }
      _ref3 = this.private_genomes;
      for (i in _ref3) {
        g = _ref3[i];
        g.visible = true;
      }
      this.pubVisible = pubGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
        };
      })(this));
      this.pvtVisible = pvtGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
        };
      })(this));
    }
    this.genomeSetId++;
    return true;
  };

  GenomeController.prototype.countMeta = function(genome, count) {
    var a, _i, _len;
    count = {};
    for (_i = 0, _len = mtypesDisplayed.length; _i < _len; _i++) {
      a = mtypesDisplayed[_i];
      count[a] = {};
    }
    if (count['serotype'][genome.serotype] != null) {
      count['serotype'][genome.serotype]++;
    } else {
      count['serotype'][genome.serotype] = 1;
    }
    if (count['isolation_host'][genome.isolation_host] != null) {
      count['isolation_host'][genome.isolation_host]++;
    } else {
      count['isolation_host'][genome.isolation_host] = 1;
    }
    if (count['isolation_source'][genome.isolation_source] != null) {
      count['isolation_source'][genome.isolation_source]++;
    } else {
      count['isolation_source'][genome.isolation_source] = 1;
    }
    if (count['isolation_date'][genome.isolation_date] != null) {
      count['isolation_date'][genome.isolation_date]++;
    } else {
      count['isolation_date'][genome.isolation_date] = 1;
    }
    if (count['syndrome'][genome.syndrome] != null) {
      count['syndrome'][genome.syndrome]++;
    } else {
      count['syndrome'][genome.syndrome] = 1;
    }
    if (count['stx1_subtype'][genome.stx1_subtype] != null) {
      count['stx1_subtype'][genome.stx1_subtype]++;
    } else {
      count['stx1_subtype'][genome.stx1_subtype] = 1;
    }
    if (count['stx2_subtype'][genome.stx2_subtype] != null) {
      count['stx2_subtype'][genome.stx2_subtype]++;
    } else {
      count['stx2_subtype'][genome.stx2_subtype] = 1;
    }
    return count;
  };

  GenomeController.prototype.filterBySelection = function() {
    var g, gset, i, pubGenomeIds, pvtGenomeIds, _i, _j, _len, _len1, _ref, _ref1;
    gset = this.selected();
    pubGenomeIds = gset["public"];
    pvtGenomeIds = gset["private"];
    this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
    if (this.filtered === 0) {
      this.filter();
    } else {
      _ref = this.public_genomes;
      for (i in _ref) {
        g = _ref[i];
        g.visible = false;
      }
      _ref1 = this.private_genomes;
      for (i in _ref1) {
        g = _ref1[i];
        g.visible = false;
      }
      for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
        g = pubGenomeIds[_i];
        this.public_genomes[g].visible = true;
        this.public_genomes[g].isSelected = false;
      }
      for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
        g = pvtGenomeIds[_j];
        this.private_genomes[g].visible = true;
        this.private_genomes[g].isSelected = false;
      }
      this.pubVisible = pubGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
        };
      })(this));
      this.pvtVisible = pvtGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
        };
      })(this));
    }
    return true;
  };

  GenomeController.prototype._runFilter = function(searchTerms) {
    var firstTerm, id, pubGenomeIds, pubSet, pvtGenomeIds, pvtSet, regex, t, _i, _len;
    if (!typeIsArray(searchTerms)) {
      throw new SuperphyError('Invalid argument. GenomeController method _runFilter() requires array of search term objects as input.');
    }
    pubGenomeIds = Object.keys(this.public_genomes);
    pvtGenomeIds = Object.keys(this.private_genomes);
    firstTerm = true;
    for (_i = 0, _len = searchTerms.length; _i < _len; _i++) {
      t = searchTerms[_i];
      if (firstTerm) {
        if (t.op != null) {
          throw new SuperphyError("Invalid filter input. First search term object cannot contain an operator property 'op'.");
        }
        if (t.dataField !== 'isolation_date') {
          if (t.searchTerm == null) {
            throw new SuperphyError("Invalid filter input. Search term objects must contain a 'searchTerm' property.");
          }
          if (t.dataField == null) {
            throw new SuperphyError("Invalid filter input. Search term objects must contain a 'dataField' property.");
          }
          if (t.negate == null) {
            throw new SuperphyError("Invalid filter input. Search term objects must contain a 'negate' property.");
          }
        } else {
          if (t.dataField == null) {
            throw new SuperphyError("Invalid filter input. Date objects must contain a 'searchTerm' property.");
          }
          if (t.date == null) {
            throw new SuperphyError("Invalid filter input. Date objects must contain a 'date' property.");
          }
          if (t.before == null) {
            throw new SuperphyError("Invalid filter input. Date objects must contain a 'before' property.");
          }
        }
        firstTerm = false;
      } else {
        if (t.op == null) {
          throw new SuperphyError("Invalid filter input. Subsequent search term objects must contain an operator property 'op'.");
        }
      }
      if ((t.op != null) && t.op === 'or') {
        pubSet = [];
        pubSet = [];
        if (t.dataField === 'isolation_date') {
          pubSet = (function() {
            var _j, _len1, _ref, _results;
            _ref = Object.keys(this.public_genomes);
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              id = _ref[_j];
              if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pvtSet = (function() {
            var _j, _len1, _ref, _results;
            _ref = Object.keys(this.private_genomes);
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              id = _ref[_j];
              if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
        } else {
          regex = new RegExp(escapeRegExp(t.searchTerm), "i");
          pubSet = (function() {
            var _j, _len1, _ref, _results;
            _ref = Object.keys(this.public_genomes);
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              id = _ref[_j];
              if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pvtSet = (function() {
            var _j, _len1, _ref, _results;
            _ref = Object.keys(this.private_genomes);
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              id = _ref[_j];
              if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
        }
        pubGenomeIds = this.union(pubGenomeIds, pubSet);
        pvtGenomeIds = this.union(pvtGenomeIds, pvtSet);
      } else {
        if (t.dataField === 'isolation_date') {
          pubSet = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
              id = pubGenomeIds[_j];
              if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pvtSet = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
              id = pvtGenomeIds[_j];
              if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pubGenomeIds = pubSet;
          pvtGenomeIds = pvtSet;
        } else {
          regex = new RegExp(escapeRegExp(t.searchTerm), "i");
          pubSet = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
              id = pubGenomeIds[_j];
              if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pvtSet = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
              id = pvtGenomeIds[_j];
              if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pubGenomeIds = pubSet;
          pvtGenomeIds = pvtSet;
        }
      }
    }
    return {
      "public": pubGenomeIds,
      "private": pvtGenomeIds
    };
  };

  GenomeController.prototype.match = function(genome, key, regex, negate) {
    var val;
    if (genome[key] == null) {
      return false;
    }
    val = genome[key];
    if (typeIsArray(genome[key])) {
      val = genome[key].toString();
    }
    if (regex.test(val)) {
      if (!negate) {
        return true;
      } else {
        return false;
      }
    } else {
      if (negate) {
        return true;
      } else {
        return false;
      }
    }
  };

  GenomeController.prototype.passDate = function(genome, before, date) {
    var d2, val;
    if (genome['isolation_date'] == null) {
      return false;
    }
    val = genome['isolation_date'][0];
    d2 = Date.parse(val);
    if (before) {
      if (d2 < date) {
        return true;
      } else {
        return false;
      }
    } else {
      if (d2 > date) {
        return true;
      } else {
        return false;
      }
    }
  };

  GenomeController.prototype.union = function(arr1, arr2) {
    var arr, i, _i, _len, _ref;
    arr = [];
    _ref = arr1.concat(arr2);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      if (__indexOf.call(arr, i) < 0) {
        arr.push(i);
      }
    }
    return arr;
  };

  GenomeController.prototype.label = function(genome, visibleMeta, joinStr) {
    var lab, na, t, _i, _len, _ref, _ref1, _ref2;
    na = 'NA';
    lab = [genome.displayname];
    _ref = this.mtypes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      if (t !== 'accession') {
        if (visibleMeta[t]) {
          lab.push(((_ref1 = genome[t]) != null ? _ref1 : [na]).join(' '));
        }
      }
    }
    if (visibleMeta.accession) {
      lab.push((_ref2 = genome.primary_dbxref) != null ? _ref2 : na);
    }
    if (joinStr != null) {
      return lab.join(joinStr);
    } else {
      return lab;
    }
  };

  GenomeController.prototype.updateMeta = function(option, checked) {
    this.meta_option = option;
    console.log(option);
    if (this.visibleMeta[option] == null) {
      throw new SuperphyError('unrecognized option in GenomeController method updateMeta()');
      return false;
    }
    if (!(checked === true || checked === false)) {
      throw new SuperphyError('invalid checked argument in GenomeController method updateMeta()');
      return false;
    }
    this.visibleMeta[option] = checked;
    this.update();
    return true;
  };

  GenomeController.prototype.select = function(g, checked) {
    if (this.publicRegexp.test(g)) {
      this.public_genomes[g].isSelected = checked;
    } else {
      this.private_genomes[g].isSelected = checked;
    }
    return true;
  };

  GenomeController.prototype.selected = function() {
    var k, pub, pvt, v;
    pub = [];
    pvt = [];
    pub = (function() {
      var _ref, _results;
      _ref = this.public_genomes;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if ((v.isSelected != null) && v.isSelected === true) {
          _results.push(k);
        }
      }
      return _results;
    }).call(this);
    pvt = (function() {
      var _ref, _results;
      _ref = this.private_genomes;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if ((v.isSelected != null) && v.isSelected === true) {
          _results.push(k);
        }
      }
      return _results;
    }).call(this);
    return {
      "public": pub,
      "private": pvt
    };
  };

  GenomeController.prototype.unselectAll = function() {
    var k, v, _ref, _ref1, _results;
    _ref = this.public_genomes;
    for (k in _ref) {
      v = _ref[k];
      if (v.isSelected != null) {
        v.isSelected = false;
      }
    }
    _ref1 = this.private_genomes;
    _results = [];
    for (k in _ref1) {
      v = _ref1[k];
      if (v.isSelected != null) {
        _results.push(v.isSelected = false);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  GenomeController.prototype.assignGroup = function(gset, grpNum) {
    var cls, g, _i, _j, _len, _len1, _ref, _ref1;
    if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
      _ref = gset["public"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        this.public_genomes[g].assignedGroup = grpNum;
        cls = 'genome_group' + grpNum;
        this.public_genomes[g].cssClass = cls;
      }
    }
    if ((gset["private"] != null) && typeof gset["private"] !== 'undefined') {
      _ref1 = gset["private"];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        g = _ref1[_j];
        this.private_genomes[g].assignedGroup = grpNum;
        cls = 'genome_group' + grpNum;
        this.private_genomes[g].cssClass = cls;
      }
    }
    return true;
  };

  GenomeController.prototype.deleteGroup = function(gset) {
    var g, _i, _j, _len, _len1, _ref, _ref1;
    if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
      _ref = gset["public"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        this.public_genomes[g].assignedGroup = null;
        this.public_genomes[g].cssClass = null;
      }
    }
    if ((gset["private"] != null) && typeof gset["public"] !== 'undefined') {
      _ref1 = gset["private"];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        g = _ref1[_j];
        this.private_genomes[g].assignedGroup = null;
        this.private_genomes[g].cssClass = null;
      }
    }
    return true;
  };

  GenomeController.prototype.grouped = function(grpNum) {
    var k, pub, pvt, v;
    pub = [];
    pvt = [];
    pub = (function() {
      var _ref, _results;
      _ref = this.public_genomes;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
          _results.push(k);
        }
      }
      return _results;
    }).call(this);
    pvt = (function() {
      var _ref, _results;
      _ref = this.private_genomes;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
          _results.push(k);
        }
      }
      return _results;
    }).call(this);
    return {
      "public": pub,
      "private": pvt
    };
  };

  GenomeController.prototype.genomeSet = function(gids) {
    var g, pub, pvt;
    pub = [];
    pvt = [];
    pub = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = gids.length; _i < _len; _i++) {
        g = gids[_i];
        if (this.publicRegexp.test(g)) {
          _results.push(g);
        }
      }
      return _results;
    }).call(this);
    pvt = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = gids.length; _i < _len; _i++) {
        g = gids[_i];
        if (this.privateRegexp.test(g)) {
          _results.push(g);
        }
      }
      return _results;
    }).call(this);
    return {
      "public": pub,
      "private": pvt
    };
  };

  GenomeController.prototype.genome = function(gid) {
    if (this.publicRegexp.test(gid)) {
      return this.public_genomes[gid];
    } else {
      return this.private_genomes[gid];
    }
  };

  GenomeController.prototype.sort = function(gids, metaField, asc) {
    var that;
    if (!gids.length) {
      return gids;
    }
    that = this;
    gids.sort(function(a, b) {
      var aField, aName, aObj, bField, bName, bObj;
      aObj = that.genome(a);
      bObj = that.genome(b);
      aField = aObj[metaField];
      aName = aObj.displayname.toLowerCase();
      bField = bObj[metaField];
      bName = bObj.displayname.toLowerCase();
      if ((aField != null) && (bField != null)) {
        if (typeIsArray(aField)) {
          aField = aField.join('').toLowerCase();
          bField = bField.join('').toLowerCase();
        } else {
          aField = aField.toLowerCase();
          bField = bField.toLowerCase();
        }
        if (aField < bField) {
          return -1;
        } else if (aField > bField) {
          return 1;
        } else {
          if (aName < bName) {
            return -1;
          } else if (aName > bName) {
            return 1;
          } else {
            return 0;
          }
        }
      } else {
        if ((aField != null) && (bField == null)) {
          return -1;
        } else if ((bField != null) && (aField == null)) {
          return 1;
        } else {
          if (aName < bName) {
            return -1;
          } else if (aName > bName) {
            return 1;
          } else {
            return 0;
          }
        }
      }
    });
    if (!asc) {
      gids.reverse();
    }
    return gids;
  };

  GenomeController.prototype.find = function(searchStr) {
    var genomes, id, pubSet, pvtSet, regex;
    regex = new RegExp(escapeRegExp(searchStr), "i");
    pubSet = (function() {
      var _i, _len, _ref, _results;
      _ref = this.pubVisible;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        if (this.match(this.public_genomes[id], 'displayname', regex, false)) {
          _results.push(id);
        }
      }
      return _results;
    }).call(this);
    pvtSet = (function() {
      var _i, _len, _ref, _results;
      _ref = this.pvtVisible;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        if (this.match(this.private_genomes[id], 'displayname', regex, false)) {
          _results.push(id);
        }
      }
      return _results;
    }).call(this);
    genomes = pubSet.concat(pvtSet);
    console.log(genomes);
    return genomes;
  };

  return GenomeController;

})();


/*
 CLASS LocusController
 
 Manages Locus/Gene allele data
 */

LocusController = (function() {
  function LocusController(locusData) {
    this.locusData = locusData;
  }

  LocusController.prototype.emptyString = "<span class='locus_group0'>No alleles detected</span>";

  LocusController.prototype.locusString = function(id, locusID) {
    var g, genomeID, l, res, str;
    if (locusID == null) {
      locusID = null;
    }
    genomeID;
    if (locusID != null) {
      genomeID = id;
    } else {
      res = parseHeader(id);
      genomeID = res[1];
      locusID = res[2];
      if (!((genomeID != null) && (locusID != null))) {
        throw new SuperphyError("Invalid locus ID format: " + id + ".");
      }
    }
    g = this.locusData[genomeID];
    if (g == null) {
      throw new SuperphyError("Unknown genome: " + genomeID + ".");
    }
    l = g[locusID];
    if (l == null) {
      throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
    }
    str = '';
    if (l.copy > 1) {
      str = " (" + l.copy + " copy)";
    }
    return str;
  };

  LocusController.prototype.locusNode = function(id, locusID) {
    var g, genomeID, l, res, str;
    if (locusID == null) {
      locusID = null;
    }
    genomeID;
    if (locusID != null) {
      genomeID = id;
    } else {
      res = parseHeader(id);
      genomeID = res[1];
      locusID = res[2];
      if (!((genomeID != null) && (locusID != null))) {
        throw new SuperphyError("Invalid locus ID format: " + id + ".");
      }
    }
    g = this.locusData[genomeID];
    if (g == null) {
      throw new SuperphyError("Unknown genome: " + genomeID + ".");
    }
    l = g[locusID];
    if (l == null) {
      throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
    }
    str;
    if (l.copy > 1) {
      str = " (" + l.copy + " copy)";
    } else {
      str = '';
    }
    return [str, null];
  };

  LocusController.prototype.genomeString = function(genomeID) {
    var g, str;
    str = ' - ';
    g = this.locusData[genomeID];
    if ((g != null) && g.num_copies > 0) {
      str += "<span class='locus_group1'>" + g.num_copies + " allele(s)</span>";
    } else {
      str += this.emptyString;
    }
    return str;
  };

  LocusController.prototype.count = function(genomes) {
    var counts_list;
    counts_list = [];
    this._count(genomes.pubVisible, counts_list);
    this._count(genomes.pvtVisible, counts_list);
    return counts_list;
  };

  LocusController.prototype._count = function(genomeList, counts_list) {
    var g, gID, _i, _len;
    for (_i = 0, _len = genomeList.length; _i < _len; _i++) {
      gID = genomeList[_i];
      g = this.locusData[gID];
      if (g != null) {
        counts_list.push(g.num_copies);
      } else {
        counts_list.push(0);
      }
    }
    return true;
  };

  return LocusController;

})();

if (!root.LocusController) {
  root.LocusController = LocusController;
}


/*
 CLASS StxController
 
 Manages Stx data
 */

StxController = (function() {
  function StxController(locusData) {
    this.locusData = locusData;
    this.dataValues = {};
    this.format();
  }

  StxController.prototype.emptyString = "<span class='locus_group0'>NA</span>";

  StxController.prototype.format = function() {
    var dataGroup, g, grpNum, k, o, val, _ref;
    for (g in this.locusData) {
      _ref = this.locusData[g];
      for (k in _ref) {
        o = _ref[k];
        val = o.data;
        dataGroup = 0;
        if (this.dataValues[val] != null) {
          dataGroup = this.dataValues[val];
        } else {
          grpNum = Object.keys(this.dataValues).length;
          grpNum++;
          this.dataValues[val] = grpNum;
          dataGroup = grpNum;
        }
        o.cls = "locus_group" + dataGroup;
        o.group = dataGroup;
        o.dataString = "<span class='" + o.cls + "'>" + val + "</span>";
      }
    }
    return true;
  };

  StxController.prototype.locusString = function(id, locusID) {
    var g, genomeID, l, res, str;
    if (locusID == null) {
      locusID = null;
    }
    genomeID;
    if (locusID != null) {
      genomeID = id;
    } else {
      res = parseHeader(id);
      genomeID = res[1];
      locusID = res[2];
      if (!((genomeID != null) && (locusID != null))) {
        throw new SuperphyError("Invalid locus ID format: " + id + ".");
      }
    }
    g = this.locusData[genomeID];
    if (g == null) {
      throw new SuperphyError("Unknown genome: " + genomeID + ".");
    }
    l = g[locusID];
    if (l == null) {
      throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
    }
    str;
    if (l.copy > 1) {
      str = " (" + l.copy + " copy) -  " + l.dataString;
    } else {
      str = ' - ' + l.dataString;
    }
    return str;
  };

  StxController.prototype.locusNode = function(id, locusID) {
    var g, genomeID, l, res, str;
    if (locusID == null) {
      locusID = null;
    }
    genomeID;
    if (locusID != null) {
      genomeID = id;
    } else {
      res = parseHeader(id);
      genomeID = res[1];
      locusID = res[2];
      if (!((genomeID != null) && (locusID != null))) {
        throw new SuperphyError("Invalid locus ID format: " + id + ".");
      }
    }
    g = this.locusData[genomeID];
    if (g == null) {
      throw new SuperphyError("Unknown genome: " + genomeID + ".");
    }
    l = g[locusID];
    if (l == null) {
      throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
    }
    str;
    if (l.copy > 1) {
      str = " (" + l.copy + " copy) -  " + l.data;
    } else {
      str = ' - ' + l.data;
    }
    return [str, l.group];
  };

  StxController.prototype.genomeString = function(genomeID) {
    var ds, g, k, str, v;
    str = ' - ';
    g = this.locusData[genomeID];
    if (g != null) {
      ds = (function() {
        var _results;
        _results = [];
        for (k in g) {
          v = g[k];
          _results.push(v.dataString);
        }
        return _results;
      })();
      str += ds.join(',');
    } else {
      str += this.emptyString;
    }
    return str;
  };

  StxController.prototype.count = function(genomes) {
    var uniqueValues;
    uniqueValues = {
      'NA': 0
    };
    this._count(genomes.pubVisible, uniqueValues);
    this._count(genomes.pvtVisible, uniqueValues);
    return uniqueValues;
  };

  StxController.prototype._count = function(genomeList, uniqueValues) {
    var g, gID, k, v, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = genomeList.length; _i < _len; _i++) {
      gID = genomeList[_i];
      g = this.locusData[gID];
      if (g != null) {
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (k in g) {
            v = g[k];
            if (uniqueValues[v.data] != null) {
              _results1.push(uniqueValues[v.data]++);
            } else {
              _results1.push(uniqueValues[v.data] = 1);
            }
          }
          return _results1;
        })());
      } else {
        _results.push(uniqueValues['NA']++);
      }
    }
    return _results;
  };

  return StxController;

})();

if (!root.StxController) {
  root.StxController = StxController;
}


/*
 CLASS SelectionView
 
 A special type of genome list that is used to temporarily store the user's
 selected genomes.
 
 Only one 'style' which provides a remove button to remove group from group.
 Will be updated by changes to the meta-display options but not by filtering.
 */

SelectionView = (function() {
  function SelectionView(parentElem, countElem, elNum) {
    this.parentElem = parentElem;
    this.countElem = countElem != null ? countElem : null;
    this.elNum = elNum != null ? elNum : 1;
    this.elID = this.elName + this.elNum;
    this.count = 0;
  }

  SelectionView.prototype.type = 'selected';

  SelectionView.prototype.elNum = 1;

  SelectionView.prototype.elName = 'selected_genomes';

  SelectionView.prototype.elID = void 0;

  SelectionView.prototype.update = function(genomes) {
    var ingrp, listElem;
    listElem = jQuery("#" + this.elID);
    if (listElem.length) {
      listElem.empty();
    } else {
      listElem = jQuery("<ul id='" + this.elID + "' class='selected-group-list'/>");
      jQuery(this.parentElem).append(listElem);
    }
    ingrp = genomes.selected();
    this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
    this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
    this.count = ingrp["public"].length;
    this.count += ingrp["private"].length;
    this._updateCount();
    return true;
  };

  SelectionView.prototype._appendGenomes = function(el, visibleG, genomes) {
    var actionEl, cls, g, listEl, _i, _len;
    cls = this.cssClass();
    for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
      g = visibleG[_i];
      listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
      actionEl = jQuery("<a href='#' data-genome='" + g + "'> <i class='fa fa-times'></a>");
      actionEl.click(function(e) {
        var gid;
        e.preventDefault();
        gid = this.dataset.genome;
        console.log('clicked unselect on ' + gid);
        return viewController.select(gid, false);
      });
      listEl.append(actionEl);
      el.append(listEl);
    }
    return true;
  };

  SelectionView.prototype.select = function(genomeID, genomes, checked) {
    var gset;
    if (checked) {
      gset = genomes.genomeSet([genomeID]);
      this.add(gset, genomes);
    } else {
      this.remove(genomeID);
    }
    return true;
  };

  SelectionView.prototype.add = function(genomeSet, genomes) {
    var listElem;
    listElem = jQuery("#" + this.elID);
    if (!listElem.length) {
      listElem = jQuery("<ul id='" + this.elID + "' class='selected-group-list'/>");
      jQuery(this.parentElem).append(listElem);
    }
    if (genomeSet["public"] != null) {
      this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
    }
    if (genomeSet["private"] != null) {
      this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
    }
    this.count += genomeSet["public"].length;
    this.count += genomeSet["private"].length;
    return this._updateCount();
  };

  SelectionView.prototype.remove = function(gid) {
    var descriptor, linkEl, listEl;
    listEl = jQuery("#" + this.elID);
    if (!((listEl != null) && listEl.length)) {
      throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call SelectionView method remove().");
    }
    descriptor = "li > a[data-genome='" + gid + "']";
    linkEl = listEl.find(descriptor);
    if (!((linkEl != null) && linkEl.length)) {
      throw new SuperphyError("List item element for genome " + gid + " not found in SelectionView");
      return false;
    }
    linkEl.parent('li').remove();
    this.count--;
    this._updateCount();
    return true;
  };

  SelectionView.prototype.cssClass = function() {
    return this.elName + '_item';
  };

  SelectionView.prototype._updateCount = function() {
    var innerElem;
    if (this.countElem != null) {
      innerElem = this.countElem.find('span.selected_genome_count_text');
      if (!innerElem.length) {
        innerElem = jQuery("<span class='selected_genome_count_text'></span>").appendTo(this.countElem);
      }
      innerElem.text("" + this.count + " genomes selected");
    }
    return true;
  };

  return SelectionView;

})();


/*

  HELPER FUNCTIONS
 */

parseHeader = function(str) {
  var match;
  match = /^((?:public|private)_\d+)\|(\d+)/.exec(str);
  return match;
};

typeIsArray = Array.isArray || function(value) {
  return {}.toString.call(value) === '[object Array]';
};

escapeRegExp = function(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};

cmp = function(a, b) {
  if (a > b) {
    return 1;
  } else if (a < b) {
    return -1;
  } else {
    return 0;
  }
};

trimInput = function(str, field) {
  var term;
  if (str != null) {
    term = jQuery.trim(str);
    if (term.length) {
      return term;
    } else {
      alert("Error: " + field + " is empty.");
      return null;
    }
  } else {
    alert("Error: " + field + " is empty.");
    return null;
  }
};

superphyAlert = function(output_msg, title_msg) {
  if (output_msg == null) {
    output_msg = 'No Message to Display.';
  }
  if (title_msg == null) {
    title_msg = 'Alert';
  }
  return jQuery("<div></div>").html(output_msg).dialog({
    title: title_msg,
    resizable: false,
    modal: true,
    buttons: {
      "Ok": function() {
        return jQuery(this).dialog("close");
      }
    }
  });
};

superphyMetaOntology = {
  "syndromes": ["Bacteriuria", "Bloody diarrhea", "Crohn's Disease", "Diarrhea", "Gastroenteritis", "Hemolytic-uremic syndrome", "Hemorrhagic colitis", "Mastitis", "Meningitis", "Peritonitis", "Pneumonia", "Pyelonephritis", "Septicaemia", "Ulcerateive colitis", "Urinary tract infection (cystitis)"],
  "hosts": ["Bos taurus (cow)", "Canis lupus familiaris (dog)", "Environmental source", "Felis catus (cat)", "Gallus gallus (chicken)", "Homo sapiens (human)", "Mus musculus (mouse)", "Oryctolagus cuniculus (rabbit)", "Ovis aries (sheep)", "Sus scrofa (pig)"],
  "sources": ["Blood", "Cecum", "Colon", "Feces", "Ileum", "Intestine", "Liver", "Meat", "Meat-based food", "Stool", "Urine", "Vegetable-based food", "Water", "Yolk", "cerebrospinal_fluid"]
};
