// Generated by CoffeeScript 1.8.0

/*


 File: superphy_tree.coffee
 Desc: Phylogenetic Tree View Class
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 20th, 2013
 */
var TreeView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

d3.selection.prototype.moveToFront = function() {
  return this.each(function() {
    return this.parentNode.appendChild(this);
  });
};


/*
 CLASS TreeView
  
 Phylogenetic tree view
 
 Can be genome- or locus-based
 Returns genome ID to redirect/select if leaf node is clicked
 */

TreeView = (function(_super) {
  var colours, total_height, visible_bars;

  __extends(TreeView, _super);

  function TreeView(parentElem, style, elNum, genomes, treeArgs) {
    var all_genomes, dialog, legendID, m, n, num, totalCount, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    this.parentElem = parentElem;
    this.style = style;
    this.elNum = elNum;
    this.genomes = genomes;
    if (!(treeArgs.length > 0)) {
      throw new SuperphyError('Missing argument. TreeView constructor requires JSON tree object.');
    }
    this.root = this.trueRoot = treeArgs[0];
    this.currentGenomeSet = -1;
    this.dim = {
      w: 700,
      h: 800
    };
    this.margin = {
      top: 20,
      right: 180,
      bottom: 20,
      left: 20
    };
    if (treeArgs[1] != null) {
      this.locusData = treeArgs[1];
    }
    if (treeArgs[2] != null) {
      this.dim = treeArgs[2];
    }
    if (treeArgs[3] != null) {
      this.margin = treeArgs[3];
    }
    TreeView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
    this.width = this.dim.w - this.margin.right - this.margin.left;
    this.height = this.dim.h - this.margin.top - this.margin.bottom;
    this.xzoom = d3.scale.linear().domain([0, this.width]).range([0, this.width]);
    this.yzoom = d3.scale.linear().domain([0, this.height]).range([0, this.height]);
    this.leafCounter = 0;
    this.cluster = d3.layout.cluster().size([this.width, this.height]).sort(null).value(function(d) {
      return Number(d.length);
    }).separation((function(_this) {
      return function(a, b) {
        var a_height, b_height;
        _this.leafCounter += 1;
        a_height = 1;
        b_height = 1;
        if ((a._children != null) && visible_bars > 1) {
          a_height = visible_bars;
        } else {
          a_height = 2;
        }
        if ((b._children != null) && visible_bars > 1) {
          b_height = visible_bars;
        } else {
          b_height = 2;
        }
        return a_height + b_height;
      };
    })(this));
    legendID = "tree_legend" + this.elNum;
    this._treeOps(this.parentElem, legendID);
    jQuery("<div id='" + this.elID + "' class='" + (this.cssClass()) + "'></div>").appendTo(this.parentElem);
    this.wrap = d3.select("#" + this.elID).append("svg").attr("width", this.dim.w).attr("height", this.dim.h).style("-webkit-backface-visibility", "hidden");
    this.scalePos = {
      x: 10,
      y: 10
    };
    this.scaleBar = this.wrap.append("g").attr("transform", "translate(" + this.scalePos.x + "," + this.scalePos.y + ")").attr("class", "scalebar");
    this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
    num = this.elNum - 1;
    this.zoom = d3.behavior.zoom().x(this.xzoom).y(this.yzoom).scaleExtent([1, 8]).on("zoom", function() {
      return viewController.getView(num).zoomed();
    });
    this.wrap.call(this.zoom);
    this.scaleBar.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 1).attr('y2', 0);
    this.scaleBar.append('text').attr("dx", "0").attr("dy", "1em").attr("text-anchor", "start");
    jQuery("<div id='" + legendID + "' class='genome_tree_legend'></div>").appendTo(this.parentElem);
    this.wrap2 = d3.select("#" + legendID).append("svg").attr("width", this.dim.w).attr("height", 120).style("-webkit-backface-visibility", "hidden");
    this.legend = this.wrap2.append("g").attr("transform", "translate(" + 5 + "," + 5 + ")");
    this._legend(this.legend);
    if (this.style === 'select') {
      dialog = jQuery('#dialog-clade-select');
      if (!dialog.length) {
        dialog = jQuery('<div id="dialog-clade-select"></div>').appendTo('body');
        dialog.text("Select/unselect genomes in clade:").dialog({
          dialogClass: 'noTitleStuff',
          autoOpen: false,
          resizable: false,
          height: 120,
          modal: true,
          buttons: {
            Select: function() {
              var node;
              node = jQuery(this).data("clade-node");
              viewController.getView(num).selectClade(node, true);
              return jQuery(this).dialog("close");
            },
            Unselect: function() {
              var node;
              node = jQuery(this).data("clade-node");
              viewController.getView(num).selectClade(node, false);
              return jQuery(this).dialog("close");
            },
            Cancel: function() {
              return jQuery(this).dialog("close");
            }
          }
        });
      }
    }
    this.mtypesDisplayed = ['serotype', 'isolation_host', 'isolation_source', 'syndrome', 'stx1_subtype', 'stx2_subtype'];
    totalCount = {};
    _ref = this.mtypesDisplayed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      totalCount[m] = {};
    }
    all_genomes = (Object.keys(this.genomes.public_genomes)).concat(Object.keys(this.genomes.private_genomes));
    this.countMeta(totalCount, all_genomes);
    this.metaOntology = {};
    this.tt_mtitle = {};
    _ref1 = this.mtypesDisplayed;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      m = _ref1[_j];
      this.metaOntology[m] = [];
      this.tt_mtitle[m] = new String();
      this.metaOntology[m] = Object.keys(totalCount[m]).sort(function(a, b) {
        return totalCount[m][b] - totalCount[m][a];
      });
      if (m === "isolation_host" || m === "isolation_source") {
        this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
        this.tt_mtitle[m] = this.tt_mtitle[m].replace("_", " ");
        this.tt_mtitle[m] = this.tt_mtitle[m].slice(0, 10) + this.tt_mtitle[m].charAt(10).toUpperCase() + this.tt_mtitle[m].slice(11);
      }
      if (m === "syndrome") {
        this.tt_mtitle[m] = "Symptoms/Diseases";
      }
      if (m === "stx1_subtype" || m === "stx2_subtype") {
        this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
        this.tt_mtitle[m] = this.tt_mtitle[m].replace("_", " ");
        this.tt_mtitle[m] = this.tt_mtitle[m].slice(0, 5) + this.tt_mtitle[m].charAt(5).toUpperCase() + this.tt_mtitle[m].slice(6);
      }
      if (m === "serotype") {
        this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
      }
    }
    this.nodes = this.cluster.nodes(this.root);
    _ref2 = this.nodes;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      n = _ref2[_k];
      n.tt_table_last = new String();
      n.tt_table = {};
      n.tt_table_partial = {};
      n.tt_sub_table = {};
      n.other_count = {};
      _ref3 = this.mtypesDisplayed;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        m = _ref3[_l];
        n.tt_table_partial[m] = new String();
        n.tt_sub_table[m] = new String();
        n.tt_table[m] = new String();
        n.other_count[m] = 0;
      }
    }
    this._prepTree();
    true;
  }

  TreeView.prototype.activeGroup = [];

  TreeView.prototype.rect_block = '';

  TreeView.prototype.type = 'tree';

  TreeView.prototype.elName = 'genome_tree';

  TreeView.prototype.nodeId = 0;

  TreeView.prototype.nonMetaUpdate = false;

  TreeView.prototype.duration = 1000;

  TreeView.prototype.expandDepth = 10;

  visible_bars = 0;

  total_height = 0;

  TreeView.prototype.levelTracker = 0;

  TreeView.prototype.mtypes_selected = [];

  TreeView.prototype.x_factor = 1.5;

  TreeView.prototype.y_factor = 5000;

  colours = {
    'serotype': ['#236932', '#468554', '#6AA276', '#8DBE98', '#B0DABA', '#D4F7DC', '#e9fbed'],
    'isolation_host': ['#a70209', '#b3262c', '#c04a4f', '#cc6e72', '#d99295', '#e5b6b8', '#f2dadb'],
    'isolation_source': ['#3741ae', '#535cb9', '#7077c5', '#8c92d0', '#a9addc', '#c5c8e7', '#e2e3f3'],
    'syndrome': ['#962ba6', '#a549b2', '#b467bf', '#c385cc', '#d2a4d8', '#e1c2e5', '#f0e0f2'],
    'stx1_subtype': ['#F05C00', '#EF7123', '#EE8746', '#ED9D69', '#ECB28C', '#EBC8AF', '#EADED2'],
    'stx2_subtype': ['#35a6a7', '#51b2b3', '#6ebfc0', '#8bcccc', '#a8d8d9', '#c5e5e5', '#e2f2f2']
  };

  TreeView.prototype.update = function(genomes, sourceNode) {
    var bar_count, centred, cladeSelect, cmdBox, currLeaves, dt, elID, i, iNodes, id, j, leaves, linksEnter, m, n, nodesEnter, nodesExit, nodesUpdate, num, oldRoot, svgLinks, svgNode, svgNodes, t1, t2, targetLen, unit, y, yedge, ypos, yshift, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;
    if (sourceNode == null) {
      sourceNode = null;
    }
    this.leafCounter = 0;
    if (this.mtypesDisplayed.indexOf(genomes.meta_option) > -1) {
      if (this.mtypes_selected.indexOf(genomes.meta_option) > -1) {
        if (!this.nonMetaUpdate) {
          this.mtypes_selected.splice(this.mtypes_selected.indexOf(genomes.meta_option), 1);
        }
      } else {
        if (!this.nonMetaUpdate) {
          if (genomes.meta_option.length !== 0) {
            this.mtypes_selected.push(genomes.meta_option);
          }
        }
      }
    }
    visible_bars = this.mtypes_selected.length;
    t1 = new Date();
    oldRoot = this.root;
    this._sync(genomes);
    this.nodes = this.cluster.nodes(this.root);
    if (sourceNode == null) {
      sourceNode = this.root;
    }
    this.launchPt = {
      x: sourceNode.x,
      y: sourceNode.y,
      x0: sourceNode.x0,
      y0: sourceNode.y0
    };
    if (this.reformat) {
      this._scale();
      targetLen = 30;
      unit = targetLen / this.branch_scale_factor_y;
      unit = Math.round(unit * 10000) / 10000;
      this.scaleLength = unit * this.branch_scale_factor_y;
      this.scaleBar.select('line').attr('x1', 0).attr('x2', this.scaleLength).attr('y1', 0).attr('y2', 0);
      this.scaleBar.select('text').text("" + unit + " branch length units");
      this.zoom.translate([0, 0]).scale(1);
      this.scaleBar.select("line").attr('transform', 'scale(1,1)');
      this.reformat = false;
    }
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      n.y = n.sum_length * this.branch_scale_factor_y;
      if (visible_bars <= 1) {
        n.x = n.x * this.branch_scale_factor_x * this.leafCounter / 24;
      }
      if (visible_bars > 1) {
        n.x = n.x * this.branch_scale_factor_x * this.leafCounter / 24 * ((visible_bars * 0.3) + 1);
      }
      n.width = [];
      n.xpos = 0;
    }
    if (this.expansionContraction) {
      yedge = this.width - 30;
      ypos = this.edgeNode.y;
      if (ypos > yedge) {
        yshift = ypos - yedge;
        _ref1 = this.nodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          n = _ref1[_j];
          n.y = n.y - yshift;
        }
      }
      this.expansionContraction = false;
    }
    svgNodes = this.canvas.selectAll("g.treenode").data(this.nodes, function(d) {
      return d.id;
    });
    svgLinks = this.canvas.selectAll("path.treelink").data(this.cluster.links(this.nodes), function(d) {
      return d.target.id;
    });
    linksEnter = svgLinks.enter().insert("path").attr("class", "treelink").attr("d", (function(_this) {
      return function(d) {
        var p;
        p = {
          x: _this.launchPt.x0,
          y: _this.launchPt.y0
        };
        return _this._step({
          source: p,
          target: p
        });
      };
    })(this));
    svgLinks.transition().duration(this.duration).attr("d", this._step);
    svgLinks.exit().transition().duration(this.duration).attr("d", (function(_this) {
      return function(d) {
        var o;
        o = {
          x: _this.launchPt.x,
          y: _this.launchPt.y
        };
        return _this._step({
          source: o,
          target: o
        });
      };
    })(this)).remove();
    currLeaves = svgNodes.filter(function(d) {
      return d.leaf;
    }).attr("class", (function(_this) {
      return function(d) {
        return _this._classList(d);
      };
    })(this)).on("click", function(d) {
      if (d.assignedGroup == null) {
        return viewController.select(d.genome, !d.selected);
      } else {
        return null;
      }
    });
    currLeaves.select("circle").style("fill", (function(_this) {
      return function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      };
    })(this));
    svgNodes.select("text").text(function(d) {
      if (d.leaf) {
        return d.viewname;
      } else {
        return d.label;
      }
    });
    svgNodes.filter(function(d) {
      return d.children && !d.leaf;
    }).select("text").transition().duration(this.duration).style("fill-opacity", 1e-6);
    nodesEnter = svgNodes.enter().append("g").attr("class", (function(_this) {
      return function(d) {
        return _this._classList(d);
      };
    })(this)).attr("id", function(d) {
      return "treenode" + d.id;
    }).attr("transform", (function(_this) {
      return function(d) {
        return "translate(" + _this.launchPt.y0 + "," + _this.launchPt.x0 + ")";
      };
    })(this));
    leaves = nodesEnter.filter(function(d) {
      return d.leaf;
    });
    leaves.append("rect").attr('width', 11).attr('height', 11).attr('x', -5.5).attr('y', -5.5).style('fill', (function(_this) {
      return function(d) {
        if (_this.activeGroup.indexOf(d.name) > -1) {
          return 'steelblue';
        } else {
          return '#fff';
        }
      };
    })(this));
    leaves.append("circle").attr("r", 1e-6).style("fill", (function(_this) {
      return function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      };
    })(this));
    if (this.style === 'select') {
      leaves.on("click", function(d) {
        if (d.assignedGroup == null) {
          return viewController.select(d.genome, !d.selected);
        } else {
          return null;
        }
      });
    } else {
      leaves.on("click", function(d) {
        return viewController.redirect(d.genome);
      });
    }
    nodesEnter.append("text").attr("class", "treelabel").attr("x", function(n) {
      if (n._children != null) {
        return 10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5) + 10;
      } else {
        return "0.6em";
      }
    }).attr("dy", ".4em").attr("text-anchor", "start").text(function(d) {
      if (d.leaf) {
        return d.viewname;
      } else {
        return d.label;
      }
    }).style("fill-opacity", 1e-6);
    iNodes = nodesEnter.filter(function(n) {
      return !n.leaf && !n.root;
    });
    num = this.elNum - 1;
    this.rect_block = svgNodes.append('g');
    svgNodes.append('rect').style("fill", "red").style("stroke-width", 0.5).style("stroke", "black").attr("class", "genomeMeter").attr("width", function(n) {
      if ((n._children != null) && !$(this).hasClass('genomeMeter')) {
        return 10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5);
      } else {
        return 0;
      }
    }).attr("height", 7).attr("y", -3).attr("x", 4);
    jQuery(document).ready(function() {
      return jQuery('input[name="meta-option"]').each(function(obj) {
        jQuery('#' + this.name + '_' + this.value).hide();
        if (this.checked) {
          return jQuery('#' + this.name + '_' + this.value).show();
        }
      });
    });
    if (this.nonMetaUpdate) {
      _ref2 = this.mtypesDisplayed;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        m = _ref2[_k];
        this.updatePopovers(m);
      }
    } else {
      this.updatePopovers(genomes.meta_option);
    }
    y = -5;
    centred = -1.5;
    _ref3 = this.mtypesDisplayed;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      m = _ref3[_l];
      if (genomes.visibleMeta[m]) {
        j = 0;
        i = 0;
        y += 7;
        centred += -3.5;
        if (this.metaOntology[m].length < 7) {
          bar_count = this.metaOntology[m].length;
        } else {
          bar_count = 7;
        }
        while (i < bar_count) {
          this.rect_block.append("rect").style("fill", colours[m][j++]).style("stroke-width", 0.5).style("stroke", "black").attr("class", function(n) {
            if (n._children != null) {
              return "metaMeter";
            }
          }).attr("id", (function(_this) {
            return function(n) {
              if (n._children != null) {
                if (i === 6) {
                  return "Other";
                } else {
                  return _this.metaOntology[m][i];
                }
              }
            };
          })(this)).attr("width", (function(_this) {
            return function(n) {
              if (n._children != null) {
                if ((n.metaCount[m][_this.metaOntology[m][i]] != null) && i < 6 && (_this.metaOntology[m][i] != null)) {
                  n.width[i] = (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)) * n.metaCount[m][_this.metaOntology[m][i]] / n.num_leaves;
                } else if (i === 6 && (_this.metaOntology[m][i] != null)) {
                  n.width[i] = (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)) - (n.width[0] + n.width[1] + n.width[2] + n.width[3] + n.width[4] + n.width[5]);
                } else {
                  n.width[i] = 0;
                }
              }
              if (n.width[i] > 0) {
                return n.width[i];
              }
            };
          })(this)).attr("height", function(n) {
            if (n._children != null) {
              return 7;
            }
          }).attr("y", function(n) {
            if (n._children != null) {
              return y;
            }
          }).attr("x", function(n) {
            if (n._children != null) {
              if ((n.width[i - 1] != null) && i > 0) {
                n.xpos += n.width[i - 1];
              } else {
                n.xpos = 0;
              }
            }
            return n.xpos + 4;
          }).attr("data-toggle", function(n) {
            if (n._children != null) {
              return "popover";
            }
          }).attr("data-content", (function(_this) {
            return function(n) {
              var length, pos, tt_data;
              if (n._children != null) {
                length = 0;
                pos = 0;
                if (_this.metaOntology[m][i] != null) {
                  pos = n.tt_table[m].indexOf(_this.metaOntology[m][i].charAt(0).toUpperCase() + _this.metaOntology[m][i].slice(1));
                }
                if (n.metaCount[m][_this.metaOntology[m][i]] > 0) {
                  length = (_this.metaOntology[m][i] + "</td><td style='text-align:right'>" + n.metaCount[m][_this.metaOntology[m][i]]).length;
                  tt_data = n.tt_table[m].slice(0, pos - 8) + "<tr class='table-row-bold' style='color:" + colours[m][3] + "'><td>" + n.tt_table[m].slice(pos, length + pos) + "</td></tr>" + n.tt_table[m].slice(length + pos);
                }
                if (i === 6) {
                  if (n.width[i - 1] === 0) {
                    if (n.tt_table[m].indexOf("[+] Other") != null) {
                      pos = n.tt_table[m].indexOf("[+] Other");
                    } else {
                      pos = n.tt_table[m].indexOf(n.tt_table_last);
                    }
                    tt_data = n.tt_table[m].slice(0, pos - 8) + "<tr class='table-row-bold' style='color:" + colours[m][3] + "'><td>" + n.tt_table[m].slice(pos);
                  } else {
                    tt_data = n.tt_table[m].slice(0, n.tt_table[m].indexOf("[+] Other") - 8) + "<tr class='table-row-bold' style='color:" + colours[m][3] + "'><td>" + n.tt_table[m].slice(n.tt_table[m].indexOf("[+] Other"));
                  }
                }
              }
              if (n.width[i] > 0) {
                return "<table class='popover-table'><tr><th style='min-width:160px;max-width:160px;text-align:left'>" + _this.tt_mtitle[m] + "</th><th style='min-width:110px;max-width:110px;text-align:right'># of Genomes</th></tr>" + tt_data + "</table>";
              }
            };
          })(this));
          i++;
        }
      }
    }
    (function($) {
      var oldHide;
      oldHide = $.fn.popover.Constructor.prototype.hide;
      $.fn.popover.Constructor.prototype.hide = function() {
        var that;
        if (this.options.trigger === 'hover' && this.tip().is(':hover')) {
          that = this;
          setTimeout((function() {
            return that.hide.call(that, arguments);
          }), that.options.delay.hide);
          return;
        }
        oldHide.call(this, arguments);
      };
    })(jQuery);
    this.rect_block.selectAll('.metaMeter').each(function() {
      return $(this).popover({
        placement: 'bottom',
        html: 'true',
        trigger: 'hover',
        delay: {
          show: 500,
          hide: 500
        },
        animate: 'false',
        container: 'body'
      });
    });
    $('body').on('click', function(e) {
      if ($(e.target).data('toggle') !== 'popover' && $(e.target).parents('.popover.in').length === 0) {
        return $('[data-toggle="popover"]').popover('hide');
      }
    });
    if ($('#treenode:has(g.v' + visible_bars + ')')) {
      svgNodes.select('.v' + visible_bars).remove();
    }
    if (visible_bars > 0) {
      this.rect_block.attr("class", 'v' + visible_bars);
    }
    if (visible_bars > 0) {
      if (($('.v' + (visible_bars - 1))[0])) {
        svgNodes.select('.v' + (visible_bars - 1)).remove();
      }
      if (($('.v' + (visible_bars + 1))[0])) {
        svgNodes.select('.v' + (visible_bars + 1)).remove();
      }
      svgNodes.selectAll('.v0').remove();
    } else {
      svgNodes.selectAll('.v1').remove();
    }
    if (visible_bars > 0) {
      svgNodes.selectAll('.genomeMeter').remove();
    }
    cmdBox = iNodes.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 4).attr("x", -8).text(function(d) {
      return "\uf0fe";
    });
    cmdBox.on("click", function(d) {
      return viewController.viewAction(num, 'expand_collapse', d, this.parentNode);
    });
    if (this.style === 'select') {
      cladeSelect = iNodes.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -25);
      cladeSelect.on("click", function(d) {
        return jQuery('#dialog-clade-select').data('clade-node', d).dialog('open');
      });
    }
    nodesUpdate = svgNodes.transition().duration(this.duration).attr("transform", function(d) {
      return "translate(" + d.y + "," + d.x + ")";
    });
    nodesUpdate.select("circle").attr("r", 4);
    nodesUpdate.selectAll("rect.genomeMeter").attr("width", function(n) {
      if (n._children != null) {
        return 10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5);
      } else {
        return 0;
      }
    });
    nodesUpdate.selectAll(".treelabel").attr("x", function(n) {
      if (n._children != null) {
        return 10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5) + 10;
      } else {
        return "0.6em";
      }
    }).attr("dy", ".4em").attr("text-anchor", "start").text(function(d) {
      if (d.leaf) {
        return d.viewname;
      } else {
        return d.label;
      }
    }).style("fill-opacity", 1e-6);
    m = 1;
    while (m < visible_bars + 1) {
      svgNodes.selectAll('.v' + m).attr("transform", "translate(" + 0 + "," + centred + ")");
      m++;
    }
    nodesUpdate.filter(function(d) {
      return !d.children;
    }).select("text").style("fill-opacity", 1);
    nodesUpdate.select(".expandcollapse").text(function(d) {
      if (d._children != null) {
        return "\uf0fe";
      } else {
        return "\uf146";
      }
    });
    nodesExit = svgNodes.exit().transition().duration(this.duration).attr("transform", (function(_this) {
      return function(d) {
        return "translate(" + _this.launchPt.y + "," + _this.launchPt.x + ")";
      };
    })(this)).remove();
    nodesExit.select("circle").attr("r", 1e-6);
    nodesExit.select("text").style("fill-opacity", 1e-6);
    nodesExit.select("rect").attr("width", 1e-6).attr("height", 1e-6);
    if (!oldRoot.root && this.root !== oldRoot) {
      id = oldRoot.id;
      elID = "treenode" + id;
      svgNode = this.canvas.select("#" + elID);
      svgNode.moveToFront();
    }
    _ref4 = this.nodes;
    for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
      n = _ref4[_m];
      n.x0 = n.x;
      n.y0 = n.y;
    }
    t2 = new Date();
    dt = new Date(t2 - t1);
    console.log('TreeView update elapsed time (sec): ' + dt.getSeconds());
    this.nonMetaUpdate = false;
    return true;
  };

  TreeView.prototype.updateActiveGroup = function(usrGrp) {
    var svgNodes;
    this.activeGroup = usrGrp.active_group.public_list.concat(usrGrp.active_group.private_list);
    svgNodes = this.canvas.selectAll("g.treenode").filter(function(d) {
      return d.leaf;
    });
    svgNodes.select("rect").attr('width', 11).attr('height', 11).attr('x', -5.5).attr('y', -5.5).style('stroke', '#fff').style('fill', (function(_this) {
      return function(d) {
        if (_this.activeGroup.indexOf(d.name) > -1) {
          return 'steelblue';
        } else {
          return '#fff';
        }
      };
    })(this));
    return true;
  };

  TreeView.prototype.updatePopovers = function(option) {
    var i;
    if (this.mtypesDisplayed.indexOf(this.genomes.meta_option) > -1) {
      i = 0;
      while (i < this.metaOntology[option].length) {
        this.rect_block.text((function(_this) {
          return function(n) {
            var other_width, tt_mtype;
            if (n._children != null) {
              if ((n.metaCount[option][_this.metaOntology[option][i]] != null) && i < 6 && (_this.metaOntology[option][i] != null)) {
                n.width[i] = (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)) * n.metaCount[option][_this.metaOntology[option][i]] / n.num_leaves;
              } else if (i === 6 && (_this.metaOntology[option][i] != null)) {
                n.width[i] = (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)) - (n.width[0] + n.width[1] + n.width[2] + n.width[3] + n.width[4] + n.width[5]);
              } else {
                n.width[i] = 0;
              }
              if ((n.metaCount[option][_this.metaOntology[option][i]] != null) && i > 5) {
                n.other_count[option] += n.metaCount[option][_this.metaOntology[option][i]];
              }
              tt_mtype = _this.metaOntology[option][i].charAt(0).toUpperCase() + _this.metaOntology[option][i].slice(1);
              if (n.metaCount[option][_this.metaOntology[option][i]] > 0) {
                other_width = Math.round(n.num_leaves * n.width[6] / (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)));
                if (i >= 6) {
                  if (!(n.tt_sub_table[option].indexOf("<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + n.metaCount[option][_this.metaOntology[option][i]] + "</td></tr>") > -1)) {
                    n.tt_sub_table[option] += "<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + n.metaCount[option][_this.metaOntology[option][i]] + "</td></tr>";
                  }
                  if (!(n.tt_table[option].indexOf(n.tt_table_partial[option] + ("<tbody class='other-row' onclick=\"$('.after-other').slideToggle(100);\"><tr><td>[+] Other</td><td style='text-align:right'\">" + other_width + "</td></tr></tbody><tbody class='after-other'>" + n.tt_sub_table[option] + "</tbody>")) > -1)) {
                    n.tt_table[option] = n.tt_table_partial[option] + ("<tbody class='other-row' onclick=\"$('.after-other').slideToggle(100);\"><tr><td>[+] Other</td><td style='text-align:right'\">" + other_width + "</td></tr></tbody><tbody class='after-other'>" + n.tt_sub_table[option] + "</tbody>");
                  }
                } else {
                  if (!(n.tt_table_partial[option].indexOf("<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + n.metaCount[option][_this.metaOntology[option][i]] + "</td></tr>") > -1)) {
                    n.tt_table_partial[option] += "<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + n.metaCount[option][_this.metaOntology[option][i]] + "</td></tr>";
                  }
                  n.tt_table_last = tt_mtype;
                  n.tt_table[option] = n.tt_table_partial[option];
                }
                return n.tt_table_partial[option];
              }
            }
          };
        })(this));
        i++;
      }
    }
    return true;
  };

  TreeView.prototype.countMeta = function(count, countType) {
    var g, genome, _i, _len;
    for (_i = 0, _len = countType.length; _i < _len; _i++) {
      g = countType[_i];
      genome = this.genomes.genome(g);
      if (count['serotype'][genome.serotype] != null) {
        count['serotype'][genome.serotype] += 1;
      } else {
        count['serotype'][genome.serotype] = 1;
      }
      if (count['isolation_host'][genome.isolation_host] != null) {
        count['isolation_host'][genome.isolation_host] += 1;
      } else {
        count['isolation_host'][genome.isolation_host] = 1;
      }
      if (count['isolation_source'][genome.isolation_source] != null) {
        count['isolation_source'][genome.isolation_source] += 1;
      } else {
        count['isolation_source'][genome.isolation_source] = 1;
      }
      if (count['syndrome'][genome.syndrome] != null) {
        count['syndrome'][genome.syndrome] += 1;
      } else {
        count['syndrome'][genome.syndrome] = 1;
      }
      if (count['stx1_subtype'][genome.stx1_subtype] != null) {
        count['stx1_subtype'][genome.stx1_subtype] += 1;
      } else {
        count['stx1_subtype'][genome.stx1_subtype] = 1;
      }
      if (count['stx2_subtype'][genome.stx2_subtype] != null) {
        count['stx2_subtype'][genome.stx2_subtype] += 1;
      } else {
        count['stx2_subtype'][genome.stx2_subtype] = 1;
      }
    }
    return count;
  };

  TreeView.prototype.intro = function() {
    var treeIntro;
    treeIntro = [];
    treeIntro.push({
      element: document.querySelector('#tree_find_input2'),
      intro: "Use this search bar to search for a specific genome.  The genome will be indicated by a yellow circle on the tree, which shows its phylogenetic relationships with other genomes.  Click 'Functions List' to view a list of functions.",
      position: 'right'
    });
    treeIntro.push({
      element: document.querySelector('#tree-controls'),
      intro: "Use these buttons to have the tree fit within the window, to reset the tree, and to expand all the clades.",
      position: 'bottom'
    });
    treeIntro.push({
      element: document.querySelector('#genome_tree2'),
      intro: "You can also click the blue circles to select genomes.  Clades can be selected by clicking the red boxes.  Pan by clicking and dragging.  Clicking on the '+' and '-' symbols will expand or collapse each clade.  Use the clickwheel on your mouse to zoom.",
      position: 'left'
    });
    treeIntro.push({
      element: document.querySelector('#tree_legend2'),
      intro: "Use this legend to help you.",
      position: 'left'
    });
    return treeIntro;
  };

  TreeView.prototype.updateCSS = function(gset, genomes) {
    var g, genomeList, svgNodes, updateNodes, _i, _j, _len, _len1, _ref, _ref1;
    genomeList = {};
    if (gset["public"] != null) {
      _ref = gset["public"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        genomeList[g] = genomes.public_genomes[g];
      }
    }
    if (gset["private"] != null) {
      _ref1 = gset["private"];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        g = _ref1[_j];
        genomeList[g] = genomes.private_genomes[g];
      }
    }
    svgNodes = this.canvas.selectAll("g.treenode");
    updateNodes = svgNodes.filter(function(d) {
      return genomeList[d.genome] != null;
    }).attr("class", (function(_this) {
      return function(d) {
        g = genomeList[d.genome];
        d.selected = (g.isSelected != null) && g.isSelected;
        d.assignedGroup = g.assignedGroup;
        return _this._classList(d);
      };
    })(this));
    updateNodes.on("click", function(d) {
      if (d.assignedGroup == null) {
        return viewController.select(d.genome, !d.selected);
      } else {
        return null;
      }
    });
    return true;
  };

  TreeView.prototype.viewAction = function(genomes, argArray) {
    var event;
    event = argArray.shift();
    if (event === 'expand_collapse') {
      this.nonMetaUpdate = true;
      this._expandCollapse(genomes, argArray[0], argArray[1]);
    } else if (event === 'fit_window') {
      this.nonMetaUpdate = true;
      this.reformat = true;
      this.update(genomes);
    } else if (event === 'reset_window') {
      this.nonMetaUpdate = true;
      this.resetWindow = true;
      this.highlightGenomes(genomes, null);
      this.update(genomes);
    } else if (event === 'expand_tree') {
      this.nonMetaUpdate = true;
      this.expandTree(genomes);
    } else if (event === 'collapse_tree') {
      this.nonMetaUpdate = true;
      this.collapseTree(genomes);
    } else {
      throw new SuperphyError("Unrecognized event type: " + event + " in TreeView viewAction method.");
    }
    return true;
  };

  TreeView.prototype.selectClade = function(node, checked) {
    var c, _i, _j, _len, _len1, _ref, _ref1;
    if (node.leaf) {
      if (checked) {
        if (!node.selected) {
          viewController.select(node.genome, checked);
        }
      } else {
        if (node.selected) {
          viewController.select(node.genome, checked);
        }
      }
    } else {
      if (node.children) {
        _ref = node.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          this.selectClade(c, checked);
        }
      } else if (node._children) {
        _ref1 = node._children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          c = _ref1[_j];
          this.selectClade(c, checked);
        }
      }
    }
    return true;
  };

  TreeView.prototype.select = function(genome, isSelected) {
    var d, svgNodes, updateNode;
    d = this._findLeaf(genome);
    svgNodes = this.canvas.selectAll("g.treenode");
    updateNode = svgNodes.filter(function(d) {
      return d.genome === genome;
    });
    if (updateNode) {
      updateNode.attr("class", (function(_this) {
        return function(d) {
          d.selected = isSelected;
          return _this._classList(d);
        };
      })(this));
      updateNode.select("circle").style("fill", (function(_this) {
        return function(d) {
          if (d.selected) {
            return "lightsteelblue";
          } else {
            return "#fff";
          }
        };
      })(this));
      this._percolateSelected(d.parent, isSelected);
      svgNodes.filter(function(d) {
        return !d.leaf;
      }).attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this));
    }
    return true;
  };

  TreeView.prototype._percolateSelected = function(node, checked) {
    if (node == null) {
      return true;
    }
    if (checked) {
      node.num_selected++;
    } else {
      node.num_selected--;
    }
    if (node.num_selected === node.num_leaves) {
      node.internal_node_selected = 2;
    } else if (node.num_selected > 0) {
      node.internal_node_selected = 1;
    } else {
      node.internal_node_selected = 0;
    }
    this._percolateSelected(node.parent, checked);
    return true;
  };

  TreeView.prototype.dump = function(genomes) {
    var output, tokens;
    tokens = [];
    this._printNode(genomes, this.root, tokens);
    output = tokens.join('');
    return {
      ext: 'newick',
      type: 'text/plain',
      data: output
    };
  };

  TreeView.prototype._printNode = function(genomes, node, tokens) {
    var c, children, g, lab, _i, _len;
    if (node.leaf) {
      g = genomes.genome(node.genome);
      lab = genomes.label(g, genomes.visibleMeta);
      tokens.push("\"" + lab + "\"", ':', node.length);
    } else {
      children = node.children;
      if (node._children != null) {
        children = node._children;
      }
      tokens.push('(');
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        c = children[_i];
        this._printNode(genomes, c, tokens);
        tokens.push(',');
      }
      tokens[tokens.length - 1] = ')';
      tokens.push("\"" + node.name + "\"", ':', node.length);
    }
    return true;
  };

  TreeView.prototype._step = function(d) {
    return "M" + d.source.y + "," + d.source.x + "L" + d.source.y + "," + d.target.x + "L" + d.target.y + "," + d.target.x;
  };

  TreeView.prototype._prepTree = function() {
    var gPattern;
    this.trueRoot.root = true;
    this.trueRoot.x0 = this.height / 2;
    this.trueRoot.y0 = 0;
    gPattern = /^((?:public_|private_)\d+)\|/;
    this.leaves = [];
    return this._assignKeys(this.trueRoot, 0, gPattern);
  };

  TreeView.prototype._assignKeys = function(n, i, gPattern) {
    var m, res, _i, _j, _len, _len1, _ref, _ref1;
    n.id = i;
    n.storage = n.length * 1;
    i++;
    if (n.children != null) {
      n.num_selected = 0;
      n.daycare = n.children.slice();
      _ref = n.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        i = this._assignKeys(m, i, gPattern);
      }
    } else if (n._children != null) {
      n.num_selected = 0;
      n.daycare = n._children.slice();
      _ref1 = n._children;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        m = _ref1[_j];
        i = this._assignKeys(m, i, gPattern);
      }
    }
    if ((n.leaf != null) && n.leaf === "true") {
      if (this.locusData != null) {
        res = gPattern.exec(n.name);
        if (res == null) {
          throw new SuperphyError("Invalid tree node key. Expecting: genome|locus. Recieved: " + n.name);
        }
        n.genome = res[1];
      } else {
        n.genome = n.name;
      }
      this.leaves.push(n);
    }
    return i;
  };

  TreeView.prototype._sync = function(genomes) {
    this.root = this._syncNode(this.trueRoot, genomes, 0);
    if ((genomes.genomeSetId !== this.currentGenomeSet) || this.resetWindow) {
      this._expansionLayout();
      this.currentGenomeSet = genomes.genomeSetId;
      this.resetWindow = false;
      this.reformat = true;
    }
    return true;
  };

  TreeView.prototype._syncNode = function(node, genomes, sumLengths) {
    var c, child, children, g, isExpanded, k, k2, ld, u, v, v2, _i, _len, _ref, _ref1, _ref2;
    node.length = node.storage * 1;
    node.sum_length = sumLengths + node.length;
    if ((node.leaf != null) && node.leaf === "true") {
      g = genomes.genome(node.genome);
      if ((g != null) && g.visible) {
        node.viewname = g.viewname;
        node.selected = (g.isSelected != null) && g.isSelected;
        node.assignedGroup = g.assignedGroup;
        node.hidden = false;
        if (this.locusData != null) {
          ld = this.locusData.locusNode(node.name);
          node.viewname += ld[0];
          if (ld[1] != null) {
            node.assignedGroup = ld[1];
          }
        }
      } else {
        node.hidden = true;
      }
      if (!((node.metaCount != null) && (g == null))) {
        node.metaCount = genomes.countMeta(g);
      }
    } else {
      isExpanded = true;
      if (node._children != null) {
        isExpanded = false;
      }
      node.metaCount = {};
      children = [];
      _ref = node.daycare;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        u = this._syncNode(c, genomes, node.sum_length);
        if (!u.hidden) {
          children.push(u);
          _ref1 = u.metaCount;
          for (k in _ref1) {
            v = _ref1[k];
            if (node.metaCount[k] == null) {
              node.metaCount[k] = {};
            }
            _ref2 = u.metaCount[k];
            for (k2 in _ref2) {
              v2 = _ref2[k2];
              if (node.metaCount[k][k2] != null) {
                node.metaCount[k][k2] += v2;
              } else {
                node.metaCount[k][k2] = v2;
              }
            }
          }
        }
      }
      if (children.length === 0) {
        node.hidden = true;
      } else if (children.length === 1) {
        node.hidden = true;
        child = children[0];
        child.length += node.length;
        return child;
      } else {
        node.hidden = false;
        if (isExpanded) {
          node.children = children;
        } else {
          node._children = children;
        }
      }
    }
    return node;
  };

  TreeView.prototype._cloneNode = function(node) {
    var copy, k, v;
    copy = {};
    for (k in node) {
      v = node[k];
      if (!(k === 'children' || k === '_children')) {
        copy[k] = v;
      }
    }
    return copy;
  };

  TreeView.prototype._expansionLayout = function() {
    this._formatNode(this.root, 0);
    this.root.x0 = this.height / 2;
    this.root.y0 = 0;
    this.root.root = true;
    return true;
  };

  TreeView.prototype._formatNode = function(node, depth, parentNode) {
    var c, children, current_depth, isExpanded, r, record, _i, _len, _ref;
    if (parentNode == null) {
      parentNode = null;
    }
    if (node.hidden) {
      return null;
    }
    current_depth = depth + 1;
    record = {};
    node.parent = parentNode;
    node.root = false;
    if ((node.leaf != null) && node.leaf === "true") {
      record['num_leaves'] = 1;
      record['outgroup'] = node.label;
      record['depth'] = current_depth;
      record['length'] = node.length;
      record['num_selected'] = (_ref = node.selected) != null ? _ref : {
        1: 0
      };
      return record;
    } else {
      isExpanded = true;
      children = node.children;
      if (node._children != null) {
        isExpanded = false;
        children = node._children;
      }
      if (current_depth < this.expandDepth) {
        node.children = children;
        node._children = null;
      } else if (isExpanded) {
        node._children = children;
        node.children = null;
      } else {
        node._children = children;
        node.children = null;
      }
      record = {
        num_leaves: 0,
        num_selected: 0,
        outgroup: '',
        depth: 1e6,
        length: 0
      };
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        c = children[_i];
        r = this._formatNode(c, current_depth, node);
        record['num_leaves'] += r['num_leaves'];
        record['num_leaves'] += r['num_selected'];
        if ((record['depth'] > r['depth']) || (record['depth'] === r['depth'] && record['length'] < r['length'])) {
          record['depth'] = r['depth'];
          record['length'] = r['length'];
          record['outgroup'] = r['outgroup'];
        }
      }
      node.label = "" + record['num_leaves'] + " genomes (outgroup: " + record['outgroup'] + ")";
      node.num_leaves = record['num_leaves'];
      node.num_selected = record['num_selected'];
      if (node.num_selected === node.num_leaves) {
        node.internal_node_selected = 2;
      } else if (node.num_selected > 0) {
        node.internal_node_selected = 1;
      } else {
        node.internal_node_selected = 0;
      }
    }
    return record;
  };

  TreeView.prototype._scale = function() {
    var farthest, lowest, padding, percCovered, xedge, yedge;
    farthest = d3.max(this.nodes, function(d) {
      return d.sum_length * 1;
    });
    lowest = d3.max(this.nodes, function(d) {
      return d.x;
    });
    percCovered = 0.10 * this.root.num_leaves;
    if (percCovered > 0.90) {
      percCovered = 0.90;
    }
    padding = 20;
    yedge = (this.width - padding) * percCovered;
    xedge = (this.height - padding) * percCovered;
    this.branch_scale_factor_y = yedge / farthest;
    this.branch_scale_factor_x = xedge / lowest;
    return true;
  };

  TreeView.prototype._expandCollapse = function(genomes, d, el) {
    var c, c2, c3, maxy, svgNode, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    svgNode = d3.select(el);
    this.edgeNode = null;
    maxy = 0;
    if (d.children != null) {
      d._children = d.children;
      d.children = null;
      this.edgeNode = d;
    } else {
      d.children = d._children;
      d._children = null;
      _ref = d.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        if (c._children != null) {
          c.children = c._children;
          c._children = null;
        }
        if (c.children != null) {
          _ref1 = c.children;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            c2 = _ref1[_j];
            if (c2._children != null) {
              c2.children = c2._children;
              c2._children = null;
            }
            if (c2.children != null) {
              _ref2 = c2.children;
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                c3 = _ref2[_k];
                if (c3.sum_length > maxy) {
                  maxy = c3.sum_length;
                  this.edgeNode = c3;
                }
              }
            }
            if (c2.sum_length > maxy) {
              maxy = c2.sum_length;
              this.edgeNode = c2;
            }
          }
        }
        if (c.sum_length > maxy) {
          maxy = c.sum_length;
          this.edgeNode = c;
        }
      }
    }
    this.expansionContraction = true;
    this.update(genomes, d);
    return true;
  };

  TreeView.prototype.zoomed = function() {
    this.canvas.selectAll("g.treenode").attr("transform", (function(_this) {
      return function(d) {
        return _this._zTransform(d, _this.xzoom, _this.yzoom);
      };
    })(this));
    this.canvas.selectAll("path.treelink").attr("d", (function(_this) {
      return function(d) {
        return _this._zTranslate(d, _this.xzoom, _this.yzoom);
      };
    })(this));
    this.scaleBar.select("line").attr('transform', 'scale(' + d3.event.scale + ',1)');
    return true;
  };

  TreeView.prototype._zTranslate = function(d, xzoom, yzoom) {
    var sourceX, sourceY, targetX, targetY;
    sourceX = xzoom(d.source.y);
    sourceY = yzoom(d.source.x);
    targetX = xzoom(d.target.y);
    targetY = yzoom(d.target.x);
    return "M" + sourceX + "," + sourceY + "L" + sourceX + "," + targetY + "L" + targetX + "," + targetY;
  };

  TreeView.prototype._zTransform = function(d, xzoom, yzoom) {
    return "translate(" + xzoom(d.y) + "," + yzoom(d.x) + ")";
  };

  TreeView.prototype._classList = function(d) {
    var clsList;
    clsList = ['treenode'];
    if (d.selected) {
      clsList.push("selectedNode");
    }
    if (d.focus) {
      clsList.push("focusNode");
    }
    if (d.assignedGroup != null) {
      clsList.push("groupedNode" + d.assignedGroup);
    }
    if (d.internal_node_selected != null) {
      if (d.internal_node_selected === 2) {
        clsList.push("internalSNodeFull");
      } else if (d.internal_node_selected === 1) {
        clsList.push("internalSNodePart");
      }
    }
    return clsList.join(' ');
  };

  TreeView.prototype._findLeaf = function(genome) {
    var found, n;
    n = null;
    found = this.leaves.some(function(el, i) {
      if (el.genome === genome) {
        n = el;
        return true;
      } else {
        return false;
      }
    });
    if (!found) {
      throw new SuperphyError("No leaf node matching " + genome + " found.");
      return null;
    }
    return n;
  };

  TreeView.prototype._legend = function(el) {
    var cladeExpand, cladeSelect, colw, colw2, csColumn, ecColumn, expandCollapse, focusNode, genomeSelect, gsColumn, indent, lineh, lineh2, lineh3, lineh4, lineh5, lineh6, panZoom, pzRow, pzdx, pzdx2, pzdy, textdx, textdx2, textdy;
    lineh = 25;
    lineh2 = 40;
    lineh3 = 55;
    lineh4 = 70;
    lineh5 = 85;
    lineh6 = 100;
    textdx = ".6em";
    textdx2 = "2.5em";
    textdy = ".4em";
    pzdx = "3.2em";
    pzdx2 = "3.7em";
    pzdy = ".5em";
    indent = 8;
    colw = 245;
    colw2 = 480;
    if (this.style === 'select') {
      gsColumn = el.append("g").attr("transform", "translate(5," + lineh + ")");
      genomeSelect = gsColumn.append("g").attr("class", 'treenode');
      genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
      genomeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to select / unselect genome');
      genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
      genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
      genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Unselected genome');
      genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh2 + ")");
      genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "lightsteelblue");
      genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Selected genome');
      genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh3 + ")");
      genomeSelect.append('rect').attr('width', 11).attr('height', 11).attr('x', -5.5).attr('y', -5.5).style('fill', 'steelblue');
      genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
      genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Active group genome');
      genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh4 + ")");
      genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("stroke", "#ffa500").style("stroke-width", "3px");
      genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Searched genome');
      csColumn = el.append("g").attr("transform", "translate(" + colw + "," + lineh + ")");
      cladeSelect = csColumn.append("g").attr("class", 'treenode');
      cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
      cladeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to select / unselect clade');
      cladeSelect = csColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
      cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
      cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('No genomes selected in clade');
      cladeSelect = csColumn.append("g").attr("class", 'treenode internalSNodePart').attr("transform", "translate(" + indent + "," + lineh2 + ")");
      cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
      cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Some genomes selected in clade');
      cladeSelect = csColumn.append("g").attr("class", 'treenode internalSNodeFull').attr("transform", "translate(" + indent + "," + lineh3 + ")");
      cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
      cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('All genomes selected in clade');
      ecColumn = el.append("g").attr("transform", "translate(" + colw2 + "," + lineh + ")");
      expandCollapse = ecColumn.append("g").attr("class", 'treenode');
      expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
        return "\uf0fe";
      });
      expandCollapse.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to collapse / expand clade');
      expandCollapse = ecColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
      expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
        return "\uf146";
      });
      expandCollapse.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Expanded clade');
      expandCollapse = ecColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh2 + ")");
      expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
        return "\uf0fe";
      });
      expandCollapse.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Collapsed clade');
      pzRow = el.append("g").attr("transform", "translate(0,0)");
      panZoom = pzRow.append("g").attr("class", 'treenode');
      panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Pan');
      panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx).attr("dy", pzdy).attr("text-anchor", "start").text('Click & Drag');
      panZoom = pzRow.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + ",0)");
      panZoom.append("text").attr("class", "slash").attr("dx", "-.4em").attr("dy", ".5em").attr("text-anchor", "start").text('Zoom');
      return panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx).attr("dy", pzdy).attr("text-anchor", "start").text('Scroll');
    } else {
      genomeSelect = el.append("g").attr("class", 'treenode').attr("transform", "translate(5,0)");
      genomeSelect.append("circle").attr("r", 4).attr("cx", 8).attr("cy", 0).style("fill", "#fff");
      genomeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Select genome');
      cladeExpand = el.append("g").attr("class", 'treenode').attr("transform", "translate(5, " + lineh + ")");
      cladeExpand.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 4).attr("x", -1).text(function(d) {
        return "\uf0fe";
      });
      cladeExpand.append("text").attr("class", "slash").attr("dx", ".5em").attr("dy", ".5em").attr("text-anchor", "start").text('/');
      cladeExpand.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 8).attr("x", 17).text(function(d) {
        return "\uf146";
      });
      cladeExpand.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Expand / Collapse clade');
      panZoom = el.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + ",0)");
      panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Pan ');
      panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx2).attr("dy", pzdy).attr("text-anchor", "start").text('Click & Drag');
      panZoom = el.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + "," + lineh + ")");
      panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Zoom');
      panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx2).attr("dy", pzdy).attr("text-anchor", "start").text('Scroll');
      focusNode = el.append("g").attr("class", 'treenode focusNode').attr("transform", "translate(" + colw2 + ",0)");
      focusNode.append("circle").attr("r", 4).attr("cx", 8).attr("cy", 2);
      return focusNode.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Target genome');
    }
  };

  TreeView.prototype._treeOps = function(el, legendID) {
    var colButtonID, controls, expButtonID, findButtonID, findInputID, fitButtonID, num, opsHtml, resetButtonID;
    opsHtml = '';
    controls = '<div class="row">';
    controls += "<div class='col-sm-6 span6'><div class='btn-group' id='tree-controls'>";
    fitButtonID = "tree_fit_button" + this.elNum;
    controls += "<button id='" + fitButtonID + "' type='button' class='btn btn-default btn-sm'>Fit to window</button>";
    resetButtonID = "tree_reset_button" + this.elNum;
    controls += "<button id='" + resetButtonID + "' type='button' class='btn btn-default btn-sm'>Reset</button>";
    expButtonID = "tree_expand_button" + this.elNum;
    controls += "<button id='" + expButtonID + "' type='button' class='btn btn-default btn-sm'>Expand</button>";
    colButtonID = "tree_collapse_button" + this.elNum;
    controls += "<button id='" + colButtonID + "' type='button' class='btn btn-default btn-sm'>Collapse</button>";
    controls += "</div></div>";
    findButtonID = "tree_find_button" + this.elNum;
    findInputID = "tree_find_input" + this.elNum;
    controls += "<div class='col-sm-3 span3'><div class='input-group input-prepend input-group-sm'>";
    controls += "<span class='input-group-btn'> <button id='" + findButtonID + "' class='btn btn-default btn-sm' type='button'>Search</button></span>";
    controls += "<input id='" + findInputID + "' type='text' class='form-control input-small'></div></div>";
    controls += "<div class='col-sm-1 span1'></div>";
    controls += "<div class='col-sm-2 span2'><a href='#" + legendID + "'>Functions List</a></div>";
    controls += "</div>";
    opsHtml += "" + controls;
    jQuery("<div class='tree_operations'>" + opsHtml + "</div>").appendTo(el);
    num = this.elNum - 1;
    jQuery("#" + findButtonID).click(function(e) {
      var searchString;
      e.preventDefault();
      searchString = jQuery("#" + findInputID).val();
      return viewController.highlightInView(searchString, num);
    });
    jQuery("#" + fitButtonID).click(function(e) {
      e.preventDefault();
      return viewController.viewAction(num, 'fit_window');
    });
    jQuery("#" + resetButtonID).click(function(e) {
      e.preventDefault();
      return viewController.viewAction(num, 'reset_window');
    });
    jQuery("#" + expButtonID).click(function(e) {
      e.preventDefault();
      return viewController.viewAction(num, 'expand_tree');
    });
    jQuery("#" + colButtonID).click(function(e) {
      e.preventDefault();
      return viewController.viewAction(num, 'collapse_tree');
    });
    return true;
  };

  TreeView.prototype.highlightGenomes = function(genomes, targetList) {
    var gs, l, maxy, n, targetNodes, _i, _j, _len, _len1, _ref;
    _ref = this.leaves;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      l = _ref[_i];
      l.focus = false;
    }
    if ((targetList != null) && targetList.length) {
      targetNodes = this._blowUpPath(targetList);
      if (targetNodes.length) {
        maxy = 0;
        this.edgeNode = null;
        for (_j = 0, _len1 = targetNodes.length; _j < _len1; _j++) {
          n = targetNodes[_j];
          if (n.sum_length > maxy) {
            maxy = n.sum_length;
            this.edgeNode = n;
          }
        }
        this.expansionContraction = true;
        return this.update(genomes);
      } else {
        gs = targetList.join(', ');
        throw new SuperphyError("TreeView method highlightGenome error. Genome(s) " + gs + " not found.");
      }
    }
  };

  TreeView.prototype._blowUpPath = function(targetList) {
    var curr, g, n, targetNodes, _i, _len;
    targetNodes = [];
    for (_i = 0, _len = targetList.length; _i < _len; _i++) {
      g = targetList[_i];
      n = this._findLeaf(g);
      n.focus = true;
      targetNodes.push(n);
      curr = n.parent;
      while (curr) {
        if (curr._children != null) {
          curr.children = curr._children;
          curr._children = null;
        }
        curr = curr.parent;
      }
    }
    return targetNodes;
  };

  TreeView.prototype.expandTree = function(genomes) {
    this._expandOneLevel(this.root);
    this.reformat = true;
    this.update(genomes);
    return true;
  };

  TreeView.prototype.collapseTree = function(genomes) {
    var n, _i, _len, _ref;
    this.levelTracker = 0;
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (n.leaf || (n._children != null)) {
        this.levelTracker = n.depth;
      }
    }
    this._collapseOneLevel(this.root);
    this.reformat = true;
    this.update(genomes);
    return true;
  };

  TreeView.prototype._collapseOneLevel = function(n) {
    var c, _i, _len, _ref;
    if (n.children != null) {
      _ref = n.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        this._collapseOneLevel(c);
      }
    }
    if ((n._children != null) || n.leaf) {
      if (n.depth === this.levelTracker) {
        if (n.parent.children !== null) {
          n.parent._children = n.parent.children;
          n.parent.children = null;
        }
      }
    }
    return true;
  };

  TreeView.prototype._expandOneLevel = function(n) {
    var c, _i, _len, _ref;
    if (n.children != null) {
      _ref = n.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        this._expandOneLevel(c);
      }
    }
    if (n._children != null) {
      n.children = n._children;
      n._children = null;
    }
    return true;
  };

  return TreeView;

})(ViewTemplate);
