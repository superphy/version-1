// Generated by CoffeeScript 1.8.0

/*

 File: superphy_map.coffee
 Desc: Objects & functions for managing geospatial views in Superphy
 Author: Akiff Manji akiff.manji@gmail.com
 Date: May 6, 2014
 */
var Cartographer, CartographerOverlay, DotCartographer, GeophyCartographer, InfoSatelliteCartographer, LocationController, MapView, SatelliteCartographer, SelectionMapView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

MapView = (function(_super) {
  __extends(MapView, _super);

  function MapView(parentElem, style, elNum, genomeController, mapArgs) {
    var buttonEl, input, inputGpEl, manifestRow, map, mapCanvasEl, mapManifest, mapManifestEl, mapRow, mapSearchEl, mapSearchRow, mapSplitLayout, menu, menuRow, resetEl, resetMapView, searchEl;
    this.parentElem = parentElem;
    this.style = style;
    this.elNum = elNum;
    this.genomeController = genomeController;
    this.mapArgs = mapArgs;
    MapView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
    this.sortField = 'isolation_country';
    this.sortAsc = 'true';
    this.locationMetaFields = {
      'isolation_country': 'Country',
      'isolation_province_state': 'Province/State',
      'isolation_city': 'City'
    };
    mapSplitLayout = jQuery('<div class="map-split-layout row"></div>').appendTo(jQuery(this.parentElem));
    mapSearchEl = jQuery('<div class="map-search-wrapper col-md-6 span6"></div>').appendTo(mapSplitLayout);
    mapSearchRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapSearchEl);
    searchEl = jQuery('<div class="col-md-9 span9"></div>').appendTo(mapSearchRow);
    resetEl = jQuery('<div class="col-md-3 span3"></div>').appendTo(mapSearchRow);
    mapRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapSearchEl);
    map = jQuery('<div class="col-md-12 span12"></div>').appendTo(mapRow);
    mapCanvasEl = jQuery('<div class="map-canvas"></div>').appendTo(map);
    inputGpEl = jQuery('<div class="input-group input-append"></div></div>').appendTo(searchEl);
    input = jQuery('<input type="text" class="form-control map-search-location input-xlarge" placeholder="Enter a search location">').appendTo(inputGpEl);
    buttonEl = jQuery('<span class="input-group-btn"><button class="btn btn-default map-search-button" type="button"><span class="fa fa-search"></span></button></span>').appendTo(inputGpEl);
    resetMapView = jQuery('<button id="reset-map-view" type="button" class="btn btn-link">Reset Map View</button>').appendTo(resetEl);
    mapManifestEl = jQuery('<div class="map-manifest-wrapper col-md-6 span6"></div>').appendTo(mapSplitLayout);
    menuRow = jQuery('<div class="row"></div>').appendTo(mapManifestEl);
    menu = jQuery('<div class="map-menu col-md-12 span12"></div>').appendTo(menuRow);
    manifestRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapManifestEl);
    mapManifest = jQuery('<div class="col-md-12 span12"></div>').appendTo(manifestRow);
    mapManifestEl = jQuery('<div class="map-manifest"></div>').appendTo(mapManifest);
    this.locationController = this.getLocationController(this.mapArgs[0], this.elNum);
    this.mapController = this.getCartographer(this.mapArgs[0], this.locationController);
    jQuery(this.parentElem).data('views-index', this.elNum);
    resetEl.click((function(_this) {
      return function(e) {
        e.preventDefault();
        return _this.mapController.resetMapView();
      };
    })(this));
  }

  MapView.prototype.type = 'map';

  MapView.prototype.elName = 'genome_map';

  MapView.prototype.mapView = true;

  MapView.prototype.update = function(genomes) {

    /* Commented out to remove map manifest (replaced by independent genome table)
    tableElem = jQuery("##{@elID} table")
    if tableElem.length
      tableElem.empty()
    else
      divElem = jQuery("<div id='#{@elID}' class='superphy-table'/>")
      tableElem = jQuery("<table />").appendTo(divElem)
      mapManifest = jQuery('.map-manifest').append(divElem)
      toggleUnknownLocations = jQuery('<div class="checkbox toggle-unknown-location" id="unknown-location"><label><input type="checkbox">Unknown Locations Off</label></div>').appendTo(jQuery('.map-menu'))
    
      that = @
      toggleUnknownLocations.change( () ->
        that.update(that.genomeController)
        )
     */
    var i, pubVis, pvtVis, unknownsOff, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    unknownsOff = false;
    pubVis = [];
    pvtVis = [];
    if (this.locationController == null) {
      pubVis = genomes.pubVisible;
      pvtVis = genomes.pvtVisible;
    } else {
      this.mapController.resetMarkers();
      _ref = this.mapController.visibleLocations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (__indexOf.call(genomes.pubVisible, i) >= 0) {
          pubVis.push(i);
        }
      }
      _ref1 = this.mapController.visibleLocations;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        i = _ref1[_j];
        if (__indexOf.call(genomes.pvtVisible, i) >= 0) {
          pvtVis.push(i);
        }
      }
      if (!unknownsOff) {
        _ref2 = this.locationController.pubNoLocations;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          i = _ref2[_k];
          if (__indexOf.call(genomes.pubVisible, i) >= 0) {
            pubVis.push(i);
          }
        }
      }
      if (!unknownsOff) {
        _ref3 = this.locationController.pvtNoLocations;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          i = _ref3[_l];
          if (__indexOf.call(genomes.pvtVisible, i) >= 0) {
            pvtVis.push(i);
          }
        }
      }
    }

    /*
     *append genomes to list
    t1 = new Date()
    table = ''
    table += @_appendHeader(genomes)
    table += '<tbody>'
    table += @_appendGenomes(genomes.sort(pubVis, @sortField, @sortAsc), genomes.public_genomes, @style, false, true)
    table += @_appendGenomes(genomes.sort(pvtVis, @sortField, @sortAsc), genomes.private_genomes, @style, true, true)
    table += '</body>'
    tableElem.append(table)
    @_actions(tableElem, @style)
    t2 = new Date()
    ft = t2-t1
    console.log 'MapView update elapsed time: ' +ft
     */
    return true;
  };

  MapView.prototype.intro = function() {
    var mapIntro;
    mapIntro = [];
    mapIntro.push({
      element: document.querySelector('.map-canvas'),
      intro: "This map displays the location of genomes around the world.",
      position: 'right'
    });
    mapIntro.push({
      element: document.querySelector('.map-search-location'),
      intro: "Input a location here to see genomes found in that region.",
      position: 'right'
    });
    mapIntro.push({
      element: document.querySelector('#genome_map3'),
      intro: "The genomes corresponding to locations on the map are shown here.  Check the boxes to select each genome.",
      position: 'left'
    });
    mapIntro.push({
      element: document.querySelector('#unknown-location'),
      intro: "Check 'Unknown Locations Off' if you want to remove unknown locations from the list (these don't appear on the map).",
      position: 'left'
    });
    mapIntro.push({
      element: document.querySelector('#reset-map-view'),
      intro: "Clicking this will reset the map view.",
      position: 'bottom'
    });
    return mapIntro;
  };

  MapView.prototype._appendHeader = function(genomes) {
    var i, sortIcon, t, tName, table, tk, tv, v, values, _i, _j, _len, _len1, _ref, _ref1;
    table = '<thead><tr>';
    values = [];
    i = -1;
    if (this.sortField === 'displayname') {
      sortIcon = 'fa-sort-asc';
      if (!this.sortAsc) {
        sortIcon = 'fa-sort-desc';
      }
      values[++i] = {
        type: 'displayname',
        name: 'Genome',
        sortIcon: sortIcon
      };
    } else {
      values[++i] = {
        type: 'displayname',
        name: 'Genome',
        sortIcon: 'fa-sort'
      };
    }
    _ref = this.locationMetaFields;
    for (tk in _ref) {
      tv = _ref[tk];
      sortIcon = null;
      if (tk === this.sortField) {
        sortIcon = 'fa-sort-asc';
        if (!this.sortAsc) {
          sortIcon = 'fa-sort-desc';
        }
      } else {
        sortIcon = 'fa-sort';
      }
      values[++i] = {
        type: tk,
        name: tv,
        sortIcon: sortIcon
      };
    }
    _ref1 = genomes.mtypes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      t = _ref1[_i];
      if (!genomes.visibleMeta[t]) {
        continue;
      }
      tName = genomes.metaMap[t];
      sortIcon = null;
      if (t === this.sortField) {
        sortIcon = 'fa-sort-asc';
        if (!this.sortAsc) {
          sortIcon = 'fa-sort-desc';
        }
      } else {
        sortIcon = 'fa-sort';
      }
      values[++i] = {
        type: t,
        name: tName,
        sortIcon: sortIcon
      };
    }
    for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
      v = values[_j];
      table += this._template('th', v);
    }
    table += '</tr></thead>';
    return table;
  };

  MapView.prototype._appendGenomes = function(visibleG, genomes, style, priv) {
    var checked, cls, d, g, gObj, k, location, name, row, table, thiscls, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    cls = this.cssClass();
    table = '';
    if (priv && visibleG.length) {
      table += this._template('spacer', null);
    }
    for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
      g = visibleG[_i];
      row = '';
      gObj = genomes[g];
      thiscls = cls;
      if (gObj.cssClass != null) {
        thiscls = cls + ' ' + gObj.cssClass;
      }
      name = gObj.meta_array[0];
      if (this.locusData != null) {
        name += this.locusData.genomeString(g);
      }
      if (gObj.isolation_location != null) {
        location = true;
      }
      if (gObj.isolation_location == null) {
        location = false;
      }
      if (style === 'redirect') {
        row += this._template('td1_redirect', {
          g: g,
          name: name,
          shortName: gObj.meta_array[0],
          klass: thiscls
        });
        _ref = this.locationMetaFields;
        for (k in _ref) {
          v = _ref[k];
          if (location) {
            row += this._template('td1_location', {
              location: (_ref1 = this.mapController.allMarkers[g][k]) != null ? _ref1 : 'NA'
            });
          }
        }
        _ref2 = this.locationMetaFields;
        for (k in _ref2) {
          v = _ref2[k];
          if (!location) {
            row += this._template('td1_nolocation', {
              location: 'Unknown'
            });
          }
        }
        _ref3 = gObj.meta_array.slice(1);
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          d = _ref3[_j];
          row += this._template('td', {
            data: d
          });
        }
        table += this._template('tr', {
          row: row
        });
      } else if (style === 'select') {
        checked = '';
        if (gObj.isSelected) {
          checked = 'checked';
        }
        row += this._template('td1_select', {
          g: g,
          name: name,
          klass: thiscls,
          checked: checked
        });
        _ref4 = this.locationMetaFields;
        for (k in _ref4) {
          v = _ref4[k];
          if (location) {
            row += this._template('td1_location', {
              location: (_ref5 = this.mapController.allMarkers[g][k]) != null ? _ref5 : 'NA'
            });
          }
        }
        _ref6 = this.locationMetaFields;
        for (k in _ref6) {
          v = _ref6[k];
          if (!location) {
            row += this._template('td1_nolocation', {
              location: 'Unknown'
            });
          }
        }
        _ref7 = gObj.meta_array.slice(1);
        for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
          d = _ref7[_k];
          row += this._template('td', {
            data: d
          });
        }
        table += this._template('tr', {
          row: row
        });
      } else {
        return false;
      }
    }
    return table;
  };

  MapView.prototype._template = function(tmpl, values) {
    var html;
    html = null;
    if (tmpl === 'tr') {
      html = "<tr>" + values.row + "</tr>";
    } else if (tmpl === 'th') {
      html = "<th><a class='genome-table-sort' href='#' data-genomesort='" + values.type + "'>" + values.name + " <i class='fa " + values.sortIcon + "'></i></a></th>";
    } else if (tmpl === 'td') {
      html = "<td>" + values.data + "</td>";
    } else if (tmpl === 'td1_redirect') {
      html = "<td class='" + values.klass + "'>" + values.name + " <a class='genome-table-link' href='#' data-genome='" + values.g + "' title='Genome " + values.shortName + " info'><i class='fa fa-search'></i></a></td>";
    } else if (tmpl === 'td1_select') {
      html = "<td class='" + values.klass + "'><div class='checkbox'> <label><input class='checkbox genome-table-checkbox' type='checkbox' value='" + values.g + "' " + values.checked + "/> " + values.name + "</label></div></td>";
    } else if (tmpl === 'td1_location') {
      html = "<td>" + values.location + "</td>";
    } else if (tmpl === 'td1_nolocation') {
      html = "<td class='no-loc'>" + values.location + "</td>";
    } else if (tmpl === 'spacer') {
      html = "<tr class='genome-table-spacer'><td>---- USER-SUBMITTED GENOMES ----</td></tr>";
    } else {
      throw new SuperphyError("Unknown template type " + tmpl + " in TableView method _template");
    }
    return html;
  };

  MapView.prototype.dump = function(genomes) {
    var fullMeta, g, header, id, k, output, _ref, _ref1;
    fullMeta = {};
    for (k in genomes.visibleMeta) {
      fullMeta[k] = true;
    }
    output = '';
    header = (function() {
      var _results;
      _results = [];
      for (k in fullMeta) {
        _results.push(genomes.metaMap[k]);
      }
      return _results;
    })();
    header.unshift("Genome name");
    header.push("Location");
    output += "#" + header.join("\t") + "\n";
    _ref = genomes.public_genomes;
    for (id in _ref) {
      g = _ref[id];
      output += genomes.label(g, fullMeta, "\t") + "\t";
      output += g.isolation_location ? JSON.parse(g.isolation_location[0]).formatted_address : "N/A";
      output += "\n";
    }
    _ref1 = genomes.private_genomes;
    for (id in _ref1) {
      g = _ref1[id];
      output += genomes.label(g, fullMeta, "\t") + "\t";
      output += g.isolation_location ? JSON.parse(g.isolation_location[0]).formatted_address : "N/A";
      output += "\n";
    }
    return {
      ext: 'csv',
      type: 'text/plain',
      data: output
    };
  };

  MapView.prototype.getCartographer = function(mapType, locationController) {
    var cartographTypes, cartographer, elem;
    elem = this.parentElem;
    mapType = mapType != null ? mapType : 'base';
    cartographTypes = {
      'base': (function(_this) {
        return function() {
          return new Cartographer(jQuery(elem), [locationController]);
        };
      })(this),
      'dot': (function(_this) {
        return function() {
          return new DotCartographer(jQuery(elem), [locationController]);
        };
      })(this),
      'satellite': (function(_this) {
        return function() {
          return new SatelliteCartographer(jQuery(elem), [locationController]);
        };
      })(this),
      'infoSatellite': (function(_this) {
        return function() {
          return new InfoSatelliteCartographer(jQuery(elem), [locationController, _this.mapArgs[1]]);
        };
      })(this),
      'geophy': (function(_this) {
        return function() {
          return new GeophyCartographer(jQuery(elem), [locationController, _this.mapArgs[1]]);
        };
      })(this)
    };
    cartographer = cartographTypes[mapType]();
    cartographer.cartograPhy();
    return cartographer;
  };

  MapView.prototype.getLocationController = function(mapType, viewNum) {
    var cartographTypes, controller;
    cartographTypes = {
      'base': (function(_this) {
        return function() {
          return null;
        };
      })(this),
      'dot': (function(_this) {
        return function() {
          return null;
        };
      })(this),
      'satellite': (function(_this) {
        return function() {
          return new LocationController(_this.genomeController, _this.parentElem, viewNum);
        };
      })(this),
      'infoSatellite': (function(_this) {
        return function() {
          return new LocationController(_this.genomeController, _this.parentElem, viewNum);
        };
      })(this),
      'geophy': (function(_this) {
        return function() {
          return new LocationController(_this.genomeController, _this.parentElem, viewNum);
        };
      })(this)
    };
    controller = cartographTypes[mapType]();
    return controller;
  };

  return MapView;

})(TableView);


/*
  CLASS SelectionMapView
 */

SelectionMapView = (function(_super) {
  __extends(SelectionMapView, _super);

  function SelectionMapView(selParentElem, selStyle, selElNum, selGenomeController, selMapArgs) {
    this.selParentElem = selParentElem;
    this.selStyle = selStyle;
    this.selElNum = selElNum;
    this.selGenomeController = selGenomeController;
    this.selMapArgs = selMapArgs;
    SelectionMapView.__super__.constructor.call(this, this.selParentElem, this.selStyle, this.selElNum, this.selGenomeController, this.selMapArgs);
  }

  SelectionMapView.prototype.update = function(genomes) {
    var selectedEl, selectedElParent;
    SelectionMapView.__super__.update.apply(this, arguments);
    selectedEl = jQuery('.genome_map_item a[data-genome="' + this.mapController.selectedGenomeId + '"]');
    selectedElParent = selectedEl.parent();
    selectedElParent.prepend('<p style="padding:0px;margin:0px">Target genome: </p>');
    selectedElParent.css({
      "font-weight": "bold",
      "margin-bottom": "5px"
    });
    jQuery('.superphy-table table tbody').prepend('<tr>' + selectedElParent + '</tr>');
    selectedEl.remove();
    return true;
  };

  return SelectionMapView;

})(MapView);


/*
  CLASS Cartographer

  Handles map drawing and location searching
 */

Cartographer = (function() {
  function Cartographer(cartographDiv, cartograhOpt) {
    this.cartographDiv = cartographDiv;
    this.cartograhOpt = cartograhOpt;
    this.pinPoint = __bind(this.pinPoint, this);
    this.defaultCenter = new google.maps.LatLng(-0.000, 0.000);
    this.mapOptions = {
      center: this.defaultCenter,
      zoom: 1,
      streetViewControl: false,
      mapTypeId: google.maps.MapTypeId.ROADMAP
    };
    this.mapBounds;
    this.map = new google.maps.Map(jQuery(this.cartographDiv).find('.map-canvas')[0], this.mapOptions);
    jQuery('.map-search-button').bind('click', {
      context: this
    }, this.pinPoint);
  }

  Cartographer.prototype.cartograPhy = function() {
    return true;
  };

  Cartographer.prototype.pinPoint = function(e) {
    var queryLocation;
    e.preventDefault();
    queryLocation = jQuery('.map-search-location').val();
    jQuery.ajax({
      type: "POST",
      url: '/strains/geocode',
      data: {
        'address': queryLocation
      }
    }).done((function(_this) {
      return function(data) {
        var bounds, northEast, results, southWest;
        results = JSON.parse(data);
        _this.map.setCenter(results.geometry.location);
        northEast = new google.maps.LatLng(results.geometry.viewport.northeast.lat, results.geometry.viewport.northeast.lng);
        southWest = new google.maps.LatLng(results.geometry.viewport.southwest.lat, results.geometry.viewport.southwest.lng);
        bounds = new google.maps.LatLngBounds(southWest, northEast);
        return _this.map.fitBounds(bounds);
      };
    })(this)).fail((function() {
      return alert("Could not get coordinates for: " + queryLocation + ". Please enter in another search query");
    }));
    return true;
  };

  Cartographer.prototype.resetMapView = function() {
    this.map.setZoom(1);
    this.map.setCenter(this.defaultCenter);
    return true;
  };

  return Cartographer;

})();


/*
  CLASS DotCartographer

  Handles map drawing and location searching
  Allows for pinpointing locations
 */

DotCartographer = (function(_super) {
  __extends(DotCartographer, _super);

  function DotCartographer(dotCartographDiv, dotCartograhOpt) {
    this.dotCartographDiv = dotCartographDiv;
    this.dotCartograhOpt = dotCartograhOpt;
    this.resetMap = __bind(this.resetMap, this);
    this.pinPoint = __bind(this.pinPoint, this);
    DotCartographer.__super__.constructor.call(this, this.dotCartographDiv, this.dotCartograhOpt);
  }

  DotCartographer.prototype.latLng = null;

  DotCartographer.prototype.marker = null;

  DotCartographer.prototype.cartograPhy = function() {
    DotCartographer.__super__.cartograPhy.apply(this, arguments);
    google.maps.event.addListener(this.map, 'click', (function(_this) {
      return function(event) {
        return _this.plantFlag(event.latLng);
      };
    })(this));
    return true;
  };

  DotCartographer.prototype.pinPoint = function(e) {
    var queryLocation;
    e.preventDefault();
    queryLocation = jQuery('.map-search-location').val();
    jQuery.ajax({
      type: "POST",
      url: '/strains/geocode',
      data: {
        'address': queryLocation
      }
    }).done((function(_this) {
      return function(data) {
        var bounds, northEast, results, southWest;
        results = JSON.parse(data);
        _this.map.setCenter(results.geometry.location);
        northEast = new google.maps.LatLng(results.geometry.viewport.northeast.lat, results.geometry.viewport.northeast.lng);
        southWest = new google.maps.LatLng(results.geometry.viewport.southwest.lat, results.geometry.viewport.southwest.lng);
        bounds = new google.maps.LatLngBounds(southWest, northEast);
        _this.map.fitBounds(bounds);
        _this.latLng = results.geometry.location;
        return _this.plantFlag(_this.latLng, _this.map);
      };
    })(this)).fail((function() {
      return alert("Could not get coordinates for: " + queryLocation + ". Please enter in another search query");
    }));
    return true;
  };

  DotCartographer.prototype.plantFlag = function(location) {
    if (this.marker != null) {
      this.marker.setMap(null);
    }
    this.marker = new google.maps.Marker({
      position: location,
      map: this.map
    });
    this.marker.setTitle(this.marker.getPosition().toString());
    this.map.panTo(this.marker.getPosition());
    return true;
  };

  DotCartographer.prototype.resetMap = function() {
    var c, x;
    x = this.map.getZoom();
    c = this.map.getCenter();
    google.maps.event.trigger(this.map, 'resize');
    this.map.setZoom(x);
    this.map.setCenter(c);
    return true;
  };

  return DotCartographer;

})(Cartographer);


/*
  CLASS SatelliteCartographer

  Handles map drawing and location searching
  Displays multiple markers on map
  Handles marker clustering
  Displays list of genomes 
  Alters genome list when map viewport changes
 */

SatelliteCartographer = (function(_super) {
  __extends(SatelliteCartographer, _super);

  function SatelliteCartographer(satelliteCartographDiv, satelliteCartograhOpt) {
    this.satelliteCartographDiv = satelliteCartographDiv;
    this.satelliteCartograhOpt = satelliteCartograhOpt;
    this.resetMarkers = __bind(this.resetMarkers, this);
    this.resetMap = __bind(this.resetMap, this);
    SatelliteCartographer.__super__.constructor.call(this, this.satelliteCartographDiv, this.satelliteCartograhOpt);
    this.locationController = this.satelliteCartograhOpt[0];
    this.allMarkers = jQuery.extend(this.locationController.pubMarkers, this.locationController.pvtMarkers);
    this.setMarkers(this.allMarkers);
  }

  SatelliteCartographer.prototype.cartograPhy = function() {
    SatelliteCartographer.__super__.cartograPhy.apply(this, arguments);
    google.maps.event.addListener(this.map, 'zoom_changed', (function(_this) {
      return function() {
        return _this.markerClusterer.clearMarkers();
      };
    })(this));
    google.maps.event.addListener(this.map, 'bounds_changed', (function(_this) {
      return function() {
        return _this.markerClusterer.clearMarkers();
      };
    })(this));
    google.maps.event.addListener(this.map, 'resize', (function(_this) {
      return function() {
        return _this.markerClusterer.clearMarkers();
      };
    })(this));
    google.maps.event.addListener(this.map, 'idle', (function(_this) {
      return function() {
        return viewController.views[_this.locationController.viewNum - 1].update(viewController.genomeController);
      };
    })(this));
    return true;
  };

  SatelliteCartographer.prototype.updateVisible = function() {
    var genomes, marker, marker_id, _ref, _ref1, _ref2;
    genomes = this.locationController.genomeController;
    this.visibleLocations = [];
    this.clusteredMarkers = [];
    _ref = this.allMarkers;
    for (marker_id in _ref) {
      marker = _ref[marker_id];
      if (this.map.getBounds() !== void 0 && this.map.getBounds().contains(marker.getPosition()) && ((_ref1 = marker.feature_id, __indexOf.call(genomes.pubVisible, _ref1) >= 0) || (_ref2 = marker.feature_id, __indexOf.call(genomes.pvtVisible, _ref2) >= 0))) {
        this.clusteredMarkers.push(marker);
        this.visibleLocations.push(marker.feature_id);
      }
    }
    return true;
  };

  SatelliteCartographer.prototype.setMarkers = function(markerList) {
    var circleIcon, marker, marker_id, mcOptions;
    circleIcon = {
      path: google.maps.SymbolPath.CIRCLE,
      fillColor: '#FF0000',
      fillOpacity: 0.8,
      scale: 5,
      strokeColor: '#FF0000',
      strokeWeight: 1
    };
    this.clusteredMarkers = [];
    for (marker_id in markerList) {
      marker = markerList[marker_id];
      marker.setMap(this.map);
      marker.setIcon(circleIcon);
      this.clusteredMarkers.push(marker);
    }
    mcOptions = {
      gridSize: 50,
      maxZoom: 15
    };
    this.markerClusterer = new MarkerClusterer(this.map, this.clusteredMarkers, mcOptions);
    return true;
  };

  SatelliteCartographer.prototype.resetMap = function() {
    var c, x;
    x = this.map.getZoom();
    c = this.map.getCenter();
    google.maps.event.trigger(this.map, 'resize');
    this.map.setZoom(x);
    this.map.setCenter(c);
    this.resetMarkers();
    return true;
  };

  SatelliteCartographer.prototype.resetMarkers = function() {
    this.updateVisible();
    this.markerClusterer.clearMarkers();
    this.markerClusterer.addMarkers(this.clusteredMarkers);
    return true;
  };

  return SatelliteCartographer;

})(Cartographer);

GeophyCartographer = (function(_super) {
  __extends(GeophyCartographer, _super);

  function GeophyCartographer(geophyCartographDiv, geophyCartograhOpt) {
    this.geophyCartographDiv = geophyCartographDiv;
    this.geophyCartograhOpt = geophyCartograhOpt;
    this.genomeGroupColor = this.geophyCartograhOpt[1];
    GeophyCartographer.__super__.constructor.call(this, this.geophyCartographDiv, this.geophyCartograhOpt);
  }

  GeophyCartographer.prototype.setMarkers = function(markerList) {
    var aqua, blue, brown, circleIcon, colors, green, grey, lime, marker, mcOptions, orange, pink, purple, red, _i, _len;
    blue = '#1f77b4';
    orange = '#ff7f0e';
    green = '#2ca02c';
    red = '#d62728';
    purple = '#9467bd';
    brown = '#8c564b';
    pink = '#e377c2';
    grey = '#7f7f7f';
    lime = '#bcbd22';
    aqua = '#17becf';
    colors = {
      'group1Color': blue,
      'group2Color': orange,
      'group3Color': green,
      'group4Color': red,
      'group5Color': purple,
      'group6Color': pink,
      'group7Color': brown,
      'group8Color': grey,
      'group9Color': aqua,
      'group10Color': lime
    };
    for (_i = 0, _len = markerList.length; _i < _len; _i++) {
      marker = markerList[_i];
      circleIcon = {
        path: google.maps.SymbolPath.CIRCLE,
        fillColor: colors["group" + this.genomeGroupColor[marker.feature_id] + "Color"],
        fillOpacity: 0.8,
        scale: 5,
        strokeColor: colors["group" + this.genomeGroupColor[marker.feature_id] + "Color"],
        strokeWeight: 1
      };
      marker.setMap(this.map);
      marker.setIcon(circleIcon);
    }
    mcOptions = {
      gridSize: 50,
      maxZoom: 15
    };
    this.markerClusterer = new MarkerClusterer(this.map, markerList, mcOptions);
    return true;
  };

  return GeophyCartographer;

})(SatelliteCartographer);


/*
  CLASS InfoSatelliteCartographer

  Handles map drawing and location searching
  Displays multiple markers on map
  Handles marker clustering
  Displays list of genomes 
  Alters genome list when map viewport changes
  Highlights selected genome on map from search query
 */

InfoSatelliteCartographer = (function(_super) {
  __extends(InfoSatelliteCartographer, _super);

  function InfoSatelliteCartographer(infoSatelliteCartographDiv, infoSatelliteCartograhOpt) {
    var _ref;
    this.infoSatelliteCartographDiv = infoSatelliteCartographDiv;
    this.infoSatelliteCartograhOpt = infoSatelliteCartograhOpt;
    InfoSatelliteCartographer.__super__.constructor.call(this, this.infoSatelliteCartographDiv, this.infoSatelliteCartograhOpt);
    this.selectedGenomeId = this.infoSatelliteCartograhOpt[1];
    this.selectedGenome = (_ref = window.viewController.genomeController.private_genomes[this.selectedGenomeId]) != null ? _ref : window.viewController.genomeController.public_genomes[this.selectedGenomeId];
    this.selectedGenomeLocation = this.locationController._parseLocation(this.selectedGenome);
  }

  InfoSatelliteCartographer.prototype.cartograPhy = function() {
    InfoSatelliteCartographer.__super__.cartograPhy.apply(this, arguments);
    this.showSelectedGenome(this.selectedGenomeLocation, this.map);
    return this.showLegend();
  };

  InfoSatelliteCartographer.prototype.showSelectedGenome = function(location, map) {
    var markerLatLng, maxZndex, overlay, zInd;
    if (location == null) {
      throw new SuperphyError('Location cannot be determined or location is undefined (not specified)!');
      return 0;
    }
    maxZndex = google.maps.Marker.MAX_ZINDEX;
    zInd = maxZndex + 1;
    markerLatLng = new google.maps.LatLng(location.centerLatLng);
    return overlay = new CartographerOverlay(map, location.centerLatLng, location.locationFormattedAddress);
  };

  InfoSatelliteCartographer.prototype.showLegend = function() {
    return jQuery('.map-search-table').append('<tr> <td> <div class="map-legend"> <div class="col-md-3"> <div class="row"> <div class="col-xs-3"> <img class="map-legend-marker-img" src="/App/Pictures/marker_icon_green.png"> </div> <div class="col-xs-9"> <p class="legendlabel1">Target genome</p> </div> </div> </div> </div> </td> </tr>');
  };

  return InfoSatelliteCartographer;

})(SatelliteCartographer);

CartographerOverlay = (function() {
  function CartographerOverlay(map, latLng, title) {
    this.map = map;
    this.latLng = latLng;
    this.title = title;
    this.setMap(this.map);
    this.div = null;
  }

  CartographerOverlay.prototype = new google.maps.OverlayView();

  CartographerOverlay.prototype.onAdd = function() {
    var div, panes, selectedMarker, svg;
    div = document.createElement('div');
    div.id = "selectedGenome";
    div.style.borderStyle = 'none';
    div.style.borderWidth = '0px';
    div.style.position = 'absolute';
    div.style.width = '15px';
    div.style.height = '15px';
    div.style.cursor = 'pointer';
    svg = d3.select(div).append('svg').attr('height', '15px').attr('width', '15px');
    selectedMarker = svg.append("g").attr('transform', 'translate(0,0)');
    selectedMarker.append("circle").attr('cx', 7.5).attr('cy', 7.5).attr('r', '5px').style({
      'fill': '#ffc966',
      'stroke': '#ffa500',
      'stroke-width': '3px',
      'fill-opacity': '0.5'
    });
    selectedMarker.append("title").text(this.title);
    this.div = div;
    panes = this.getPanes();
    return panes.floatPane.appendChild(div);
  };

  CartographerOverlay.prototype.onRemove = function() {
    this.div.parentNode.removeChild(this.div);
    return this.div = null;
  };

  CartographerOverlay.prototype.draw = function() {
    var div, location, overlayProjection;
    overlayProjection = this.getProjection();
    location = overlayProjection.fromLatLngToDivPixel(this.latLng);
    div = this.div;
    div.style.left = (location.x - 7.5) + 'px';
    return div.style.top = (location.y - 7.5) + 'px';
  };

  return CartographerOverlay;

})();

LocationController = (function() {
  function LocationController(genomeController, parentElem, viewNum) {
    this.genomeController = genomeController;
    this.parentElem = parentElem;
    this.viewNum = viewNum;
    this._populateLocations(this.genomeController);
  }

  LocationController.prototype.pubLocations = null;

  LocationController.prototype.pvtLocations = null;

  LocationController.prototype.pubNoLocations = null;

  LocationController.prototype.pvtNoLocations = null;

  LocationController.prototype.pubMarkers = null;

  LocationController.prototype.pvtMarkers = null;

  LocationController.prototype._populateLocations = function(genomes) {
    var private_genome, pubGenomeId, pubMarker, pubMarkerObj, public_genome, pvtGenomeId, pvtMarker, pvtMarkerObj, _ref, _ref1;
    this.pubLocations = [];
    this.pvtLocations = [];
    this.pubNoLocations = [];
    this.pvtNoLocations = [];
    this.pubMarkers = {};
    this.pvtMarkers = {};
    _ref = genomes.public_genomes;
    for (pubGenomeId in _ref) {
      public_genome = _ref[pubGenomeId];
      if (!((public_genome.isolation_location != null) && public_genome.isolation_location !== "")) {
        this.pubNoLocations.push(pubGenomeId);
      } else {
        pubMarkerObj = this._parseLocation(public_genome);
        this.pubLocations.push(pubGenomeId);
        public_genome.isolation_country = pubMarkerObj['locationCountry'];
        public_genome.isolation_province_state = pubMarkerObj['locationProvinceState'];
        public_genome.isolation_city = pubMarkerObj['locationCity'];
        pubMarker = new google.maps.Marker({
          position: pubMarkerObj['centerLatLng'],
          title: public_genome.uniquename,
          feature_id: pubGenomeId,
          uniquename: public_genome.uniquename,
          location: pubMarkerObj['locationFormattedAddress'],
          isolation_country: pubMarkerObj['locationCountry'],
          isolation_province_state: pubMarkerObj['locationProvinceState'],
          isolation_city: pubMarkerObj['locationCity'],
          privacy: 'public'
        });
        this.pubMarkers[pubGenomeId] = pubMarker;
      }
    }
    _ref1 = genomes.private_genomes;
    for (pvtGenomeId in _ref1) {
      private_genome = _ref1[pvtGenomeId];
      if (!((private_genome.isolation_location != null) && private_genome.isolation_location !== "")) {
        this.pvtNoLocations.push(pvtGenomeId);
      } else {
        pvtMarkerObj = this._parseLocation(private_genome);
        this.pvtLocations.push(pvtGenomeId);
        private_genome.isolation_country = pvtMarkerObj['locationCountry'];
        private_genome.isolation_province_state = pvtMarkerObj['locationProvinceState'];
        private_genome.isolation_city = pvtMarkerObj['locationCity'];
        pvtMarker = new google.maps.Marker({
          position: pvtMarkerObj['centerLatLng'],
          title: private_genome.uniquename,
          feature_id: pvtGenomeId,
          uniquename: private_genome.uniquename,
          location: pvtMarkerObj['locationFormattedAddress'],
          isolation_country: pvtMarkerObj['locationCountry'],
          isolation_province_state: pvtMarkerObj['locationProvinceState'],
          isolation_city: pvtMarkerObj['locationCity'],
          privacy: 'private'
        });
        this.pvtMarkers[pvtGenomeId] = pvtMarker;
      }
    }
    return true;
  };

  LocationController.prototype._parseLocation = function(genome) {
    var add_cmp, centerLatLng, genomeLocation, locationAddressComponents, locationCenter, locationCenterLat, locationCenterLng, locationCoordinates, locationFormattedAddress, locationViewPortNE, locationViewPortNELat, locationViewPortNELng, locationViewPortSW, locationViewPortSWLat, locationViewPortSWLng, markerBounds, markerObj, neLatLng, swLatLng, _i, _len, _ref, _ref1;
    genomeLocation = JSON.parse(genome.isolation_location[0]);
    locationFormattedAddress = genomeLocation.formatted_address;
    locationCoordinates = genomeLocation.geometry;
    locationCenter = locationCoordinates.location;
    locationCenterLat = locationCenter.lat;
    locationCenterLng = locationCenter.lng;
    locationViewPortSW = locationCoordinates.viewport.southwest;
    locationViewPortSWLat = locationViewPortSW.lat;
    locationViewPortSWLng = locationViewPortSW.lng;
    locationViewPortNE = locationCoordinates.viewport.northeast;
    locationViewPortNELat = locationViewPortNE.lat;
    locationViewPortNELng = locationViewPortNE.lng;
    locationAddressComponents = {
      'country': void 0,
      'administrative_area_level_1': void 0,
      'locality': void 0
    };
    _ref = genomeLocation.address_components;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      add_cmp = _ref[_i];
      if (_ref1 = add_cmp.types[0], __indexOf.call(Object.keys(locationAddressComponents), _ref1) >= 0) {
        locationAddressComponents[add_cmp.types[0]] = add_cmp.long_name;
      }
    }
    centerLatLng = new google.maps.LatLng(locationCenterLat, locationCenterLng);
    swLatLng = new google.maps.LatLng(locationViewPortSWLat, locationViewPortSWLng);
    neLatLng = new google.maps.LatLng(locationViewPortNELat, locationViewPortNELng);
    markerBounds = new google.maps.LatLngBounds(swLatLng, neLatLng);
    markerObj = {};
    markerObj['locationFormattedAddress'] = locationFormattedAddress;
    markerObj['locationCountry'] = locationAddressComponents['country'];
    markerObj['locationProvinceState'] = locationAddressComponents['administrative_area_level_1'];
    markerObj['locationCity'] = locationAddressComponents['locality'];
    markerObj['centerLatLng'] = centerLatLng;
    markerObj['markerBounds'] = markerBounds;
    return markerObj;
  };

  return LocationController;

})();
