// Generated by CoffeeScript 1.9.3

/*


 File: superphy.coffee
 Desc: Objects & functions for managing views in Superphy
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 7th, 2013
 */

(function() {
  var AlleleTicker, Cartographer, CartographerOverlay, DotCartographer, GenomeController, GeoPhy, GeophyCartographer, GroupView, Histogram, InfoSatelliteCartographer, ListView, LocationController, LocusController, MapView, MatrixTicker, MatrixView, MetaTicker, MsaView, SatelliteCartographer, SelectionMapView, SelectionView, StxController, StxTicker, SummaryView, SuperphyError, TableView, TickerTemplate, TreeView, ViewController, ViewTemplate, cmp, escapeRegExp, mixOf, parseHeader, root, superphyAlert, superphyMetaOntology, trimInput, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;


  /*
   CLASS SuperphyError
   
   Error object for this library
   */

  SuperphyError = (function(superClass) {
    extend(SuperphyError, superClass);

    function SuperphyError(message, name1) {
      this.message = message != null ? message : '';
      this.name = name1 != null ? name1 : 'Superphy Error';
    }

    return SuperphyError;

  })(Error);


  /*
   CLASS ViewController
    
   Captures events. Updates data and views
   */

  ViewController = (function() {
    function ViewController() {
      if (typeof jQuery === "undefined" || jQuery === null) {
        throw new SuperphyError('jQuery must be loaded before the SuperPhy libary');
      }
      if (typeof URL === "undefined" || URL === null) {
        throw new SuperphyError('SuperPhy library requires the URL library');
      }
      if (typeof Blob === "undefined" || Blob === null) {
        throw new SuperphyError('SuperPhy library requires the Blob library');
      }
    }

    ViewController.prototype.views = [];

    ViewController.prototype.groups = [];

    ViewController.prototype.tickers = [];

    ViewController.prototype.selectedBox = null;

    ViewController.prototype.actionMode = false;

    ViewController.prototype.action = false;

    ViewController.prototype.maxGroups = 10;

    ViewController.prototype.genomeController = void 0;

    ViewController.prototype.init = function(publicGenomes, privateGenomes, actionMode, action, subset) {
      this.actionMode = actionMode;
      this.action = action;
      if (subset == null) {
        subset = null;
      }
      if (!(this.actionMode === 'single_select' || this.actionMode === 'multi_select' || this.actionMode === 'two_groups')) {
        throw new SuperphyError('Unrecognized actionMode in ViewController init() method.');
      }
      this.genomeController = new GenomeController(publicGenomes, privateGenomes, subset);
      this.views = [];
      this.groups = [];
      return this.tickers = [];
    };

    ViewController.prototype.createView = function() {
      var clickStyle, downloadElem, downloadElemDiv, e, elem, listView, mapView, matView, msaView, sumView, tableView, treeView, vNum, viewArgs, viewType;
      viewType = arguments[0], elem = arguments[1], viewArgs = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      clickStyle = 'select';
      vNum = this.views.length + 1;
      if (this.actionMode === 'single_select') {
        clickStyle = 'redirect';
      }
      try {
        if (viewType === 'list') {
          listView = new ListView(elem, clickStyle, vNum, viewArgs);
          listView.update(this.genomeController);
          this.views.push(listView);
        } else if (viewType === 'tree') {
          treeView = new TreeView(elem, clickStyle, vNum, this.genomeController, viewArgs);
          treeView.update(this.genomeController);
          this.views.push(treeView);
        } else if (viewType === 'msa') {
          msaView = new MsaView(elem, clickStyle, vNum, viewArgs);
          msaView.update(this.genomeController);
          this.views.push(msaView);
        } else if (viewType === 'matrix') {
          matView = new MatrixView(elem, clickStyle, vNum, this.genomeController, viewArgs);
          matView.update(this.genomeController);
          this.views.push(matView);
        } else if (viewType === 'map') {
          mapView = new MapView(elem, clickStyle, vNum, this.genomeController, viewArgs);
          this.views.push(mapView);
        } else if (viewType === 'selmap') {
          mapView = new SelectionMapView(elem, clickStyle, vNum, this.genomeController, viewArgs);
          this.views.push(mapView);
        } else if (viewType === 'table') {
          tableView = new TableView(elem, clickStyle, vNum, viewArgs);
          tableView.update(this.genomeController);
          this.views.push(tableView);
        } else if (viewType === 'summary') {
          sumView = new SummaryView(elem, clickStyle, vNum, this.genomeController, viewArgs);
          sumView.update(this.genomeController);
          this.views.push(sumView);
        } else if (viewType === 'jump2table') {
          tableView = new TableView(elem, clickStyle, vNum, viewArgs);
          tableView.update(this.genomeController);
          this.views.push(tableView);
          return;
        } else {
          throw new SuperphyError('Unrecognized viewType <' + viewType + '> in ViewController createView() method.');
          return false;
        }
        downloadElemDiv = jQuery("<div class='download-view'></div>");
        downloadElem = jQuery("<a class='download-view-link' href='#' data-genome-view='" + vNum + "'>Download <i class='fa fa-download'></a>");
        downloadElem.click(function(e) {
          var data, viewNum;
          viewNum = parseInt(this.dataset.genomeView);
          data = viewController.downloadViews(viewNum);
          this.href = data.href;
          this.download = data.file;
          return true;
        });
        downloadElemDiv.append(downloadElem);
        downloadElemDiv.prependTo(elem);
      } catch (_error) {
        e = _error;
        this.viewError(e, elem);
        return false;
      }
      return true;
    };

    ViewController.prototype.viewError = function(e, elem) {
      elem.append("<div class='superphy-error'><p>Superphy Error! View failed to load.</p></div>");
      alert("Superphy error: " + e.message + "\nLine: " + e.line);
      return true;
    };

    ViewController.prototype.introOptions = function() {
      var intros, len, q, ref, v;
      intros = [];
      intros.push({
        element: document.querySelector('#meta-data-form'),
        intro: "Any genome search can be further specified to include various meta-data by checking the corresponding boxes.  This will show more information for each genome on the list, tree, and map, but it will not affect the data.",
        position: 'right'
      });
      intros.push({
        element: document.querySelector('#user-groups'),
        intro: "Preset and user-defined groups can be loaded here as the active group.  Active group genomes will be highlighted in each view.  Use the 'Modify/Delete' tab to create and edit groups from your own selections.  These groups can be accessed from other SuperPhy pages.",
        position: 'right'
      });
      intros.push({
        element: document.querySelector('#filter-form'),
        intro: "Searches can also be filtered to limit the number of genomes displayed on the list, tree, map, and meta-data summary.",
        position: 'right'
      });
      ref = this.views;
      for (q = 0, len = ref.length; q < len; q++) {
        v = ref[q];
        intros = intros.concat(v.intro());
      }
      return intros;
    };

    ViewController.prototype.createGroup = function(boxEl, buttonEl, clearButtonEl) {
      var gNum, grpView;
      gNum = this.groups.length + 1;
      if (gNum > this.maxGroups) {
        return false;
      }
      grpView = new GroupView(boxEl, gNum);
      grpView.update(this.genomeController);
      this.groups.push(grpView);
      buttonEl.click(function(e) {
        e.preventDefault();
        return viewController.addToGroup(gNum);
      });
      clearButtonEl.click(function(e) {
        e.preventDefault();
        return viewController.clearFromGroup(gNum);
      });
      return true;
    };

    ViewController.prototype.addToGroup = function(grp) {
      var i, len, q, ref, selected, v;
      selected = this.genomeController.selected();
      this.genomeController.assignGroup(selected, grp);
      this.genomeController.unselectAll();
      i = grp - 1;
      this.groups[i].add(selected, this.genomeController);
      ref = this.views;
      for (q = 0, len = ref.length; q < len; q++) {
        v = ref[q];
        v.update(this.genomeController);
      }
      if (this.selectedBox != null) {
        return this.selectedBox.update(this.genomeController);
      }
    };

    ViewController.prototype.createTicker = function() {
      var alTicker, elem, matTicker, metaTicker, stxTicker, tNum, tickerArgs, tickerType;
      tickerType = arguments[0], elem = arguments[1], tickerArgs = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      tNum = this.tickers.length + 1;
      if (tickerType === 'meta') {
        metaTicker = new MetaTicker(elem, tNum, tickerArgs);
        metaTicker.update(this.genomeController);
        this.tickers.push(metaTicker);
      } else if (tickerType === 'stx') {
        stxTicker = new StxTicker(elem, tNum, tickerArgs);
        stxTicker.update(this.genomeController);
        this.tickers.push(stxTicker);
      } else if (tickerType === 'matrix') {
        matTicker = new MatrixTicker(elem, tNum, this.genomeController, tickerArgs);
        matTicker.update(this.genomeController);
        this.tickers.push(matTicker);
      } else if (tickerType === 'allele') {
        alTicker = new AlleleTicker(elem, tNum, tickerArgs);
        alTicker.update(this.genomeController);
        this.tickers.push(alTicker);
      } else {
        throw new SuperphyError('Unrecognized tickerType in ViewController createTicker() method.');
        return false;
      }
      return true;
    };

    ViewController.prototype.select = function(g, checked) {
      var len, q, ref, v;
      if (this.actionMode === 'single_select') {
        this.redirect(g);
      } else {
        this.genomeController.select(g, checked);
        ref = this.views;
        for (q = 0, len = ref.length; q < len; q++) {
          v = ref[q];
          v.select(g, checked);
        }
        if (this.selectedBox) {
          this.selectedBox.select(g, this.genomeController, checked);
        }
      }
      return true;
    };

    ViewController.prototype.redirect = function(g) {
      var buttonCloseEl, buttonSubmitEl, displayName, modalView, ref, ref1;
      displayName = (ref = (ref1 = this.genomeController.private_genomes[g]) != null ? ref1.displayname : void 0) != null ? ref : this.genomeController.public_genomes[g].displayname;
      modalView = jQuery('<div class="modal fade" id="view-redirect-modal" tabindex="-1" role="dialog" aria-labelledby="viewRedirectModalLabel" aria-hidden="true"> <div class="modal-dialog modal-sm"> <div class="modal-content"> <div class="modal-header"> <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button> <h4 class="modal-title" id="viewRedirectModalLabel">Retrieve selected genome?</h4> </div> <div class="modal-body"> Would you like to retrieve genome information for the selected genome: <form id="view-redirect-form"> <div class="well well-sm">' + displayName + '</div> <input type="hidden" name="genome" value="' + g + '"/> </form> </div> <div class="modal-footer"> </div> </div> </div> </div>');
      buttonCloseEl = jQuery('<button type="button" class="btn btn-danger" data-dismiss="modal" form="view-redirect-form" value="Cancel">Cancel</button>');
      buttonSubmitEl = jQuery('<button type="submit" id="view-redirect-submit" class="btn btn-success" value="Submit" form="view-redirect-form" formmethod="post" formaction="' + viewController.action + '"> Submit </button>');
      buttonSubmitEl.click(function() {
        return modalView.find('.modal-body').append('<div class="alert alert-success"> <p style="text-align:center">Retrieving genome</p> <div class="loader"> <span></span> </div> </div>');
      });
      modalView.find('.modal-footer').append(buttonCloseEl);
      modalView.find('.modal-footer').append(buttonSubmitEl);
      modalView.modal('show');
      return true;
    };

    ViewController.prototype.removeFromGroup = function(genomeID, grp) {
      var gset, i, len, q, ref, v;
      gset = this.genomeController.genomeSet([genomeID]);
      this.genomeController.deleteGroup(gset);
      i = grp - 1;
      this.groups[i].remove(genomeID);
      ref = this.views;
      for (q = 0, len = ref.length; q < len; q++) {
        v = ref[q];
        v.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.clearFromGroup = function(grp) {
      var actionEl;
      actionEl = jQuery("a[data-genome-group='" + grp + "']");
      return actionEl.click();
    };

    ViewController.prototype.groupForm = function(elem, addMoreBool, submitBool, filterBool) {
      var addEl, blockEl, buttEl, buttonEl, clearFormEl, divEl, hiddenFormEl, submitEl;
      blockEl = jQuery("<div id='group-form-block'></div>").appendTo(elem);
      this.addGroupFormRow(blockEl);
      if (addMoreBool) {
        addEl = jQuery("<div class='add-genome-groups row'></div>");
        divEl = jQuery("<div class='col-md-12'></div>").appendTo(addEl);
        buttEl = jQuery("<button class='btn' type='button'>More Genome Groups...</button>").appendTo(divEl);
        buttEl.click(function(e) {
          var reachedMax;
          reachedMax = viewController.addGroupFormRow(jQuery("#group-form-block"));
          if (!reachedMax) {
            jQuery(this).text('Max groups reached').css('color', 'darkgrey');
            return e.preventDefault();
          }
        });
        elem.append(addEl);
      }
      if (submitBool) {
        submitEl = jQuery("<div class='compare-genome-groups row'></div>");
        divEl = jQuery("<div class='col-md-12'></div>").appendTo(submitEl);
        clearFormEl = jQuery("<button class='btn btn-danger' onclick='location.reload()'><span class='fa fa-times'></span> Reset Form</button>").appendTo(divEl);
        if (filterBool) {
          buttonEl = jQuery("<button type='submit' class='btn btn-primary' value='Submit' form='groups-compare-form'><span class='fa fa-check'></span> Filter Groups</button>").appendTo(divEl);
        }
        if (!filterBool) {
          buttonEl = jQuery("<button type='submit' class='btn btn-primary' value='Submit' form='groups-compare-form'><span class='fa fa-check'></span> Analyze Groups</button>").appendTo(divEl);
        }
        hiddenFormEl = jQuery("<form class='form' id='groups-compare-form' method='post' action='" + this.action + "' enctype='application/x-www-form-urlencoded'></form>").appendTo(divEl);
        buttonEl.click((function(_this) {
          return function(e) {
            var alert, genome, groupGenomes, i, len, q, ref, s;
            e.preventDefault();
            alert = jQuery('<div class="alert alert-danger"> <button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button> You must have at least one genome in either of the groups to compare to. </div>');
            if (!(jQuery('#genome_group1 li').length > 0 || jQuery('#genome_group2 li').length > 0)) {
              blockEl.prepend(alert);
              return false;
            }
            for (i = q = 1, ref = _this.groups.length; q <= ref; i = q += 1) {
              groupGenomes = jQuery("#genome_group" + i + " .genome_group_item");
              for (s = 0, len = groupGenomes.length; s < len; s++) {
                genome = groupGenomes[s];
                jQuery("<input type='hidden' name='group" + i + "-genome' value='" + (jQuery(genome).find('a').data('genome')) + "'>").appendTo(hiddenFormEl);
              }
            }
            jQuery("<input type='hidden' name='num-groups' value='" + _this.groups.length + "'>").appendTo(hiddenFormEl);
            return jQuery('#groups-compare-form').submit();
          };
        })(this));
        elem.append(submitEl);
      }
      return true;
    };

    ViewController.prototype.addGroupFormRow = function(elem) {
      var buttEl, clearButtEl, divEl, formEl, gNum, i, len, listEl, ok, q, ref, rowEl;
      if (typeof elem === 'string') {
        elem = jQuery(elem);
      }
      gNum = this.groups.length + 1;
      if (gNum > this.maxGroups) {
        return false;
      }
      rowEl = jQuery("<div class='group-form-row row'></div>").appendTo(elem);
      ok = true;
      ref = [gNum, gNum + 1];
      for (q = 0, len = ref.length; q < len; q++) {
        i = ref[q];
        formEl = jQuery("<div id='genome-group-form" + i + "' class='genome-group-form col-md-6'></div>");
        listEl = jQuery("<div id='genome-group-list" + i + "' class='genome-group'></div>").appendTo(formEl);
        divEl = jQuery("<div class='genome-group-add-controller'></div>").appendTo(listEl);
        buttEl = jQuery("<button id='genome-group-add" + i + "' class='btn btn-primary' type='button' title='Add genome(s) to Group " + i + "'><span class='fa fa-plus'></span> <span class='input-lg' id='genome-group" + i + "-heading'>Group " + i + "</span></button>").appendTo(divEl);
        clearButtEl = jQuery("<button id='genome-group-clear" + i + "' class='btn btn-primary pull-right' type='button' title='Clear all genome(s) from Group " + i + "'><span class='fa fa-times'></span> <span class='input-lg' id='genome-group" + i + "-heading'></span></button>").appendTo(divEl);
        rowEl.append(formEl);
        ok = this.createGroup(listEl, buttEl, clearButtEl);
      }
      return ok;
    };

    ViewController.prototype.viewAction = function() {
      var vNum, viewArgs;
      vNum = arguments[0], viewArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.views[vNum].viewAction(this.genomeController, viewArgs);
      return true;
    };

    ViewController.prototype.getView = function(vNum) {
      return this.views[vNum];
    };

    ViewController.prototype.updateViews = function(option, checked) {
      var len, len1, len2, q, ref, ref1, ref2, s, t, v, w;
      this.genomeController.updateMeta(option, checked);
      ref = this.views;
      for (q = 0, len = ref.length; q < len; q++) {
        v = ref[q];
        v.update(this.genomeController);
      }
      ref1 = this.groups;
      for (s = 0, len1 = ref1.length; s < len1; s++) {
        v = ref1[s];
        v.update(this.genomeController);
      }
      ref2 = this.tickers;
      for (w = 0, len2 = ref2.length; w < len2; w++) {
        t = ref2[w];
        t.update(this.genomeController);
      }
      if (this.selectedBox != null) {
        this.selectedBox.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.downloadViews = function(viewNum) {
      var blob, dump, file, href, url;
      url = window.URL || window.webkitURL;
      blob = window.Blob;
      dump = this.views[viewNum - 1].dump(this.genomeController);
      file = new blob([dump.data], {
        type: dump.type
      });
      href = url.createObjectURL(file);
      file = "superphy_download." + dump.ext;
      return {
        href: href,
        file: file
      };
    };

    ViewController.prototype.sideBar = function(elem) {
      var form1, form2, form3, parentTarget, wrapper;
      parentTarget = 'sidebar-group';
      wrapper = jQuery('<div class="panel-group" id="' + parentTarget + '"></div>');
      elem.append(wrapper);
      form1 = jQuery('<div id="meta-data-form" class="panel panel-default"></div>');
      wrapper.append(form1);
      this.metaForm(form1, parentTarget);
      form3 = jQuery('<div id="user-groups" class="panel panel-default"></div>');
      wrapper.append(form3);
      this.groupForm(form3, parentTarget);
      form2 = jQuery('<div id="filter-form" class="panel panel-default"></div>');
      wrapper.append(form2);
      this.filterForm(form2, parentTarget);
      return true;
    };

    ViewController.prototype.groupForm = function(elem, parentStr) {
      var group_form, panel_body, panel_header, panel_main, panel_title;
      panel_header = $('<div class="panel-heading"></div>');
      panel_title = $('<div class="panel_title"> <a data-toggle="collapse" href="#group-form"> User Groups <span class="caret"></span></a></div>').appendTo(panel_header);
      panel_main = $('<div id="group-form" class="collapse in"></div>');
      panel_body = $('<div class="panel-body"></div>').appendTo(panel_main);
      group_form = $('<div class="user-groups-menu"></div>').appendTo(panel_body);
      elem.append(panel_header);
      elem.append(panel_main);
      return true;
    };

    ViewController.prototype.sideBarGroupManager = function(elem) {
      var form, parentTarget, wrapper;
      parentTarget = 'sidebar-accordion';
      wrapper = jQuery('#sidebar-accordion');
      form = jQuery('<div class="panel panel-default"></div>');
      wrapper.append(form);
      this.groupsSideForm(form, parentTarget);
      return true;
    };

    ViewController.prototype.createGroupsForm = function(elem, addMoreBool, submitBool, filterBool) {
      var form, parentTarget, wrapper;
      parentTarget = 'groups-compare-panel-body';
      wrapper = jQuery('<div class="panel panel-default" id="groups-compare-panel"></div>');
      elem.append(wrapper);
      form = jQuery('<div class="panel-body" id="' + parentTarget + '"></div>');
      wrapper.append(form);
      this.groupForm(form, addMoreBool, submitBool, filterBool);
      return true;
    };

    ViewController.prototype.metaForm = function(elem, parentStr) {
      var form;
      form = '<div class="panel-heading">' + '<div class="panel-title">' + '<a data-toggle="collapse" href="#meta-form"><i class="fa fa-eye"></i> Meta-data ' + '<span class="caret"></span></a>' + '</div></div>' + '<div id="meta-form" class="collapse in">' + '<div class="panel-body">' + '<p>Select meta-data displayed:</p>' + '<form class="form-inline">' + '<fieldset>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="accession"> Accession # </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="strain"> Strain </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="serotype"> Serotype </label><div id="meta-option_serotype" style="display:none;width:12px;height:12px;background:#004D11;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_host"> Isolation Host </label><div id="meta-option_isolation_host" style="display:none;width:12px;height:12px;background:#9E0015;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_source"> Isolation Source </label><div id="meta-option_isolation_source" style="display:none;width:12px;height:12px;background:#000752;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_date"> Isolation Date </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="syndrome"> Symptoms / Diseases </label><div id="meta-option_syndrome" style="display:none;width:12px;height:12px;background:#520042;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="stx1_subtype"> Stx1 Subtype </label><div id="meta-option_stx1_subtype" style="display:none;width:12px;height:12px;background:#F05C00;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="stx2_subtype"> Stx2 Subtype </label><div id="meta-option_stx2_subtype" style="display:none;width:12px;height:12px;background:#006B5C;border:1px solid #000;position:relative;bottom:15px;left:200px;"></div></div>' + '</fieldset>' + '</form>' + '</div></div>';
      elem.append(form);
      jQuery('input[name="meta-option"]').change(function() {
        return viewController.updateViews(this.value, this.checked);
      });
      return true;
    };

    ViewController.prototype.filterViews = function(filterForm) {
      var aa, g, groupedNodes, len, len1, len2, len3, q, ref, ref1, s, searchTerms, selectedNodes, t, term, v, w;
      if (filterForm === 'selection') {
        this.genomeController.filterBySelection();
      } else {
        searchTerms = null;
        if (filterForm === 'fast') {
          term = jQuery("#fast-filter > input").val().toLowerCase();
          if ((term != null) && term.length) {
            searchTerms = [];
            searchTerms.push({
              searchTerm: term,
              dataField: 'viewname',
              negate: false
            });
          }
        } else {
          searchTerms = this._parseFilterForm();
          if (searchTerms == null) {
            return false;
          }
        }
        this.genomeController.filter(searchTerms);
      }
      this._toggleFilterStatus(true);
      groupedNodes = this.views[1].findGroupedChildren(this.views[1].activeGroup);
      selectedNodes = this.views[1].findGroupedChildren(this.genomeController.selected()["public"].concat(this.genomeController.selected()["private"]));
      if (this.views[1].activeGroup.length > 0) {
        for (q = 0, len = groupedNodes.length; q < len; q++) {
          g = groupedNodes[q];
          this.views[1]._percolateSelected(g.parent, true);
        }
      }
      for (s = 0, len1 = selectedNodes.length; s < len1; s++) {
        g = selectedNodes[s];
        console.log(selectedNodes);
        this.views[1]._percolateSelected(g.parent, true);
      }
      ref = this.views;
      for (w = 0, len2 = ref.length; w < len2; w++) {
        v = ref[w];
        v.update(this.genomeController);
      }
      ref1 = this.tickers;
      for (aa = 0, len3 = ref1.length; aa < len3; aa++) {
        t = ref1[aa];
        t.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.resetFilter = function() {
      var len, len1, q, ref, ref1, results1, s, t, v;
      this.genomeController.filterReset = true;
      this.genomeController.filter();
      this._toggleFilterStatus();
      this._clearFilterForm();
      if ((typeof user_groups_menu !== "undefined" && user_groups_menu !== null) && this.views[2].activeGroup.length > 0) {
        this.views[2].updateActiveGroup(user_groups_menu);
      }
      ref = this.views;
      for (q = 0, len = ref.length; q < len; q++) {
        v = ref[q];
        v.update(this.genomeController);
      }
      ref1 = this.tickers;
      results1 = [];
      for (s = 0, len1 = ref1.length; s < len1; s++) {
        t = ref1[s];
        results1.push(t.update(this.genomeController));
      }
      return results1;
    };

    ViewController.prototype.filterForm = function(elem, parentStr) {
      var advDiv, advForm, advGroup, advLab, advRadio, container, delButton, fastDiv, fastGroup, fastLab, fastRadio, fbg, fbs, filtButton, filtType, filterOff, filterOn, filterStatus, findButton, header, numVisible, selDiv, selGroup, selLab, selRadio, sf;
      header = jQuery('<div class="panel-heading">' + '<div class="panel-title">' + '<a data-toggle="collapse" href="#filter-form"><i class="fa fa-filter"></i> Filter ' + '<span class="caret"></span></a>' + '</div></div>').appendTo(elem);
      container = jQuery('<div id="filter-form" class="panel-collapse collapse in"></div>');
      numVisible = this.genomeController.filtered;
      filterStatus = jQuery('<div id="filter-status"></div>');
      filterOn = jQuery("<div id='filter-on'><div id='filter-on-text' class='alert alert-warning'>Filter active. " + numVisible + " genomes visible.</div></div>");
      filterOff = jQuery('<div id="filter-off"></div>');
      delButton = jQuery('<button id="remove-filter" type="button" class="btn btn-sm">Clear</button>');
      delButton.click(function(e) {
        e.preventDefault();
        return viewController.resetFilter();
      });
      delButton.appendTo(filterOn);
      if (numVisible > 0) {
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      filterStatus.append(filterOn);
      filterStatus.append(filterOff);
      container.append(filterStatus);
      container.append('<p>Limit genomes displayed in views by:</p>');
      filtType = jQuery('<form id="select-filter-form" class="form-horizontal"></form>');
      fastGroup = jQuery('<div class="form-group"></div>');
      fastDiv = jQuery('<div class="col-xs-1"></div>').appendTo(fastGroup);
      fastRadio = jQuery('<input id="fast" type="radio" name="filter-form-type" value="fast" checked>').appendTo(fastDiv);
      fastLab = jQuery('<label class="col-xs-10" for="fast">Basic</label>').appendTo(fastGroup);
      fastRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").show();
          jQuery("#adv-filter").hide();
          jQuery("#selection-filter").hide();
          jQuery("#group-filter").hide();
        }
        return true;
      });
      filtType.append(fastGroup);
      advGroup = jQuery('<div class="form-group"></div>');
      advDiv = jQuery('<div class="col-xs-1"></div>').appendTo(advGroup);
      advRadio = jQuery('<input type="radio" id="adv" name="filter-form-type" value="advanced">').appendTo(advDiv);
      advLab = jQuery('<label class="col-xs-10" for="adv">Advanced</label>').appendTo(advGroup);
      advRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").show();
          jQuery("#selection-filter").hide();
          jQuery("#group-filter").hide();
        }
        return true;
      });
      filtType.append(advGroup);
      selGroup = jQuery('<div class="form-group"></div>');
      selDiv = jQuery('<div class="col-xs-1"></div>').appendTo(selGroup);
      selRadio = jQuery('<input id="sel" type="radio" name="filter-form-type" value="selection">').appendTo(selDiv);
      selLab = jQuery('<label class="col-xs-10" for="sel">By Selection</label>').appendTo(selGroup);
      selRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").hide();
          jQuery("#selection-filter").show();
          jQuery("#group-filter").hide();
        }
        return true;
      });
      filtType.append(selGroup);
      container.append(filtType);
      sf = jQuery("<div id='fast-filter'></div>");
      this.addFastFilter(sf);
      container.append(sf);
      advForm = jQuery("<div id='adv-filter'></div>");
      this.addAdvancedFilter(advForm);
      advForm.hide();
      container.append(advForm);
      fbs = jQuery("<div id='selection-filter'>" + "<p>A selection in one of the views (i.e. genomes selected in a clade or map region)</p>" + "</div>");
      filtButton = jQuery('<button id="filter-selection-button" type="button" class="btn btn-sm">Filter by selection</button>');
      filtButton.click(function(e) {
        e.preventDefault();
        return viewController.filterViews('selection');
      });
      fbs.append(filtButton);
      fbs.hide();
      container.append(fbs);
      fbg = jQuery("<div class='row' id='group-filter'>" + "<p>A group in one of the views</p>" + "</div>");
      findButton = jQuery('<div class="col-xs-3"><button id="user-groups-submit" class="btn btn btn-sm" type="button">Select</button></div>');
      fbg.append(findButton);
      filtButton = jQuery('<div class="col-xs-3"><button id="filter-group-button" type="button" class="btn btn-sm">Filter</button></div>');
      filtButton.click(function(e) {
        e.preventDefault();
        return viewController.filterViews('selection');
      });
      fbg.append(filtButton);
      fbg.hide();
      container.append(fbg);
      container.appendTo(elem);
      return true;
    };

    ViewController.prototype._toggleFilterStatus = function(attempt) {
      var filterOff, filterOn, numVisible;
      if (attempt == null) {
        attempt = false;
      }
      numVisible = this.genomeController.filtered;
      filterOn = jQuery('#filter-on');
      filterOff = jQuery('#filter-off');
      if (numVisible > 0) {
        filterOn.find('#filter-on-text').text("Filter active. " + numVisible + " genomes visible.");
        filterOn.show();
        filterOff.hide();
      } else if (numVisible === 0 && attempt) {
        filterOn.find('#filter-on-text').text("No genomes match search criteria.");
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      return true;
    };

    ViewController.prototype._toggleSelectAll = function(switchOn, hardLimit) {
      var buttonGp, divEl, numVisible, selectAllButt, selectAllRow, unSelectAllButt;
      numVisible = this.genomeController.filtered;
      selectAllRow = jQuery('.select-all-genomes-row');
      selectAllRow.empty();
      divEl = jQuery('<div class="col-md-6"></div>');
      buttonGp = jQuery('<div class="btn-group"></div>').appendTo(divEl);
      selectAllButt = jQuery('<button id="table-select-all" class="btn btn-link">Select All</button>').appendTo(buttonGp);
      unSelectAllButt = jQuery('<button id="table-unselect-all" class="btn btn-link">Unselect All</button>').appendTo(buttonGp);
      selectAllButt.click((function(_this) {
        return function(e) {
          var g, len, len1, q, ref, ref1, results1, s;
          e.preventDefault();
          ref = _this.genomeController.pubVisible;
          for (q = 0, len = ref.length; q < len; q++) {
            g = ref[q];
            _this.select(g, true);
          }
          ref1 = _this.genomeController.pvtVisible;
          results1 = [];
          for (s = 0, len1 = ref1.length; s < len1; s++) {
            g = ref1[s];
            results1.push(_this.select(g, true));
          }
          return results1;
        };
      })(this));
      unSelectAllButt.click((function(_this) {
        return function(e) {
          var g, len, len1, q, ref, ref1, results1, s;
          e.preventDefault();
          ref = _this.genomeController.pubVisible;
          for (q = 0, len = ref.length; q < len; q++) {
            g = ref[q];
            _this.select(g, false);
          }
          ref1 = _this.genomeController.pvtVisible;
          results1 = [];
          for (s = 0, len1 = ref1.length; s < len1; s++) {
            g = ref1[s];
            results1.push(_this.select(g, false));
          }
          return results1;
        };
      })(this));
      if (switchOn && numVisible <= hardLimit) {
        selectAllRow.append(divEl);
      } else {

      }
      return true;
    };

    ViewController.prototype._clearFilterForm = function() {
      var advForm, sf;
      sf = jQuery("#fast-filter");
      sf.empty();
      this.addFastFilter(sf);
      advForm = jQuery("#adv-filter");
      advForm.empty();
      this.addAdvancedFilter(advForm);
      return true;
    };

    ViewController.prototype.addAdvancedFilter = function(elem) {
      var addRow, advButton, advRows;
      elem.append("<p>Boolean keyword search of specified meta-data fields</p>");
      advRows = jQuery("<div id='adv-filter-rows'></div>");
      elem.append(advRows);
      this.addFilterRow(advRows, 1);
      advButton = jQuery('<button id="adv-filter-submit" type="button" class="btn btn-sm">Filter</button>');
      elem.append(advButton);
      advButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('advanced');
      });
      addRow = jQuery('<a href="#" class="adv-filter-addition">Add term</a>');
      addRow.click(function(e) {
        var rowI, rows;
        e.preventDefault();
        rows = jQuery('.adv-filter-row');
        rowI = rows.length + 1;
        return viewController.addFilterRow(jQuery('#adv-filter-rows'), rowI);
      });
      elem.append(addRow);
      return true;
    };


    /*  
     * FUNC addFilterRow
     * Adds additional search term row to advanced filter form.
     * Multiple search terms are joined using boolean operators.
     *
     * PARAMS
     * elem - jQuery element object of rows
     * rowNum - sequential number for new row
     * 
     * RETURNS
     * boolean 
     *       
    addFilterRow: (elem, rowNum) ->
      
       * Row wrapper
      row = jQuery('<div class="adv-filter-row" data-filter-row="' + rowNum + '"></div>').appendTo(elem)
      
       * Term join operation
      if rowNum isnt 1
        jQuery('<select name="adv-filter-op" data-filter-row="' + rowNum + '">' +
          '<option value="and" selected="selected">AND</option>' +
          '<option value="or">OR</option>' +
          '<option value="not">NOT</option>' +
          '</select>').appendTo(row)
      
       * Field type
      dropDown = jQuery('<select name="adv-filter-field" data-filter-row="' + rowNum + '"></select>').appendTo(row)
      for k,v of @genomeController.metaMap
          dropDown.append('<option value="' + k + '">' + v + '</option>')
      
      dropDown.append('<option value="displayname" selected="selected">Genome name</option>')
      
       * Change type of search term box depending on field type
      dropDown.change ->
        thisRow = this.dataset.filterRow
        if @.value is 'isolation_date'
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide()
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show()
        else
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show()
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide()
        true
      
       * Keyword-based search wrapper
      keyw = jQuery('<div class="adv-filter-keyword" data-filter-row="' + rowNum + '"></div>)')
      
       * Search term box
      jQuery('<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>').appendTo(keyw)
      keyw.appendTo(row)
      
       * Predefined search term dropdowns
       * Host
      
      
    
       * Date-based search wrapper
      dt = jQuery('<div class="adv-filter-date" data-filter-row="' + rowNum + '"></div>)')
      dt.append('<select name="adv-filter-before" data-filter-row="' + rowNum + '">' +
        '<option value="before" selected="selected">before</option>' +
        '<option value="after">after</option>' +
        '</select>')
      dt.append('<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>')
      dt.append('<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>')
      dt.append('<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>')
      dt.hide()
      dt.appendTo(row)
      
       * Delete button
      if rowNum isnt 1
        delRow = jQuery('<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>')
        delRow.appendTo(row)
    
         * Delete row wrapper
        delRow.click (e) ->
          e.preventDefault()
          thisRow = this.dataset.filterRow
          jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove()
    
      true
     */

    ViewController.prototype.addFilterRow = function(elem, rowNum) {
      var db, delRow, dropDown, dt, fd, fdt, ff, fh, fht, fs, fst, hosts, k, keyw, len, len1, len2, q, ref, ref1, ref2, ref3, row, rowObj, s, sources, syndromes, v, w;
      row = '<div class="adv-filter-row" data-filter-row="' + rowNum + '">';
      row += '<div class="adv-filter-header">';
      if (rowNum !== 1) {
        row += '<select name="adv-filter-op" data-filter-row="' + rowNum + '">' + '<option value="and" selected="selected">AND</option>' + '<option value="or">OR</option>' + '<option value="not">NOT</option>' + '</select>';
      }
      dropDown = '<select name="adv-filter-field" data-filter-row="' + rowNum + '">';
      ref = this.genomeController.metaMap;
      for (k in ref) {
        v = ref[k];
        dropDown += '<option value="' + k + '">' + v + '</option>';
      }
      dropDown += '<option value="displayname" selected="selected">Genome name</option></select>';
      row += dropDown;
      row += '</div><div class="adv-filter-body">';
      keyw = '<div class="adv-filter-keyword" data-filter-row="' + rowNum + '">';
      keyw += '<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>';
      keyw += '</div>';
      row += keyw;
      hosts = '<div class="adv-filter-host-terms" data-filter-row="' + rowNum + '">';
      hosts += '<select name="adv-filter-hosts" data-filter-row="' + rowNum + '">';
      hosts += '<option value="">--Select Host--</option>';
      ref1 = superphyMetaOntology["hosts"];
      for (q = 0, len = ref1.length; q < len; q++) {
        v = ref1[q];
        hosts += '<option value="' + v + '">' + v + '</option>';
      }
      hosts += '<option value="other">Other (fill in field below)</option></select>';
      hosts += '<input type="text" name="adv-filter-host-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
      hosts += '</div>';
      row += hosts;
      sources = '<div class="adv-filter-source-terms" data-filter-row="' + rowNum + '">';
      sources += '<select name="adv-filter-sources" data-filter-row="' + rowNum + '">';
      sources += '<option value="">--Select Source--</option>';
      ref2 = superphyMetaOntology["sources"];
      for (s = 0, len1 = ref2.length; s < len1; s++) {
        v = ref2[s];
        sources += '<option value="' + v + '">' + v + '</option>';
      }
      sources += '<option value="other">Other (fill in field below)</option></select>';
      sources += '<input type="text" name="adv-filter-source-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
      sources += '</div>';
      row += sources;
      syndromes = '<div class="adv-filter-syndrome-terms" data-filter-row="' + rowNum + '">';
      syndromes += '<select name="adv-filter-syndromes" data-filter-row="' + rowNum + '">';
      syndromes += '<option value="">--Select Syndrome--</option>';
      ref3 = superphyMetaOntology["syndromes"];
      for (w = 0, len2 = ref3.length; w < len2; w++) {
        v = ref3[w];
        syndromes += '<option value="' + v + '">' + v + '</option>';
      }
      syndromes += '<option value="other">Other (fill in field below)</option></select>';
      syndromes += '<input type="text" name="adv-filter-syndrome-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
      syndromes += '</div>';
      row += syndromes;
      dt = '<div class="adv-filter-date" data-filter-row="' + rowNum + '">';
      dt += '<select name="adv-filter-before" data-filter-row="' + rowNum + '">' + '<option value="before" selected="selected">before</option>' + '<option value="after">after</option>' + '</select>';
      dt += '<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>';
      dt += '<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>';
      dt += '<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>';
      dt += '</div>';
      row += dt;
      if (rowNum !== 1) {
        delRow = '<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>';
        row += delRow;
      }
      row += '</div>';
      rowObj = jQuery(row);
      ff = rowObj.find('[name="adv-filter-field"][data-filter-row="' + rowNum + '"]');
      ff.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'isolation_date') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
        } else if (this.value === 'isolation_host') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').show();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
        } else if (this.value === 'isolation_source') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').show();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
        } else if (this.value === 'syndrome') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').show();
        } else {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
        }
        return true;
      });
      fht = rowObj.find('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]');
      fh = fht.find('[name="adv-filter-hosts"]');
      fh.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'other') {
          return jQuery('[name="adv-filter-host-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
        } else {
          return jQuery('[name="adv-filter-host-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
        }
      });
      fht.hide();
      fst = rowObj.find('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]');
      fs = fst.find('[name="adv-filter-sources"]');
      fs.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'other') {
          return jQuery('[name="adv-filter-source-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
        } else {
          return jQuery('[name="adv-filter-source-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
        }
      });
      fst.hide();
      fdt = rowObj.find('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]');
      fd = fdt.find('[name="adv-filter-syndromes"]');
      fd.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'other') {
          return jQuery('[name="adv-filter-syndrome-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
        } else {
          return jQuery('[name="adv-filter-syndrome-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
        }
      });
      fdt.hide();
      fd = rowObj.find('.adv-filter-date[data-filter-row="' + rowNum + '"]');
      fd.hide();
      if (rowNum !== 1) {
        db = rowObj.find('.adv-filter-subtraction[data-filter-row="' + rowNum + '"]');
        db.click(function(e) {
          var thisRow;
          e.preventDefault();
          thisRow = this.dataset.filterRow;
          console.log('del' + thisRow);
          return jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove();
        });
      }
      elem.append(rowObj);
      return true;
    };

    ViewController.prototype.addFastFilter = function(elem) {
      var fastButton, tBox;
      elem.append("<p>Basic genome name filter</p>");
      tBox = jQuery('<input type="text" name="fast-filter-term" placeholder="Filter by..."></input>');
      fastButton = jQuery('<button id="fast-filter-submit" type="button" class="btn btn-sm">Filter</button>');
      fastButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('fast');
      });
      tBox.appendTo(elem);
      fastButton.appendTo(elem);
      return true;
    };

    ViewController.prototype._parseFilterForm = function() {
      var bef, date, df, dy, isBefore, isDate, len, mn, negate, op, q, row, rowNum, rows, searchTerms, t, term, yr;
      rows = jQuery('.adv-filter-row');
      searchTerms = [];
      for (q = 0, len = rows.length; q < len; q++) {
        row = rows[q];
        t = {};
        rowNum = parseInt(row.dataset.filterRow);
        df = jQuery("[name='adv-filter-field'][data-filter-row='" + rowNum + "']").val();
        t.dataField = df;
        isDate = false;
        if (df === 'isolation_date') {
          isDate = true;
        }
        if (!isDate) {
          if (df === 'isolation_host') {
            term = jQuery("[name='adv-filter-hosts'][data-filter-row='" + rowNum + "']").val();
            if (term === 'other') {
              term = jQuery("[name='adv-filter-host-other'][data-filter-row='" + rowNum + "']").val();
              term = trimInput(term, 'keyword');
            }
            if (!((term != null) && term !== "")) {
              alert('Error: empty field.');
              return null;
            }
            t.searchTerm = term;
          } else if (df === 'isolation_source') {
            term = jQuery("[name='adv-filter-sources'][data-filter-row='" + rowNum + "']").val();
            if (term === 'other') {
              term = jQuery("[name='adv-filter-source-other'][data-filter-row='" + rowNum + "']").val();
              term = trimInput(term, 'keyword');
            }
            if (!((term != null) && term !== "")) {
              alert('Error: empty field.');
              return null;
            }
            t.searchTerm = term;
          } else if (df === 'syndrome') {
            term = jQuery("[name='adv-filter-syndromes'][data-filter-row='" + rowNum + "']").val();
            if (term === 'other') {
              term = jQuery("[name='adv-filter-syndrome-other'][data-filter-row='" + rowNum + "']").val();
              term = trimInput(term, 'keyword');
            }
            if (!((term != null) && term !== "")) {
              alert('Error: empty field.');
              return null;
            }
            t.searchTerm = term;
          } else {
            term = jQuery("[name='adv-filter-term'][data-filter-row='" + rowNum + "']").val();
            term = trimInput(term, 'keyword');
            if (!((term != null) && term !== "")) {
              alert('Error: empty field.');
              return null;
            }
            t.searchTerm = term;
          }
        } else {
          bef = jQuery("[name='adv-filter-before'][data-filter-row='" + rowNum + "']").val();
          if (!(bef === 'before' || bef === 'after')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-before" must contain strings "before","after".');
          }
          isBefore = true;
          if (bef === 'after') {
            isBefore = false;
          }
          yr = jQuery("[name='adv-filter-year'][data-filter-row='" + rowNum + "']").val();
          yr = trimInput(yr, 'Year');
          if (yr == null) {
            return null;
          }
          if (!/^[1-9][0-9]{3}$/.test(yr)) {
            alert('Error: invalid Year.');
            return null;
          }
          mn = jQuery("[name='adv-filter-mon'][data-filter-row='" + rowNum + "']").val();
          if (mn != null) {
            mn = jQuery.trim(mn);
          }
          if ((mn != null) && mn.length) {
            if (!/^[0-9]{1,2}$/.test(mn)) {
              alert('Error: invalid Month.');
              return null;
            }
          } else {
            mn = '01';
          }
          dy = jQuery("[name='adv-filter-day'][data-filter-row='" + rowNum + "']").val();
          if (dy != null) {
            dy = jQuery.trim(dy);
          }
          if ((dy != null) && dy.length) {
            if (!/^[0-9]{1,2}$/.test(dy)) {
              alert('Error: invalid Day.');
              return null;
            }
          } else {
            dy = '01';
          }
          date = Date.parse(yr + "-" + mn + "-" + dy);
          if (isNaN(date)) {
            alert('Error: invalid date.');
            return null;
          }
          t.date = date;
          t.before = isBefore;
        }
        if (rowNum !== 1) {
          op = jQuery("[name='adv-filter-op'][data-filter-row='" + rowNum + "']").val();
          negate = false;
          if (!(op === 'or' || op === 'and' || op === 'not')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-op" must contain strings "and","or","not".');
          }
          if (op === 'not') {
            op = 'and';
            negate = true;
          }
          t.op = op;
          t.negate = negate;
          searchTerms.push(t);
        } else {
          t.negate = false;
          searchTerms.unshift(t);
        }
      }
      return searchTerms;
    };

    ViewController.prototype.createSelectionView = function(boxEl, countEl) {
      var selView;
      if (countEl == null) {
        countEl = null;
      }
      if (this.selectedBox != null) {
        throw new SuperphyError('Existing SelectionView. Cannot create multiple views of this type.');
      }
      selView = new SelectionView(boxEl, countEl);
      selView.update(this.genomeController);
      this.selectedBox = selView;
      return true;
    };

    ViewController.prototype.submitGenomes = function(formEl, paramType) {
      var g, genomes, gset, input, k, len, q, ref, ref1, results1, results2, v;
      if (paramType == null) {
        paramType = 'selected';
      }
      if (paramType === 'selected') {
        gset = this.genomeController.selected();
        genomes = gset["public"].concat(gset["private"]);
        results1 = [];
        for (q = 0, len = genomes.length; q < len; q++) {
          g = genomes[q];
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', 'genome');
          input.val(g);
          results1.push(formEl.append(input));
        }
        return results1;
      } else if (paramType === 'grouped') {
        ref = this.genomeController.public_genomes;
        for (k in ref) {
          v = ref[k];
          if (!(v.assignedGroup != null)) {
            continue;
          }
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', "group" + v.assignedGroup);
          input.val(g);
          formEl.append(input);
        }
        ref1 = this.genomeController.private_genomes;
        results2 = [];
        for (k in ref1) {
          v = ref1[k];
          if (!(v.assignedGroup != null)) {
            continue;
          }
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', "group" + v.assignedGroup);
          input.val(g);
          results2.push(formEl.append(input));
        }
        return results2;
      } else {
        throw new SuperphyError("Unknown paramType parameter: " + paramType);
      }
    };

    ViewController.prototype.highlightInView = function(searchStr, vNum) {
      var targetList;
      if (!(searchStr && searchStr.length)) {
        return false;
      }
      targetList = this.genomeController.find(searchStr);
      if (targetList && targetList.length) {
        this.views[vNum].highlightGenomes(this.genomeController, targetList);
      } else {
        superphyAlert("Search string " + searchStr + " matches no currently visible genomes.", "None Found");
      }
      return true;
    };

    return ViewController;

  })();

  if (!root.ViewController) {
    root.viewController = new ViewController;
  }


  /*
   CLASS ViewTemplate
   
   Template object for views. Defines required and
   common properties/methods. All view objects
   are descendants of the ViewTemplate.
   */

  ViewTemplate = (function() {
    function ViewTemplate(parentElem, style1, elNum) {
      this.parentElem = parentElem;
      this.style = style1 != null ? style1 : 'select';
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    ViewTemplate.prototype.type = void 0;

    ViewTemplate.prototype.elNum = 1;

    ViewTemplate.prototype.elName = 'view';

    ViewTemplate.prototype.elID = void 0;

    ViewTemplate.prototype.parentElem = void 0;

    ViewTemplate.prototype.style = 'select';

    ViewTemplate.prototype.update = function(genomes) {
      throw new SuperphyError("ViewTemplate method update() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.updateCSS = function(gset, genomes) {
      throw new SuperphyError("ViewTemplate method updateCSS() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.select = function(genome, isSelected) {
      throw new SuperphyError("ViewTemplate method select() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.dump = function(genomes) {
      throw new SuperphyError("ViewTemplate method dump() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.viewAction = function() {
      var args, genomes;
      genomes = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      throw new SuperphyError("viewAction method has not been defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.highlightGenomes = function() {
      var args, genomes, targetList;
      genomes = arguments[0], targetList = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      throw new SuperphyError("highlightGenomes method has not been defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    return ViewTemplate;

  })();


  /*
   CLASS ListView
   
   Genome list
   
   Always genome-based
   Returns genome ID to redirect/select when genome list item is clicked
   */

  ListView = (function(superClass) {
    extend(ListView, superClass);

    function ListView(parentElem, style1, elNum, listArgs) {
      this.parentElem = parentElem;
      this.style = style1;
      this.elNum = elNum;
      if ((listArgs != null) && (listArgs[0] != null)) {
        this.locusData = listArgs[0];
      }
      ListView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
    }

    ListView.prototype.type = 'list';

    ListView.prototype.elName = 'genome_list';

    ListView.prototype.locusData = null;

    ListView.prototype.update = function(genomes) {
      var ft, listElem, t1, t2;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      t1 = new Date();
      this._appendGenomes(listElem, genomes.pubVisible, genomes.public_genomes, this.style, false);
      this._appendGenomes(listElem, genomes.pvtVisible, genomes.private_genomes, this.style, true);
      t2 = new Date();
      ft = t2 - t1;
      console.log('ListView update elapsed time: ' + ft);
      return true;
    };

    ListView.prototype._appendGenomes = function(el, visibleG, genomes, style, priv) {
      var actionEl, checked, cls, g, labEl, len, listEl, name, q, thiscls;
      cls = this.cssClass();
      if (priv && visibleG.length) {
        el.append("<li class='genome_list_spacer'>---- USER-SUBMITTED GENOMES ----</li>");
      }
      for (q = 0, len = visibleG.length; q < len; q++) {
        g = visibleG[q];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        name = genomes[g].viewname;
        if (this.locusData != null) {
          name += this.locusData.genomeString(g);
        }
        if (style === 'redirect') {
          listEl = jQuery("<li class='" + thiscls + "'>" + name + "</li>");
          actionEl = jQuery("<a href='#' data-genome='" + g + "'> <span class='fa fa-search'></span>info</a>");
          actionEl.click(function(e) {
            var gid;
            e.preventDefault();
            gid = this.dataset.genome;
            return viewController.select(gid, true);
          });
          listEl.append(actionEl);
          el.append(listEl);
        } else if (style === 'select') {
          checked = '';
          if (genomes[g].isSelected) {
            checked = 'checked';
          }
          listEl = jQuery("<li class='" + thiscls + "'></li>");
          labEl = jQuery("<label class='checkbox'>" + name + "</label>");
          actionEl = jQuery("<input class='checkbox' type='checkbox' value='" + g + "' " + checked + "/>");
          actionEl.change(function(e) {
            e.preventDefault();
            return viewController.select(this.value, this.checked);
          });
          labEl.append(actionEl);
          listEl.append(labEl);
          el.append(listEl);
        } else {
          return false;
        }
      }
      return true;
    };

    ListView.prototype.updateCSS = function(gset, genomes) {
      var listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call ListView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    ListView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, len, liEl, q, thiscls;
      cls = this.cssClass();
      for (q = 0, len = changedG.length; q < len; q++) {
        g = changedG[q];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        liEl = null;
      }
      if (this.style === 'redirect') {
        descriptor = "td > a[data-genome='" + g + "']";
        itemEl = el.find(descriptor);
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
          return false;
        }
        liEl = itemEl.parent();
      } else if (this.style === 'select') {
        descriptor = "td input[value='" + g + "']";
        itemEl = el.find(descriptor);
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
          return false;
        }
        liEl = itemEl.parents().eq(1);
      } else {
        return false;
      }
      liEl.attr('class', thiscls);
      return true;
    };

    ListView.prototype.select = function(genome, isSelected) {
      var descriptor, itemEl;
      itemEl = null;
      if (this.style === 'select') {
        descriptor = "li input[value='" + genome + "']";
        itemEl = jQuery(descriptor);
      } else {
        return false;
      }
      if (!((itemEl != null) && itemEl.length)) {
        throw new SuperphyError("List element for genome " + genome + " not found in ListView " + this.elID);
        return false;
      }
      itemEl.prop('checked', isSelected);
      return true;
    };

    ListView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, ref, ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var len, q, ref, results1;
        ref = genomes.mtypes;
        results1 = [];
        for (q = 0, len = ref.length; q < len; q++) {
          k = ref[q];
          results1.push(genomes.metaMap[k]);
        }
        return results1;
      })();
      header.unshift("Genome name");
      output += "#" + header.join("\t") + "\n";
      ref = genomes.public_genomes;
      for (id in ref) {
        g = ref[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      ref1 = genomes.private_genomes;
      for (id in ref1) {
        g = ref1[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    return ListView;

  })(ViewTemplate);


  /*
   CLASS GroupView
   
   A special type of genome list that is used to temporarily store the user's
   selected genomes.
   
   Only one 'style' which provides a remove button to remove group from group.
   Will be updated by changes to the meta-display options but not by filtering.
   */

  GroupView = (function() {
    function GroupView(parentElem, elNum) {
      this.parentElem = parentElem;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    GroupView.prototype.type = 'group';

    GroupView.prototype.elNum = 1;

    GroupView.prototype.elName = 'genome_group';

    GroupView.prototype.elID = void 0;

    GroupView.prototype.update = function(genomes) {
      var ingrp, listElem;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      ingrp = genomes.grouped(this.elNum);
      this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
      this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
      return true;
    };

    GroupView.prototype.add = function(genomeSet, genomes) {
      var listElem;
      listElem = jQuery("#" + this.elID);
      if (!listElem.length) {
        listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      if (genomeSet["public"] != null) {
        this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
      }
      if (genomeSet["private"] != null) {
        return this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
      }
    };

    GroupView.prototype._appendGenomes = function(el, visibleG, genomes) {
      var actionEl, cls, g, len, listEl, q;
      cls = this.cssClass();
      for (q = 0, len = visibleG.length; q < len; q++) {
        g = visibleG[q];
        listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
        actionEl = jQuery("<a href='#' data-genome='" + g + "' data-genome-group='" + this.elNum + "'> <i class='fa fa-times'></a>");
        actionEl.click(function(e) {
          var gid, grp;
          e.preventDefault();
          gid = this.dataset.genome;
          grp = this.dataset.genomeGroup;
          console.log('clicked remove on ' + gid);
          return viewController.removeFromGroup(gid, grp);
        });
        listEl.append(actionEl);
        el.append(listEl);
      }
      return true;
    };

    GroupView.prototype.remove = function(gid) {
      var descriptor, linkEl, listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call GroupView method remove().");
      }
      descriptor = "li > a[data-genome='" + gid + "']";
      linkEl = listEl.find(descriptor);
      if (!((linkEl != null) && linkEl.length)) {
        throw new SuperphyError("List item element for genome " + gid + " not found in GroupView " + this.elID);
        return false;
      }
      linkEl.parent('li').remove();
      return true;
    };

    GroupView.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    return GroupView;

  })();


  /*
   CLASS GenomeController
   
   Manages private/public genome list
   */

  GenomeController = (function() {
    var mtypesDisplayed;

    function GenomeController(public_genomes1, private_genomes1, subset) {
      var countPri, countPub, g, i, id, len, len1, len2, newPri, newPub, q, ref, ref1, s, w;
      this.public_genomes = public_genomes1;
      this.private_genomes = private_genomes1;
      if (subset == null) {
        subset = null;
      }
      if (subset != null) {
        newPub = {};
        newPri = {};
        for (q = 0, len = subset.length; q < len; q++) {
          i = subset[q];
          if (this.public_genomes[i] != null) {
            newPub[i] = this.public_genomes[i];
          } else if (this.private_genomes[i] != null) {
            newPri[i] = this.private_genomes[i];
          }
        }
        this.public_genomes = newPub;
        this.private_genomes = newPri;
      }
      this.update();
      this.filter();
      ref = this.public_genomes;
      for (g = s = 0, len1 = ref.length; s < len1; g = ++s) {
        id = ref[g];
        countPub = this.countMeta(g);
      }
      ref1 = this.private_genomes;
      for (g = w = 0, len2 = ref1.length; w < len2; g = ++w) {
        id = ref1[g];
        countPri = this.countMeta(g);
      }
      this.genomeSetId = 0;
    }

    GenomeController.prototype.pubVisible = [];

    GenomeController.prototype.pvtVisible = [];

    GenomeController.prototype.filterReset = false;

    GenomeController.prototype.visibleMeta = {
      strain: false,
      serotype: false,
      isolation_host: false,
      isolation_source: false,
      isolation_date: false,
      accession: false,
      syndrome: false,
      stx1_subtype: false,
      stx2_subtype: false
    };

    GenomeController.prototype.metaMap = {
      'strain': 'Strain',
      'serotype': 'Serotype',
      'isolation_host': 'Host',
      'isolation_source': 'Source',
      'isolation_date': 'Date of isolation',
      'accession': 'Accession ID',
      'syndrome': 'Symptom / Disease',
      'stx1_subtype': 'Stx1 Subtype',
      'stx2_subtype': 'Stx2 Subtype'
    };

    GenomeController.prototype.mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype', 'accession'];

    GenomeController.prototype.publicRegexp = new RegExp('^public_');

    GenomeController.prototype.privateRegexp = new RegExp('^private_');

    GenomeController.prototype.meta_option = '';

    GenomeController.prototype.filtered = 0;

    GenomeController.prototype.firstRun = true;

    mtypesDisplayed = ['serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype'];

    GenomeController.prototype.update = function() {
      var g, id, ma, ref, ref1;
      if (this.firstRun) {
        this.visibleMeta['serotype'] = true;
        this.visibleMeta['isolation_host'] = true;
        this.visibleMeta['isolation_source'] = true;
      }
      this.firstRun = false;
      ref = this.public_genomes;
      for (id in ref) {
        g = ref[id];
        ma = this.label(g, this.visibleMeta, null);
        g.viewname = ma.join('|');
        g.meta_array = ma;
      }
      ref1 = this.private_genomes;
      for (id in ref1) {
        g = ref1[id];
        ma = this.label(g, this.visibleMeta, null);
        g.viewname = ma.join('|');
        g.meta_array = ma;
      }
      return true;
    };

    GenomeController.prototype.filter = function(searchTerms) {
      var g, i, len, len1, pubGenomeIds, pvtGenomeIds, q, ref, ref1, ref2, ref3, results, s;
      if (searchTerms == null) {
        searchTerms = null;
      }
      pubGenomeIds = [];
      pvtGenomeIds = [];
      if (searchTerms != null) {
        results = this._runFilter(searchTerms);
        pubGenomeIds = results["public"];
        pvtGenomeIds = results["private"];
        this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
        if (this.filtered !== 0) {
          ref = this.public_genomes;
          for (i in ref) {
            g = ref[i];
            g.visible = false;
          }
          ref1 = this.private_genomes;
          for (i in ref1) {
            g = ref1[i];
            g.visible = false;
          }
          for (q = 0, len = pubGenomeIds.length; q < len; q++) {
            g = pubGenomeIds[q];
            this.public_genomes[g].visible = true;
          }
          for (s = 0, len1 = pvtGenomeIds.length; s < len1; s++) {
            g = pvtGenomeIds[s];
            this.private_genomes[g].visible = true;
          }
          this.pubVisible = pubGenomeIds.sort((function(_this) {
            return function(a, b) {
              return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
            };
          })(this));
          this.pvtVisible = pvtGenomeIds.sort((function(_this) {
            return function(a, b) {
              return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
            };
          })(this));
        }
      } else {
        pubGenomeIds = Object.keys(this.public_genomes);
        pvtGenomeIds = Object.keys(this.private_genomes);
        this.filtered = 0;
        ref2 = this.public_genomes;
        for (i in ref2) {
          g = ref2[i];
          g.visible = true;
        }
        ref3 = this.private_genomes;
        for (i in ref3) {
          g = ref3[i];
          g.visible = true;
        }
        this.pubVisible = pubGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
          };
        })(this));
        this.pvtVisible = pvtGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
          };
        })(this));
      }
      this.genomeSetId++;
      return true;
    };

    GenomeController.prototype.countMeta = function(genome, count) {
      var a, len, q;
      count = {};
      for (q = 0, len = mtypesDisplayed.length; q < len; q++) {
        a = mtypesDisplayed[q];
        count[a] = {};
      }
      if (count['serotype'][genome.serotype] != null) {
        count['serotype'][genome.serotype]++;
      } else {
        count['serotype'][genome.serotype] = 1;
      }
      if (count['isolation_host'][genome.isolation_host] != null) {
        count['isolation_host'][genome.isolation_host]++;
      } else {
        count['isolation_host'][genome.isolation_host] = 1;
      }
      if (count['isolation_source'][genome.isolation_source] != null) {
        count['isolation_source'][genome.isolation_source]++;
      } else {
        count['isolation_source'][genome.isolation_source] = 1;
      }
      if (count['isolation_date'][genome.isolation_date] != null) {
        count['isolation_date'][genome.isolation_date]++;
      } else {
        count['isolation_date'][genome.isolation_date] = 1;
      }
      if (count['syndrome'][genome.syndrome] != null) {
        count['syndrome'][genome.syndrome]++;
      } else {
        count['syndrome'][genome.syndrome] = 1;
      }
      if (count['stx1_subtype'][genome.stx1_subtype] != null) {
        count['stx1_subtype'][genome.stx1_subtype]++;
      } else {
        count['stx1_subtype'][genome.stx1_subtype] = 1;
      }
      if (count['stx2_subtype'][genome.stx2_subtype] != null) {
        count['stx2_subtype'][genome.stx2_subtype]++;
      } else {
        count['stx2_subtype'][genome.stx2_subtype] = 1;
      }
      return count;
    };

    GenomeController.prototype.filterBySelection = function() {
      var g, gset, i, len, len1, pubGenomeIds, pvtGenomeIds, q, ref, ref1, s;
      gset = this.selected();
      pubGenomeIds = gset["public"];
      pvtGenomeIds = gset["private"];
      this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
      if (this.filtered === 0) {
        this.filter();
      } else {
        ref = this.public_genomes;
        for (i in ref) {
          g = ref[i];
          g.visible = false;
        }
        ref1 = this.private_genomes;
        for (i in ref1) {
          g = ref1[i];
          g.visible = false;
        }
        for (q = 0, len = pubGenomeIds.length; q < len; q++) {
          g = pubGenomeIds[q];
          this.public_genomes[g].visible = true;
        }
        for (s = 0, len1 = pvtGenomeIds.length; s < len1; s++) {
          g = pvtGenomeIds[s];
          this.private_genomes[g].visible = true;
        }
        this.pubVisible = pubGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
          };
        })(this));
        this.pvtVisible = pvtGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
          };
        })(this));
        viewController.viewAction(1, 'reset_window');
      }
      return true;
    };

    GenomeController.prototype._runFilter = function(searchTerms) {
      var firstTerm, id, len, pubGenomeIds, pubSet, pvtGenomeIds, pvtSet, q, regex, t;
      if (!typeIsArray(searchTerms)) {
        throw new SuperphyError('Invalid argument. GenomeController method _runFilter() requires array of search term objects as input.');
      }
      pubGenomeIds = Object.keys(this.public_genomes);
      pvtGenomeIds = Object.keys(this.private_genomes);
      firstTerm = true;
      for (q = 0, len = searchTerms.length; q < len; q++) {
        t = searchTerms[q];
        if (firstTerm) {
          if (t.op != null) {
            throw new SuperphyError("Invalid filter input. First search term object cannot contain an operator property 'op'.");
          }
          if (t.dataField !== 'isolation_date') {
            if (t.searchTerm == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'searchTerm' property.");
            }
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'dataField' property.");
            }
            if (t.negate == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'negate' property.");
            }
          } else {
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'searchTerm' property.");
            }
            if (t.date == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'date' property.");
            }
            if (t.before == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'before' property.");
            }
          }
          firstTerm = false;
        } else {
          if (t.op == null) {
            throw new SuperphyError("Invalid filter input. Subsequent search term objects must contain an operator property 'op'.");
          }
        }
        if ((t.op != null) && t.op === 'or') {
          pubSet = [];
          pubSet = [];
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var len1, ref, results1, s;
              ref = Object.keys(this.public_genomes);
              results1 = [];
              for (s = 0, len1 = ref.length; s < len1; s++) {
                id = ref[s];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  results1.push(id);
                }
              }
              return results1;
            }).call(this);
            pvtSet = (function() {
              var len1, ref, results1, s;
              ref = Object.keys(this.private_genomes);
              results1 = [];
              for (s = 0, len1 = ref.length; s < len1; s++) {
                id = ref[s];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  results1.push(id);
                }
              }
              return results1;
            }).call(this);
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var len1, ref, results1, s;
              ref = Object.keys(this.public_genomes);
              results1 = [];
              for (s = 0, len1 = ref.length; s < len1; s++) {
                id = ref[s];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  results1.push(id);
                }
              }
              return results1;
            }).call(this);
            pvtSet = (function() {
              var len1, ref, results1, s;
              ref = Object.keys(this.private_genomes);
              results1 = [];
              for (s = 0, len1 = ref.length; s < len1; s++) {
                id = ref[s];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  results1.push(id);
                }
              }
              return results1;
            }).call(this);
          }
          pubGenomeIds = this.union(pubGenomeIds, pubSet);
          pvtGenomeIds = this.union(pvtGenomeIds, pvtSet);
        } else {
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var len1, results1, s;
              results1 = [];
              for (s = 0, len1 = pubGenomeIds.length; s < len1; s++) {
                id = pubGenomeIds[s];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  results1.push(id);
                }
              }
              return results1;
            }).call(this);
            pvtSet = (function() {
              var len1, results1, s;
              results1 = [];
              for (s = 0, len1 = pvtGenomeIds.length; s < len1; s++) {
                id = pvtGenomeIds[s];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  results1.push(id);
                }
              }
              return results1;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var len1, results1, s;
              results1 = [];
              for (s = 0, len1 = pubGenomeIds.length; s < len1; s++) {
                id = pubGenomeIds[s];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  results1.push(id);
                }
              }
              return results1;
            }).call(this);
            pvtSet = (function() {
              var len1, results1, s;
              results1 = [];
              for (s = 0, len1 = pvtGenomeIds.length; s < len1; s++) {
                id = pvtGenomeIds[s];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  results1.push(id);
                }
              }
              return results1;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          }
        }
      }
      return {
        "public": pubGenomeIds,
        "private": pvtGenomeIds
      };
    };

    GenomeController.prototype.match = function(genome, key, regex, negate) {
      var val;
      if (genome[key] == null) {
        return false;
      }
      val = genome[key];
      if (typeIsArray(genome[key])) {
        val = genome[key].toString();
      }
      if (regex.test(val)) {
        if (!negate) {
          return true;
        } else {
          return false;
        }
      } else {
        if (negate) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.passDate = function(genome, before, date) {
      var d2, val;
      if (genome['isolation_date'] == null) {
        return false;
      }
      val = genome['isolation_date'][0];
      d2 = Date.parse(val);
      if (before) {
        if (d2 < date) {
          return true;
        } else {
          return false;
        }
      } else {
        if (d2 > date) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.union = function(arr1, arr2) {
      var arr, i, len, q, ref;
      arr = [];
      ref = arr1.concat(arr2);
      for (q = 0, len = ref.length; q < len; q++) {
        i = ref[q];
        if (indexOf.call(arr, i) < 0) {
          arr.push(i);
        }
      }
      return arr;
    };

    GenomeController.prototype.label = function(genome, visibleMeta, joinStr) {
      var lab, len, na, q, ref, ref1, ref2, t;
      na = 'NA';
      lab = [genome.displayname];
      ref = this.mtypes;
      for (q = 0, len = ref.length; q < len; q++) {
        t = ref[q];
        if (t !== 'accession') {
          if (visibleMeta[t]) {
            lab.push(((ref1 = genome[t]) != null ? ref1 : [na]).join(' '));
          }
        }
      }
      if (visibleMeta.accession) {
        lab.push((ref2 = genome.primary_dbxref) != null ? ref2 : na);
      }
      if (joinStr != null) {
        return lab.join(joinStr);
      } else {
        return lab;
      }
    };

    GenomeController.prototype.updateMeta = function(option, checked) {
      this.meta_option = option;
      if (this.visibleMeta[option] == null) {
        throw new SuperphyError('unrecognized option in GenomeController method updateMeta()');
        return false;
      }
      if (!(checked === true || checked === false)) {
        throw new SuperphyError('invalid checked argument in GenomeController method updateMeta()');
        return false;
      }
      this.visibleMeta[option] = checked;
      this.update();
      return true;
    };

    GenomeController.prototype.select = function(g, checked) {
      if (this.publicRegexp.test(g)) {
        this.public_genomes[g].isSelected = checked;
      } else {
        this.private_genomes[g].isSelected = checked;
      }
      return true;
    };

    GenomeController.prototype.selected = function() {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var ref, results1;
        ref = this.public_genomes;
        results1 = [];
        for (k in ref) {
          v = ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            results1.push(k);
          }
        }
        return results1;
      }).call(this);
      pvt = (function() {
        var ref, results1;
        ref = this.private_genomes;
        results1 = [];
        for (k in ref) {
          v = ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            results1.push(k);
          }
        }
        return results1;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.unselectAll = function() {
      var k, ref, ref1, results1, v;
      ref = this.public_genomes;
      for (k in ref) {
        v = ref[k];
        if (v.isSelected != null) {
          v.isSelected = false;
        }
      }
      ref1 = this.private_genomes;
      results1 = [];
      for (k in ref1) {
        v = ref1[k];
        if (v.isSelected != null) {
          results1.push(v.isSelected = false);
        } else {
          results1.push(void 0);
        }
      }
      return results1;
    };

    GenomeController.prototype.assignGroup = function(gset, grpNum) {
      var cls, g, len, len1, q, ref, ref1, s;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        ref = gset["public"];
        for (q = 0, len = ref.length; q < len; q++) {
          g = ref[q];
          this.public_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.public_genomes[g].cssClass = cls;
        }
      }
      if ((gset["private"] != null) && typeof gset["private"] !== 'undefined') {
        ref1 = gset["private"];
        for (s = 0, len1 = ref1.length; s < len1; s++) {
          g = ref1[s];
          this.private_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.private_genomes[g].cssClass = cls;
        }
      }
      return true;
    };

    GenomeController.prototype.deleteGroup = function(gset) {
      var g, len, len1, q, ref, ref1, s;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        ref = gset["public"];
        for (q = 0, len = ref.length; q < len; q++) {
          g = ref[q];
          this.public_genomes[g].assignedGroup = null;
          this.public_genomes[g].cssClass = null;
        }
      }
      if ((gset["private"] != null) && typeof gset["public"] !== 'undefined') {
        ref1 = gset["private"];
        for (s = 0, len1 = ref1.length; s < len1; s++) {
          g = ref1[s];
          this.private_genomes[g].assignedGroup = null;
          this.private_genomes[g].cssClass = null;
        }
      }
      return true;
    };

    GenomeController.prototype.grouped = function(grpNum) {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var ref, results1;
        ref = this.public_genomes;
        results1 = [];
        for (k in ref) {
          v = ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            results1.push(k);
          }
        }
        return results1;
      }).call(this);
      pvt = (function() {
        var ref, results1;
        ref = this.private_genomes;
        results1 = [];
        for (k in ref) {
          v = ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            results1.push(k);
          }
        }
        return results1;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genomeSet = function(gids) {
      var g, pub, pvt;
      pub = [];
      pvt = [];
      pub = (function() {
        var len, q, results1;
        results1 = [];
        for (q = 0, len = gids.length; q < len; q++) {
          g = gids[q];
          if (this.publicRegexp.test(g)) {
            results1.push(g);
          }
        }
        return results1;
      }).call(this);
      pvt = (function() {
        var len, q, results1;
        results1 = [];
        for (q = 0, len = gids.length; q < len; q++) {
          g = gids[q];
          if (this.privateRegexp.test(g)) {
            results1.push(g);
          }
        }
        return results1;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genome = function(gid) {
      if (this.publicRegexp.test(gid)) {
        return this.public_genomes[gid];
      } else {
        return this.private_genomes[gid];
      }
    };

    GenomeController.prototype.sort = function(gids, metaField, asc) {
      var that;
      if (!gids.length) {
        return gids;
      }
      that = this;
      gids.sort(function(a, b) {
        var aField, aName, aObj, bField, bName, bObj;
        aObj = that.genome(a);
        bObj = that.genome(b);
        aField = aObj[metaField];
        aName = aObj.displayname.toLowerCase();
        bField = bObj[metaField];
        bName = bObj.displayname.toLowerCase();
        if ((aField != null) && (bField != null)) {
          if (typeIsArray(aField)) {
            aField = aField.join('').toLowerCase();
            bField = bField.join('').toLowerCase();
          } else {
            aField = aField.toLowerCase();
            bField = bField.toLowerCase();
          }
          if (aField < bField) {
            return -1;
          } else if (aField > bField) {
            return 1;
          } else {
            if (aName < bName) {
              return -1;
            } else if (aName > bName) {
              return 1;
            } else {
              return 0;
            }
          }
        } else {
          if ((aField != null) && (bField == null)) {
            return -1;
          } else if ((bField != null) && (aField == null)) {
            return 1;
          } else {
            if (aName < bName) {
              return -1;
            } else if (aName > bName) {
              return 1;
            } else {
              return 0;
            }
          }
        }
      });
      if (!asc) {
        gids.reverse();
      }
      return gids;
    };

    GenomeController.prototype.find = function(searchStr) {
      var genomes, id, pubSet, pvtSet, regex;
      regex = new RegExp(escapeRegExp(searchStr), "i");
      pubSet = (function() {
        var len, q, ref, results1;
        ref = this.pubVisible;
        results1 = [];
        for (q = 0, len = ref.length; q < len; q++) {
          id = ref[q];
          if (this.match(this.public_genomes[id], 'displayname', regex, false)) {
            results1.push(id);
          }
        }
        return results1;
      }).call(this);
      pvtSet = (function() {
        var len, q, ref, results1;
        ref = this.pvtVisible;
        results1 = [];
        for (q = 0, len = ref.length; q < len; q++) {
          id = ref[q];
          if (this.match(this.private_genomes[id], 'displayname', regex, false)) {
            results1.push(id);
          }
        }
        return results1;
      }).call(this);
      genomes = pubSet.concat(pvtSet);
      console.log(genomes);
      return genomes;
    };

    return GenomeController;

  })();


  /*
   CLASS LocusController
   
   Manages Locus/Gene allele data
   */

  LocusController = (function() {
    function LocusController(locusData) {
      this.locusData = locusData;
    }

    LocusController.prototype.emptyString = "<span class='locus_group0'>No alleles detected</span>";

    LocusController.prototype.zeroString = "<span class='locus_group0'>0</span>";

    LocusController.prototype.locusString = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str = '';
      if (l.copy > 1) {
        str = " (" + l.copy + " copy)";
      }
      return str;
    };

    LocusController.prototype.locusNode = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str;
      if (l.copy > 1) {
        str = " (" + l.copy + " copy)";
      } else {
        str = '';
      }
      return [str, null];
    };

    LocusController.prototype.genomeString = function(genomeID) {
      var g, str;
      str = ' - ';
      g = this.locusData[genomeID];
      if ((g != null) && g.num_copies > 0) {
        str += "<span class='locus_group1'>" + g.num_copies + " allele(s)</span>";
      } else {
        str += this.emptyString;
      }
      return str;
    };

    LocusController.prototype.countString = function(genomeID) {
      var g, str;
      str = '';
      g = this.locusData[genomeID];
      if ((g != null) && g.num_copies > 0) {
        str = "<span class='locus_group1'>" + g.num_copies + "</span>";
      } else {
        str = this.zeroString;
      }
      return str;
    };

    LocusController.prototype.count = function(genomes) {
      var counts_list;
      counts_list = [];
      this._count(genomes.pubVisible, counts_list);
      this._count(genomes.pvtVisible, counts_list);
      return counts_list;
    };

    LocusController.prototype._count = function(genomeList, counts_list) {
      var c, gID, len, q;
      for (q = 0, len = genomeList.length; q < len; q++) {
        gID = genomeList[q];
        c = this.genome_copies(gID);
        counts_list.push(c);
      }
      return true;
    };

    LocusController.prototype.genome_copies = function(gID) {
      var g;
      g = this.locusData[gID];
      if (g != null) {
        return g.num_copies;
      }
      return 0;
    };

    LocusController.prototype.sort = function(genomeList, asc, genomesC) {
      var that;
      if (!genomeList.length) {
        return genomeList;
      }
      that = this;
      genomeList.sort(function(a, b) {
        var aName, aObj, anum, bName, bObj, bnum;
        anum = that.genome_copies(a);
        bnum = that.genome_copies(b);
        if (anum < bnum) {
          return -1;
        } else if (anum > bnum) {
          return 1;
        } else {
          aObj = genomesC.genome(a);
          bObj = genomesC.genome(b);
          aName = aObj.displayname.toLowerCase();
          bName = bObj.displayname.toLowerCase();
          if (aName < bName) {
            return -1;
          } else if (aName > bName) {
            return 1;
          } else {
            return 0;
          }
        }
      });
      if (!asc) {
        genomeList.reverse();
      }
      return genomeList;
    };

    return LocusController;

  })();

  if (!root.LocusController) {
    root.LocusController = LocusController;
  }


  /*
   CLASS StxController
   
   Manages Stx data
   */

  StxController = (function() {
    function StxController(locusData) {
      this.locusData = locusData;
      this.dataValues = {};
      this.format();
    }

    StxController.prototype.emptyString = "<span class='locus_group0'>NA</span>";

    StxController.prototype.format = function() {
      var dataGroup, g, grpNum, k, o, ref, val;
      for (g in this.locusData) {
        ref = this.locusData[g];
        for (k in ref) {
          o = ref[k];
          val = o.data;
          dataGroup = 0;
          if (this.dataValues[val] != null) {
            dataGroup = this.dataValues[val];
          } else {
            grpNum = Object.keys(this.dataValues).length;
            grpNum++;
            this.dataValues[val] = grpNum;
            dataGroup = grpNum;
          }
          o.cls = "locus_group" + dataGroup;
          o.group = dataGroup;
          o.dataString = "<span class='" + o.cls + "'>" + val + "</span>";
        }
      }
      return true;
    };

    StxController.prototype.locusString = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str;
      if (l.copy > 1) {
        str = " (" + l.copy + " copy) -  " + l.dataString;
      } else {
        str = ' - ' + l.dataString;
      }
      return str;
    };

    StxController.prototype.locusNode = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str;
      if (l.copy > 1) {
        str = " (" + l.copy + " copy) -  " + l.data;
      } else {
        str = ' - ' + l.data;
      }
      return [str, l.group];
    };

    StxController.prototype.genomeString = function(genomeID) {
      var ds, g, k, str, v;
      str = ' - ';
      g = this.locusData[genomeID];
      if (g != null) {
        ds = (function() {
          var results1;
          results1 = [];
          for (k in g) {
            v = g[k];
            results1.push(v.dataString);
          }
          return results1;
        })();
        str += ds.join(',');
      } else {
        str += this.emptyString;
      }
      return str;
    };

    StxController.prototype.count = function(genomes) {
      var uniqueValues;
      uniqueValues = {
        'NA': 0
      };
      this._count(genomes.pubVisible, uniqueValues);
      this._count(genomes.pvtVisible, uniqueValues);
      return uniqueValues;
    };

    StxController.prototype._count = function(genomeList, uniqueValues) {
      var g, gID, k, len, q, results1, v;
      results1 = [];
      for (q = 0, len = genomeList.length; q < len; q++) {
        gID = genomeList[q];
        g = this.locusData[gID];
        if (g != null) {
          results1.push((function() {
            var results2;
            results2 = [];
            for (k in g) {
              v = g[k];
              if (uniqueValues[v.data] != null) {
                results2.push(uniqueValues[v.data]++);
              } else {
                results2.push(uniqueValues[v.data] = 1);
              }
            }
            return results2;
          })());
        } else {
          results1.push(uniqueValues['NA']++);
        }
      }
      return results1;
    };

    return StxController;

  })();

  if (!root.StxController) {
    root.StxController = StxController;
  }


  /*
   CLASS SelectionView
   
   A special type of genome list that is used to temporarily store the user's
   selected genomes.
   
   Only one 'style' which provides a remove button to remove group from group.
   Will be updated by changes to the meta-display options but not by filtering.
   */

  SelectionView = (function() {
    function SelectionView(parentElem, countElem, elNum) {
      this.parentElem = parentElem;
      this.countElem = countElem != null ? countElem : null;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
      this.count = 0;
    }

    SelectionView.prototype.type = 'selected';

    SelectionView.prototype.elNum = 1;

    SelectionView.prototype.elName = 'selected_genomes';

    SelectionView.prototype.elID = void 0;

    SelectionView.prototype.update = function(genomes) {
      var ingrp, listElem;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "' class='selected-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      ingrp = genomes.selected();
      this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
      this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
      this.count = ingrp["public"].length;
      this.count += ingrp["private"].length;
      this._updateCount();
      return true;
    };

    SelectionView.prototype._appendGenomes = function(el, visibleG, genomes) {
      var actionEl, cls, g, len, listEl, q;
      cls = this.cssClass();
      for (q = 0, len = visibleG.length; q < len; q++) {
        g = visibleG[q];
        listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
        actionEl = jQuery("<a href='#' data-genome='" + g + "'> <i class='fa fa-times'></a>");
        actionEl.click(function(e) {
          var gid;
          e.preventDefault();
          gid = this.dataset.genome;
          console.log('clicked unselect on ' + gid);
          viewController.select(gid, false);
          return viewController.views[2].matchSelected($("input[value='" + gid + "']")[0]);
        });
        listEl.append(actionEl);
        el.append(listEl);
      }
      return true;
    };

    SelectionView.prototype.select = function(genomeID, genomes, checked) {
      var gset;
      if (checked) {
        gset = genomes.genomeSet([genomeID]);
        this.add(gset, genomes);
      } else {
        this.remove(genomeID);
      }
      return true;
    };

    SelectionView.prototype.add = function(genomeSet, genomes) {
      var listElem;
      listElem = jQuery("#" + this.elID);
      if (!listElem.length) {
        listElem = jQuery("<ul id='" + this.elID + "' class='selected-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      if (genomeSet["public"] != null) {
        this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
      }
      if (genomeSet["private"] != null) {
        this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
      }
      this.count += genomeSet["public"].length;
      this.count += genomeSet["private"].length;
      return this._updateCount();
    };

    SelectionView.prototype.remove = function(gid) {
      var descriptor, linkEl, listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call SelectionView method remove().");
      }
      descriptor = "li > a[data-genome='" + gid + "']";
      linkEl = listEl.find(descriptor);
      if ((linkEl != null) && linkEl.length) {
        linkEl.parent('li').remove();
        this.count--;
        this._updateCount();
      }
      return true;
    };

    SelectionView.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    SelectionView.prototype._updateCount = function() {
      var innerElem;
      if (this.countElem != null) {
        innerElem = this.countElem.find('span.selected_genome_count_text');
        if (!innerElem.length) {
          innerElem = jQuery("<span class='selected_genome_count_text'></span>").appendTo(this.countElem);
        }
        innerElem.text(this.count + " genomes selected");
      }
      return true;
    };

    return SelectionView;

  })();


  /*
  
    HELPER FUNCTIONS
   */

  parseHeader = function(str) {
    var match;
    match = /^((?:public|private)_\d+)\|(\d+)/.exec(str);
    return match;
  };

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  cmp = function(a, b) {
    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    } else {
      return 0;
    }
  };

  trimInput = function(str, field) {
    var term;
    if (str != null) {
      term = jQuery.trim(str);
      if (term.length) {
        return term;
      } else {
        alert("Error: " + field + " is empty.");
        return null;
      }
    } else {
      alert("Error: " + field + " is empty.");
      return null;
    }
  };

  superphyAlert = function(output_msg, title_msg) {
    if (output_msg == null) {
      output_msg = 'No Message to Display.';
    }
    if (title_msg == null) {
      title_msg = 'Alert';
    }
    return jQuery("<div></div>").html(output_msg).dialog({
      title: title_msg,
      resizable: false,
      modal: true,
      buttons: {
        "Ok": function() {
          return jQuery(this).dialog("close");
        }
      }
    });
  };

  superphyMetaOntology = {
    "syndromes": ["Bacteriuria", "Bloody diarrhea", "Crohn's Disease", "Diarrhea", "Gastroenteritis", "Hemolytic-uremic syndrome", "Hemorrhagic colitis", "Mastitis", "Meningitis", "Peritonitis", "Pneumonia", "Pyelonephritis", "Septicaemia", "Ulcerateive colitis", "Urinary tract infection (cystitis)"],
    "hosts": ["Bos taurus (cow)", "Canis lupus familiaris (dog)", "Environmental source", "Felis catus (cat)", "Gallus gallus (chicken)", "Homo sapiens (human)", "Mus musculus (mouse)", "Oryctolagus cuniculus (rabbit)", "Ovis aries (sheep)", "Sus scrofa (pig)"],
    "sources": ["Blood", "Cecum", "Colon", "Feces", "Ileum", "Intestine", "Liver", "Meat", "Meat-based food", "Stool", "Urine", "Vegetable-based food", "Water", "Yolk", "cerebrospinal_fluid"]
  };


  /*
  
  
   File: superphy_tree.coffee
   Desc: Phylogenetic Tree View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: March 20th, 2013
   */

  d3.selection.prototype.moveToFront = function() {
    return this.each(function() {
      return this.parentNode.appendChild(this);
    });
  };


  /*
   CLASS TreeView
    
   Phylogenetic tree view
   
   Can be genome- or locus-based
   Returns genome ID to redirect/select if leaf node is clicked
   */

  TreeView = (function(superClass) {
    var colours, total_height, visible_bars;

    extend(TreeView, superClass);

    function TreeView(parentElem, style1, elNum, genomes1, treeArgs) {
      var aa, dialog, legendID, len, len1, len2, len3, m, n, num, q, ref, ref1, ref2, ref3, s, totalCount, w;
      this.parentElem = parentElem;
      this.style = style1;
      this.elNum = elNum;
      this.genomes = genomes1;
      if (!(treeArgs.length > 0)) {
        throw new SuperphyError('Missing argument. TreeView constructor requires JSON tree object.');
      }
      this.root = this.trueRoot = treeArgs[0];
      this.currentGenomeSet = -1;
      this.dim = {
        w: 700,
        h: 800
      };
      this.margin = {
        top: 20,
        right: 180,
        bottom: 20,
        left: 20
      };
      if (treeArgs[1] != null) {
        this.locusData = treeArgs[1];
      }
      if (treeArgs[2] != null) {
        this.dim = treeArgs[2];
      }
      if (treeArgs[3] != null) {
        this.margin = treeArgs[3];
      }
      TreeView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.width = this.dim.w - this.margin.right - this.margin.left;
      this.height = this.dim.h - this.margin.top - this.margin.bottom;
      this.xzoom = d3.scale.linear().domain([0, this.width]).range([0, this.width]);
      this.yzoom = d3.scale.linear().domain([0, this.height]).range([0, this.height]);
      this.leafCounter = 0;
      this.cluster = d3.layout.cluster().size([this.width, this.height]).sort(null).value(function(d) {
        return Number(d.length);
      }).separation((function(_this) {
        return function(a, b) {
          var a_height, b_height;
          _this.leafCounter += 1;
          a_height = 1;
          b_height = 1;
          if ((a._children != null) && visible_bars > 1) {
            a_height = visible_bars;
          } else {
            a_height = 2;
          }
          if ((b._children != null) && visible_bars > 1) {
            b_height = visible_bars;
          } else {
            b_height = 2;
          }
          return a_height + b_height;
        };
      })(this));
      legendID = "tree_legend" + this.elNum;
      this._treeOps(this.parentElem, legendID);
      jQuery("<div id='" + this.elID + "' class='" + (this.cssClass()) + "'></div>").appendTo(this.parentElem);
      this.wrap = d3.select("#" + this.elID).append("svg").attr("width", this.dim.w).attr("height", this.dim.h).style("-webkit-backface-visibility", "hidden");
      this.scalePos = {
        x: 10,
        y: 10
      };
      this.scaleBar = this.wrap.append("g").attr("transform", "translate(" + this.scalePos.x + "," + this.scalePos.y + ")").attr("class", "scalebar");
      this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      this.windowX = this.margin.top;
      this.windowY = this.margin.left;
      num = this.elNum - 1;
      this.zoom = d3.behavior.zoom().x(this.xzoom).y(this.yzoom).scaleExtent([1, 8]).on("zoom", function() {
        return viewController.getView(num).zoomed();
      });
      this.wrap.call(this.zoom);
      this.scaleBar.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 1).attr('y2', 0);
      this.scaleBar.append('text').attr("dx", "0").attr("dy", "1em").attr("text-anchor", "start");
      jQuery("<div id='" + legendID + "' class='genome_tree_legend'></div>").appendTo(this.parentElem);
      this.wrap2 = d3.select("#" + legendID).append("svg").attr("width", this.dim.w).attr("height", 120).style("-webkit-backface-visibility", "hidden");
      this.legend = this.wrap2.append("g").attr("transform", "translate(" + 5 + "," + 5 + ")");
      this._legend(this.legend);
      if (this.style === 'select') {
        dialog = jQuery('#dialog-clade-select');
        if (!dialog.length) {
          dialog = jQuery('<div id="dialog-clade-select"></div>').appendTo('body');
          dialog.text("Select/unselect genomes in clade:").dialog({
            dialogClass: 'noTitleStuff',
            autoOpen: false,
            resizable: false,
            height: 120,
            modal: true,
            buttons: {
              Select: function() {
                var node, summary;
                node = jQuery(this).data("clade-node");
                viewController.getView(num).selectClade(node, true);
                if (viewController.views[2].constructor.name === 'SummaryView') {
                  summary = viewController.views[2];
                  summary.afterSelect(true);
                }
                return jQuery(this).dialog("close");
              },
              Unselect: function() {
                var node, summary;
                node = jQuery(this).data("clade-node");
                viewController.getView(num).selectClade(node, false);
                if (viewController.views[2].constructor.name === 'SummaryView') {
                  summary = viewController.views[2];
                  summary.afterSelect(false);
                }
                return jQuery(this).dialog("close");
              },
              Cancel: function() {
                return jQuery(this).dialog("close");
              }
            }
          });
        }
      }
      this.mtypesDisplayed = ['serotype', 'isolation_host', 'isolation_source', 'syndrome', 'stx1_subtype', 'stx2_subtype'];
      totalCount = {};
      ref = this.mtypesDisplayed;
      for (q = 0, len = ref.length; q < len; q++) {
        m = ref[q];
        totalCount[m] = {};
      }
      this.allGenomes = (Object.keys(this.genomes.public_genomes)).concat(Object.keys(this.genomes.private_genomes));
      this.countMeta(totalCount, this.allGenomes);
      this.metaOntology = {};
      this.tt_mtitle = {};
      ref1 = this.mtypesDisplayed;
      for (s = 0, len1 = ref1.length; s < len1; s++) {
        m = ref1[s];
        this.metaOntology[m] = [];
        this.tt_mtitle[m] = new String();
        this.metaOntology[m] = Object.keys(totalCount[m]).sort(function(a, b) {
          return totalCount[m][b] - totalCount[m][a];
        });
        if (m === "isolation_host" || m === "isolation_source") {
          this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
          this.tt_mtitle[m] = this.tt_mtitle[m].replace("_", " ");
          this.tt_mtitle[m] = this.tt_mtitle[m].slice(0, 10) + this.tt_mtitle[m].charAt(10).toUpperCase() + this.tt_mtitle[m].slice(11);
        }
        if (m === "syndrome") {
          this.tt_mtitle[m] = "Symptoms/Diseases";
        }
        if (m === "stx1_subtype" || m === "stx2_subtype") {
          this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
          this.tt_mtitle[m] = this.tt_mtitle[m].replace("_", " ");
          this.tt_mtitle[m] = this.tt_mtitle[m].slice(0, 5) + this.tt_mtitle[m].charAt(5).toUpperCase() + this.tt_mtitle[m].slice(6);
        }
        if (m === "serotype") {
          this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
        }
      }
      this.nodes = this.cluster.nodes(this.root);
      ref2 = this.nodes;
      for (w = 0, len2 = ref2.length; w < len2; w++) {
        n = ref2[w];
        n.tt_table_last = new String();
        n.tt_table = {};
        n.tt_table_partial = {};
        n.tt_sub_table = {};
        n.other_count = {};
        ref3 = this.mtypesDisplayed;
        for (aa = 0, len3 = ref3.length; aa < len3; aa++) {
          m = ref3[aa];
          n.tt_table_partial[m] = new String();
          n.tt_sub_table[m] = new String();
          n.tt_table[m] = new String();
          n.other_count[m] = 0;
        }
      }
      this._prepTree();
      true;
    }

    TreeView.prototype.activeGroup = [];

    TreeView.prototype.rectBlock = '';

    TreeView.prototype.type = 'tree';

    TreeView.prototype.elName = 'genome_tree';

    TreeView.prototype.nodeId = 0;

    TreeView.prototype.expandTracker = 0;

    TreeView.prototype.depths = [];

    TreeView.prototype.nonMetaUpdate = false;

    TreeView.prototype.separationChange = true;

    TreeView.prototype.xStretcher = 1;

    TreeView.prototype.xStretch = false;

    TreeView.prototype.yStretcher = 1;

    TreeView.prototype.yStretch = false;

    TreeView.prototype.duration = 1000;

    TreeView.prototype.expandDepth = 9;

    visible_bars = 0;

    total_height = 0;

    TreeView.prototype.levelTracker = 0;

    TreeView.prototype.firstRun = true;

    TreeView.prototype.mtypesSelected = [];

    TreeView.prototype.x_factor = 1.5;

    TreeView.prototype.y_factor = 5000;

    colours = {
      'serotype': ['#236932', '#468554', '#6AA276', '#8DBE98', '#B0DABA', '#D4F7DC', '#e9fbed'],
      'isolation_host': ['#a70209', '#b3262c', '#c04a4f', '#cc6e72', '#d99295', '#e5b6b8', '#f2dadb'],
      'isolation_source': ['#3741ae', '#535cb9', '#7077c5', '#8c92d0', '#a9addc', '#c5c8e7', '#e2e3f3'],
      'syndrome': ['#962ba6', '#a549b2', '#b467bf', '#c385cc', '#d2a4d8', '#e1c2e5', '#f0e0f2'],
      'stx1_subtype': ['#F05C00', '#EF7123', '#EE8746', '#ED9D69', '#ECB28C', '#EBC8AF', '#EADED2'],
      'stx2_subtype': ['#35a6a7', '#51b2b3', '#6ebfc0', '#8bcccc', '#a8d8d9', '#c5e5e5', '#e2f2f2']
    };

    TreeView.prototype.update = function(genomes, sourceNode) {
      var aa, ab, bar_count, centred, cladeSelect, cmdBox, currLeaves, dt, elID, i, iNodes, id, j, leaves, len, len1, len2, len3, len4, linksEnter, m, n, nodesEnter, nodesExit, nodesUpdate, num, oldRoot, q, ref, ref1, ref2, ref3, ref4, s, svgLinks, svgNode, svgNodes, t1, t2, targetLen, unit, w, y, yedge, ypos, yshift;
      if (sourceNode == null) {
        sourceNode = null;
      }
      if (this.firstRun) {
        $('input[value="serotype"]').prop('checked', true);
        $('input[value="isolation_host"]').prop('checked', true);
        $('input[value="isolation_source"]').prop('checked', true);
        if (!(this.mtypesSelected.indexOf('serotype') > -1)) {
          this.mtypesSelected.push('serotype');
        }
        if (!(this.mtypesSelected.indexOf('isolation_host') > -1)) {
          this.mtypesSelected.push('isolation_host');
        }
        if (!(this.mtypesSelected.indexOf('isolation_source') > -1)) {
          this.mtypesSelected.push('isolation_source');
        }
      }
      this.firstRun = false;
      this.leafCounter = 0;
      if (this.mtypesDisplayed.indexOf(genomes.meta_option) > -1) {
        if (this.mtypesSelected.indexOf(genomes.meta_option) > -1) {
          if (!this.nonMetaUpdate) {
            this.mtypesSelected.splice(this.mtypesSelected.indexOf(genomes.meta_option), 1);
          }
        } else {
          if (!this.nonMetaUpdate) {
            if (genomes.meta_option.length !== 0) {
              this.mtypesSelected.push(genomes.meta_option);
            }
          }
        }
      }
      visible_bars = this.mtypesSelected.length;
      t1 = new Date();
      oldRoot = this.root;
      this._sync(genomes);
      this.nodes = this.cluster.nodes(this.root);
      if (sourceNode == null) {
        sourceNode = this.root;
      }
      this.launchPt = {
        x: sourceNode.x,
        y: sourceNode.y,
        x0: sourceNode.x0,
        y0: sourceNode.y0,
        oldX: sourceNode.oldX,
        oldY: sourceNode.oldY
      };
      if (this.reformat) {
        this._scale();
        targetLen = 30;
        unit = targetLen / this.branch_scale_factor_y;
        unit = Math.round(unit * 10000) / 10000;
        this.scaleLength = unit * this.branch_scale_factor_y;
        this.scaleBar.select('line').attr('x1', 0).attr('x2', this.scaleLength).attr('y1', 0).attr('y2', 0);
        this.scaleBar.select('text').text(unit + " branch length units");
        if (this.reset || this.fitToWindow) {
          this.zoom.translate([0, 0]).scale(1);
        }
        this.scaleBar.select("line").attr('transform', 'scale(1,1)');
        this.reformat = false;
      }
      ref = this.nodes;
      for (q = 0, len = ref.length; q < len; q++) {
        n = ref[q];
        n.y = n.sum_length * this.branch_scale_factor_y;
        if (this.separationChange) {
          if (visible_bars <= 1) {
            n.x = n.x * this.branch_scale_factor_x * this.leafCounter / 24;
          }
          if (visible_bars > 1) {
            n.x = n.x * this.branch_scale_factor_x * this.leafCounter / 24 * ((visible_bars * 0.3) + 1);
            n.oldX = n.oldX * this.branch_scale_factor_x * this.leafCounter / 24 * ((visible_bars * 0.3) + 1);
          }
        } else {
          n.x = n.x * this.branch_scale_factor_x;
        }
        if (this.xStretch) {
          n.y = n.y * this.xStretcher;
        }
        if (this.yStretch) {
          n.x = n.x * this.yStretcher;
        }
        n.width = [];
        n.xpos = 0;
      }
      if (this.expansionContraction) {
        yedge = this.width - 30;
        ypos = this.edgeNode.y;
        if (ypos > yedge) {
          yshift = ypos - yedge;
          ref1 = this.nodes;
          for (s = 0, len1 = ref1.length; s < len1; s++) {
            n = ref1[s];
            n.y = n.y - yshift;
            n.oldY = n.oldY - yshift;
          }
        }
        this.expansionContraction = false;
      }
      svgNodes = this.canvas.selectAll("g.treenode").data(this.nodes, function(d) {
        return d.id;
      });
      svgLinks = this.canvas.selectAll("path.treelink").data(this.cluster.links(this.nodes), function(d) {
        return d.target.id;
      });
      linksEnter = svgLinks.enter().insert("path").attr("class", "treelink").attr("d", (function(_this) {
        return function(d) {
          var p;
          p = {
            x: _this.launchPt.x0,
            y: _this.launchPt.y0,
            oldX: _this.launchPt.oldX,
            oldY: _this.launchPt.oldY
          };
          return _this._step({
            source: p,
            target: p
          });
        };
      })(this));
      this.canvas.selectAll("path.treelink").transition().duration(this.duration).attr("d", (function(_this) {
        return function(d) {
          return _this._zTranslate(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      svgLinks.exit().transition().duration(this.duration).attr("d", (function(_this) {
        return function(d) {
          var o;
          o = {
            x: _this.launchPt.x,
            y: _this.launchPt.y,
            oldX: _this.launchPt.oldX,
            oldY: _this.launchPt.oldY
          };
          return _this._step({
            source: o,
            target: o
          });
        };
      })(this)).remove();
      currLeaves = svgNodes.filter(function(d) {
        return d.leaf;
      }).attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).on("click", function(d) {
        var summary;
        if (d.assignedGroup == null) {
          viewController.select(d.genome, !d.selected);
          if (viewController.views[2].constructor.name === 'SummaryView') {
            summary = viewController.views[2];
            return summary.afterSelect(!d.selected);
          }
        } else {
          return null;
        }
      });
      currLeaves.select("circle").style("fill", (function(_this) {
        return function(d) {
          if (d.selected) {
            return "lightsteelblue";
          } else {
            return "#fff";
          }
        };
      })(this));
      svgNodes.select("text").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      });
      svgNodes.filter(function(d) {
        return d.children && !d.leaf;
      }).select("text").transition().duration(this.duration).style("fill-opacity", 1e-6);
      nodesEnter = svgNodes.enter().append("g").attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).attr("id", function(d) {
        return "treenode" + d.id;
      }).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.launchPt.y0 + "," + _this.launchPt.x0 + ")";
        };
      })(this));
      leaves = nodesEnter.filter(function(d) {
        return d.leaf;
      });
      leaves.append("rect").attr('width', 11).attr('height', 11).attr('x', -5.5).attr('y', -5.5).style('opacity', (function(_this) {
        return function(d) {
          if (_this.activeGroup.indexOf(d.name) > -1) {
            return 1;
          } else {
            return 0;
          }
        };
      })(this)).style('fill', (function(_this) {
        return function(d) {
          if (_this.activeGroup.indexOf(d.name) > -1) {
            return 'steelblue';
          } else {
            return '#fff';
          }
        };
      })(this));
      leaves.append("circle").attr("r", 1e-6).style("fill", (function(_this) {
        return function(d) {
          if (d.selected) {
            return "lightsteelblue";
          } else {
            return "#fff";
          }
        };
      })(this));
      if (this.style === 'select') {
        leaves.on("click", function(d) {
          var summary;
          if (d.assignedGroup == null) {
            viewController.select(d.genome, !d.selected);
            if (viewController.views[2].constructor.name === 'SummaryView') {
              summary = viewController.views[2];
              return summary.afterSelect(!d.selected);
            }
          } else {
            return null;
          }
        });
      } else {
        leaves.on("click", function(d) {
          return viewController.redirect(d.genome);
        });
      }
      nodesEnter.append("text").attr("class", "treelabel").attr("x", function(n) {
        if (n._children != null) {
          return 10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5) + 10;
        } else {
          return "0.6em";
        }
      }).attr("dy", ".4em").attr("text-anchor", "start").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      }).style("fill-opacity", 1e-6);
      iNodes = nodesEnter.filter(function(n) {
        return !n.leaf && !n.root;
      });
      num = this.elNum - 1;
      svgNodes.select('g').remove();
      svgNodes.select('rect.genomeMeter').remove();
      this.rectBlock = svgNodes.append('g');
      svgNodes.append('rect').style("fill", "red").style("stroke-width", 0.5).style("stroke", "black").attr("class", "genomeMeter").attr("width", function(n) {
        if ((n._children != null) && !($(this).hasClass('genomeMeter'))) {
          return 10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5);
        } else {
          return 0;
        }
      }).attr("height", 7).attr("y", -3).attr("x", 4);
      $(document).ready(function() {
        return $('input[name="meta-option"]').each(function(obj) {
          $('#' + this.name + '_' + this.value).hide();
          if (this.checked) {
            return $('#' + this.name + '_' + this.value).show();
          }
        });
      });
      ref2 = this.mtypesSelected;
      for (w = 0, len2 = ref2.length; w < len2; w++) {
        m = ref2[w];
        this.updatePopovers(m);
      }
      y = -5;
      centred = -1.5;
      ref3 = this.mtypesDisplayed;
      for (aa = 0, len3 = ref3.length; aa < len3; aa++) {
        m = ref3[aa];
        if (genomes.visibleMeta[m]) {
          j = 0;
          i = 0;
          y += 7;
          centred += -3.5;
          if (this.metaOntology[m].length < 7) {
            bar_count = this.metaOntology[m].length;
          } else {
            bar_count = 7;
          }
          while (i < bar_count) {
            this.rectBlock.append("rect").style("fill", colours[m][j++]).style("stroke-width", 0.5).style("stroke", "black").attr("class", function(n) {
              if (n._children != null) {
                return "metaMeter";
              }
            }).attr("id", (function(_this) {
              return function(n) {
                if (n._children != null) {
                  if (i === 6) {
                    return "Other";
                  } else {
                    return _this.metaOntology[m][i];
                  }
                }
              };
            })(this)).attr("width", (function(_this) {
              return function(n) {
                if (n._children != null) {
                  if ((n.metaCount[m][_this.metaOntology[m][i]] != null) && i < 6 && (_this.metaOntology[m][i] != null)) {
                    n.width[i] = (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)) * n.metaCount[m][_this.metaOntology[m][i]] / n.num_leaves;
                  } else if (i === 6 && (_this.metaOntology[m][i] != null)) {
                    n.width[i] = (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)) - (n.width[0] + n.width[1] + n.width[2] + n.width[3] + n.width[4] + n.width[5]);
                  } else {
                    n.width[i] = 0;
                  }
                }
                if (n.width[i] > 0) {
                  return n.width[i];
                }
              };
            })(this)).attr("height", function(n) {
              if (n._children != null) {
                return 7;
              }
            }).attr("y", function(n) {
              if (n._children != null) {
                return y;
              }
            }).attr("x", function(n) {
              if (n._children != null) {
                if ((n.width[i - 1] != null) && i > 0) {
                  n.xpos += n.width[i - 1];
                } else {
                  n.xpos = 0;
                }
              }
              return n.xpos + 4;
            }).attr("data-toggle", function(n) {
              if (n._children != null) {
                return "popover";
              }
            }).attr("data-content", (function(_this) {
              return function(n) {
                var length, pos, tt_data;
                if (n._children != null) {
                  length = 0;
                  pos = 0;
                  if (_this.metaOntology[m][i] != null) {
                    pos = n.tt_table[m].indexOf(_this.metaOntology[m][i].charAt(0).toUpperCase() + _this.metaOntology[m][i].slice(1));
                  }
                  if (n.metaCount[m][_this.metaOntology[m][i]] > 0) {
                    length = (_this.metaOntology[m][i] + "</td><td style='text-align:right'>" + n.metaCount[m][_this.metaOntology[m][i]]).length;
                    tt_data = n.tt_table[m].slice(0, pos - 8) + "<tr class='table-row-bold' style='color:" + colours[m][3] + "'><td>" + n.tt_table[m].slice(pos, length + pos) + "</td></tr>" + n.tt_table[m].slice(length + pos);
                  }
                  if (i === 6) {
                    if (n.width[i - 1] === 0) {
                      if (n.tt_table[m].indexOf("[+] Other") != null) {
                        pos = n.tt_table[m].indexOf("[+] Other");
                      } else {
                        pos = n.tt_table[m].indexOf(n.tt_table_last);
                      }
                      tt_data = n.tt_table[m].slice(0, pos - 8) + "<tr class='table-row-bold' style='color:" + colours[m][3] + "'><td>" + n.tt_table[m].slice(pos);
                    } else {
                      tt_data = n.tt_table[m].slice(0, n.tt_table[m].indexOf("[+] Other") - 8) + "<tr class='table-row-bold' style='color:" + colours[m][3] + "'><td>" + n.tt_table[m].slice(n.tt_table[m].indexOf("[+] Other"));
                    }
                  }
                }
                if (n.width[i] > 0) {
                  return "<table class='popover-table'><tr><th style='min-width:160px;max-width:160px;text-align:left'>" + _this.tt_mtitle[m] + "</th><th style='min-width:110px;max-width:110px;text-align:right'># of Genomes</th></tr>" + tt_data + "</table>";
                }
              };
            })(this));
            i++;
          }
        }
      }
      (function($) {
        var oldHide;
        oldHide = $.fn.popover.Constructor.prototype.hide;
        $.fn.popover.Constructor.prototype.hide = function() {
          var that;
          if (this.options.trigger === 'hover' && this.tip().is(':hover')) {
            that = this;
            setTimeout((function() {
              return that.hide.call(that, arguments);
            }), that.options.delay.hide);
            return;
          }
          oldHide.call(this, arguments);
        };
      })(jQuery);
      this.rectBlock.selectAll('.metaMeter').each(function() {
        return $(this).popover({
          placement: 'bottom',
          html: 'true',
          trigger: 'hover',
          delay: {
            show: 500,
            hide: 500
          },
          animate: 'false',
          container: 'body'
        });
      });
      $('body').on('click', function(e) {
        if ($(e.target).data('toggle') !== 'popover' && $(e.target).parents('.popover.in').length === 0) {
          return $('[data-toggle="popover"]').popover('hide');
        }
      });
      if ($('#treenode:has(g.v' + visible_bars + ')')) {
        svgNodes.select('.v' + visible_bars).remove();
      }
      if (visible_bars > 0) {
        this.rectBlock.attr("class", 'v' + visible_bars);
      }
      if (visible_bars > 0) {
        if (($('.v' + (visible_bars - 1))[0])) {
          svgNodes.select('.v' + (visible_bars - 1)).remove();
        }
        if (($('.v' + (visible_bars + 1))[0])) {
          svgNodes.select('.v' + (visible_bars + 1)).remove();
        }
        svgNodes.selectAll('.v0').remove();
      } else {
        svgNodes.selectAll('.v1').remove();
      }
      if (visible_bars > 0) {
        svgNodes.selectAll('.genomeMeter').remove();
      }
      cmdBox = iNodes.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 4).attr("x", -8).text(function(d) {
        return "\uf0fe";
      });
      cmdBox.on("click", function(d) {
        return viewController.viewAction(num, 'expand_collapse', d, this.parentNode);
      });
      if (this.style === 'select') {
        cladeSelect = iNodes.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -25);
        cladeSelect.on("click", function(d) {
          return jQuery('#dialog-clade-select').data('clade-node', d).dialog('open');
        });
      }
      nodesUpdate = svgNodes.transition().duration(this.duration).attr("transform", (function(_this) {
        return function(d) {
          if (!isNaN(d.oldX) && !isNaN(d.oldY)) {
            return "translate(" + d.oldY + "," + d.oldX + ")";
          } else if ((_this.launchPt.oldX != null) && (_this.launchPt.oldY != null)) {
            return "translate(" + (_this.launchPt.oldY + (d.y - _this.launchPt.y0)) + "," + (_this.launchPt.oldX + (d.x - _this.launchPt.x0)) + ")";
          } else {
            return "translate(" + d.y + "," + d.x + ")";
          }
        };
      })(this));
      nodesUpdate.select("circle").attr("r", 4);
      nodesUpdate.selectAll("rect.genomeMeter").attr("width", function(n) {
        if (n._children != null) {
          return 10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5);
        } else {
          return 0;
        }
      });
      nodesUpdate.selectAll(".treelabel").attr("x", function(n) {
        if (n._children != null) {
          return 10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5) + 10;
        } else {
          return "0.6em";
        }
      }).attr("dy", ".4em").attr("text-anchor", "start").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      }).style("fill-opacity", 1e-6);
      m = 1;
      while (m < visible_bars + 1) {
        svgNodes.selectAll('.v' + m).attr("transform", "translate(" + 0 + "," + centred + ")");
        m++;
      }
      nodesUpdate.filter(function(d) {
        return !d.children;
      }).select("text").style("fill-opacity", 1);
      nodesUpdate.select(".expandcollapse").text(function(d) {
        if (d._children != null) {
          return "\uf0fe";
        } else {
          return "\uf146";
        }
      });
      this.canvas.selectAll("g.treenode").transition().duration(this.duration).attr("transform", (function(_this) {
        return function(d) {
          return _this._zTransform(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      nodesExit = svgNodes.exit().transition().duration(this.duration).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.launchPt.y + "," + _this.launchPt.x + ")";
        };
      })(this)).remove();
      nodesExit.select("circle").attr("r", 1e-6);
      nodesExit.select("text").style("fill-opacity", 1e-6);
      nodesExit.select("rect").attr("width", 1e-6).attr("height", 1e-6);
      if (!oldRoot.root && this.root !== oldRoot) {
        id = oldRoot.id;
        elID = "treenode" + id;
        svgNode = this.canvas.select("#" + elID);
        svgNode.moveToFront();
      }
      ref4 = this.nodes;
      for (ab = 0, len4 = ref4.length; ab < len4; ab++) {
        n = ref4[ab];
        n.x0 = n.x;
        n.y0 = n.y;
      }
      t2 = new Date();
      dt = new Date(t2 - t1);
      console.log('TreeView update elapsed time (sec): ' + dt.getSeconds());
      this.nonMetaUpdate = false;
      this.expandCollapse = false;
      this.reset = false;
      this.fitToWindow = false;
      return true;
    };

    TreeView.prototype.findGroupedChildren = function(groupList) {
      var g, groupedNodes, len, n, q;
      groupedNodes = [];
      for (q = 0, len = groupList.length; q < len; q++) {
        g = groupList[q];
        n = this._findLeaf(g);
        groupedNodes.push(n);
      }
      return groupedNodes;
    };

    TreeView.prototype.resetInternalNodes = function(node) {
      if (node == null) {
        return true;
      }
      node.num_selected = 0;
      node.internal_node_selected = 0;
      this.resetInternalNodes(node.parent);
      return true;
    };

    TreeView.prototype.updateActiveGroup = function(usrGrp) {
      var g, groupedNodes, leafNodes, len, len1, n, q, ref, s, svgNodes;
      this.groupInstance = true;
      this.activeGroup = usrGrp.active_group.public_list.concat(usrGrp.active_group.private_list);
      svgNodes = this.canvas.selectAll("g.treenode");
      leafNodes = svgNodes.filter(function(d) {
        return d.leaf;
      });
      ref = this.allGenomes;
      for (q = 0, len = ref.length; q < len; q++) {
        g = ref[q];
        n = this._findLeaf(g);
        this.resetInternalNodes(n);
        if (this.activeGroup.indexOf(g) > -1) {
          n.activeGroup = true;
          n.selected = true;
        } else {
          n.activeGroup = false;
          n.selected = false;
        }
      }
      groupedNodes = this.findGroupedChildren(this.activeGroup);
      for (s = 0, len1 = groupedNodes.length; s < len1; s++) {
        g = groupedNodes[s];
        this._percolateSelected(g.parent, true);
      }
      svgNodes.attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this));
      leafNodes.select("rect").attr('width', 11).attr('height', 11).attr('x', -5.5).attr('y', -5.5).style('stroke', '#fff').style('opacity', (function(_this) {
        return function(d) {
          if (d.activeGroup) {
            return 1;
          } else {
            return 0;
          }
        };
      })(this)).style('fill', (function(_this) {
        return function(d) {
          if (d.activeGroup) {
            return 'steelblue';
          } else {
            return '#fff';
          }
        };
      })(this));
      svgNodes.select("circle").style("fill", (function(_this) {
        return function(d) {
          if (d.selected) {
            return "lightsteelblue";
          } else {
            return "#fff";
          }
        };
      })(this));
      return true;
    };

    TreeView.prototype.updatePopovers = function(option) {
      var i;
      if (this.mtypesDisplayed.indexOf(option) > -1) {
        i = 0;
        while (i < this.metaOntology[option].length) {
          this.rectBlock.text((function(_this) {
            return function(n) {
              var other_width, tt_mtype;
              if (n._children != null) {
                if ((n.metaCount[option][_this.metaOntology[option][i]] != null) && i < 6 && (_this.metaOntology[option][i] != null)) {
                  n.width[i] = (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)) * n.metaCount[option][_this.metaOntology[option][i]] / n.num_leaves;
                } else if (i === 6 && (_this.metaOntology[option][i] != null)) {
                  n.width[i] = (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)) - (n.width[0] + n.width[1] + n.width[2] + n.width[3] + n.width[4] + n.width[5]);
                } else {
                  n.width[i] = 0;
                }
                if ((n.metaCount[option][_this.metaOntology[option][i]] != null) && i > 5) {
                  n.other_count[option] += n.metaCount[option][_this.metaOntology[option][i]];
                }
                tt_mtype = _this.metaOntology[option][i].charAt(0).toUpperCase() + _this.metaOntology[option][i].slice(1);
                if (n.metaCount[option][_this.metaOntology[option][i]] > 0) {
                  other_width = Math.round(n.num_leaves * n.width[6] / (10 * (Math.log(n.num_leaves)) + Math.pow(Math.log(n.num_leaves), 2.5)));
                  if (i >= 6) {
                    if (!(n.tt_sub_table[option].indexOf("<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + n.metaCount[option][_this.metaOntology[option][i]] + "</td></tr>") > -1)) {
                      n.tt_sub_table[option] += "<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + n.metaCount[option][_this.metaOntology[option][i]] + "</td></tr>";
                    }
                    if (!(n.tt_table[option].indexOf(n.tt_table_partial[option] + ("<tbody class='other-row' onclick=\"$('.after-other').slideToggle(100);\"><tr><td>[+] Other</td><td style='text-align:right'\">" + other_width + "</td></tr></tbody><tbody class='after-other'>" + n.tt_sub_table[option] + "</tbody>")) > -1)) {
                      n.tt_table[option] = n.tt_table_partial[option] + ("<tbody class='other-row' onclick=\"$('.after-other').slideToggle(100);\"><tr><td>[+] Other</td><td style='text-align:right'\">" + other_width + "</td></tr></tbody><tbody class='after-other'>" + n.tt_sub_table[option] + "</tbody>");
                    }
                  } else {
                    if (!(n.tt_table_partial[option].indexOf("<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + n.metaCount[option][_this.metaOntology[option][i]] + "</td></tr>") > -1)) {
                      n.tt_table_partial[option] += "<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + n.metaCount[option][_this.metaOntology[option][i]] + "</td></tr>";
                    }
                    n.tt_table_last = tt_mtype;
                    n.tt_table[option] = n.tt_table_partial[option];
                  }
                  return n.tt_table_partial[option];
                }
              }
            };
          })(this));
          i++;
        }
      }
      return true;
    };

    TreeView.prototype.countMeta = function(count, countType) {
      var g, genome, len, q;
      for (q = 0, len = countType.length; q < len; q++) {
        g = countType[q];
        genome = this.genomes.genome(g);
        if (count['serotype'][genome.serotype] != null) {
          count['serotype'][genome.serotype] += 1;
        } else {
          count['serotype'][genome.serotype] = 1;
        }
        if (count['isolation_host'][genome.isolation_host] != null) {
          count['isolation_host'][genome.isolation_host] += 1;
        } else {
          count['isolation_host'][genome.isolation_host] = 1;
        }
        if (count['isolation_source'][genome.isolation_source] != null) {
          count['isolation_source'][genome.isolation_source] += 1;
        } else {
          count['isolation_source'][genome.isolation_source] = 1;
        }
        if (count['syndrome'][genome.syndrome] != null) {
          count['syndrome'][genome.syndrome] += 1;
        } else {
          count['syndrome'][genome.syndrome] = 1;
        }
        if (count['stx1_subtype'][genome.stx1_subtype] != null) {
          count['stx1_subtype'][genome.stx1_subtype] += 1;
        } else {
          count['stx1_subtype'][genome.stx1_subtype] = 1;
        }
        if (count['stx2_subtype'][genome.stx2_subtype] != null) {
          count['stx2_subtype'][genome.stx2_subtype] += 1;
        } else {
          count['stx2_subtype'][genome.stx2_subtype] = 1;
        }
      }
      return count;
    };

    TreeView.prototype.intro = function() {
      var treeIntro;
      treeIntro = [];
      treeIntro.push({
        element: document.querySelector('#tree_find_input2'),
        intro: "Use this search bar to search for a specific genome.  The genome will be indicated by a yellow circle on the tree, which shows its phylogenetic relationships with other genomes.",
        position: 'left'
      });
      treeIntro.push({
        element: document.querySelector('#tree-controls'),
        intro: "Use these buttons to have the tree fit within the window, to reset the tree, to expand/collapse one level, and to stretch the tree.",
        position: 'bottom'
      });
      treeIntro.push({
        element: document.querySelector('#genome_tree2'),
        intro: "Genomes can be selected by clicking the blue circles.  Clades can be selected by clicking the red boxes.  Pan by clicking and dragging.  Clicking on the '+' and '-' symbols will expand or collapse each clade.  Use the clickwheel on your mouse to zoom. Single red bars represent the number of genomes in each clade.  Stacked bars represent the proportion of each type of meta-data in the clade.  Further information is displayed by hovering over each segment of the bar.",
        position: 'left'
      });
      treeIntro.push({
        element: document.querySelector('#tree_legend2'),
        intro: "Use this legend to help you.",
        position: 'left'
      });
      return treeIntro;
    };

    TreeView.prototype.updateCSS = function(gset, genomes) {
      var g, genomeList, len, len1, q, ref, ref1, s, svgNodes, updateNodes;
      genomeList = {};
      if (gset["public"] != null) {
        ref = gset["public"];
        for (q = 0, len = ref.length; q < len; q++) {
          g = ref[q];
          genomeList[g] = genomes.public_genomes[g];
        }
      }
      if (gset["private"] != null) {
        ref1 = gset["private"];
        for (s = 0, len1 = ref1.length; s < len1; s++) {
          g = ref1[s];
          genomeList[g] = genomes.private_genomes[g];
        }
      }
      svgNodes = this.canvas.selectAll("g.treenode");
      updateNodes = svgNodes.filter(function(d) {
        return genomeList[d.genome] != null;
      }).attr("class", (function(_this) {
        return function(d) {
          g = genomeList[d.genome];
          d.selected = (g.isSelected != null) && g.isSelected;
          d.assignedGroup = g.assignedGroup;
          return _this._classList(d);
        };
      })(this));
      updateNodes.on("click", function(d) {
        var summary;
        if (d.assignedGroup == null) {
          viewController.select(d.genome, !d.selected);
          if (viewController.views[2].constructor.name === 'SummaryView') {
            summary = viewController.views[2];
            return summary.afterSelect(!d.selected);
          }
        } else {
          return null;
        }
      });
      return true;
    };

    TreeView.prototype.viewAction = function(genomes, argArray) {
      var event;
      event = argArray.shift();
      if (event === 'expand_collapse') {
        this.nonMetaUpdate = true;
        this._expandCollapse(genomes, argArray[0], argArray[1]);
      } else if (event === 'fit_window') {
        this.xStretcher = 1;
        this.yStretcher = 1;
        this.fitToWindow = true;
        this.separationChange = false;
        this.nonMetaUpdate = true;
        this.reformat = true;
        this.update(genomes);
      } else if (event === 'reset_window') {
        this.xStretcher = 1;
        this.yStretcher = 1;
        this.xStretch = false;
        this.yStretch = false;
        this.separationChange = true;
        this.nonMetaUpdate = true;
        this.reset = true;
        this.resetWindow = true;
        this.highlightGenomes(genomes, null);
        this.update(genomes);
      } else if (event === 'expand_tree') {
        this.expandTracker++;
        this.separationChange = true;
        this.nonMetaUpdate = true;
        this.expandTree(genomes);
      } else if (event === 'collapse_tree') {
        this.expandTracker--;
        this.separationChange = true;
        this.nonMetaUpdate = true;
        this.collapseTree(genomes);
      } else if (event === 'xstretch') {
        this.xStretch = true;
        this.xStretcher = this.xStretcher * 2;
        this.nonMetaUpdate = true;
        this.reformat = true;
        this.update(genomes);
      } else if (event === 'ystretch') {
        this.yStretch = true;
        this.yStretcher = this.yStretcher * 1.5;
        this.nonMetaUpdate = true;
        this.reformat = true;
        this.update(genomes);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in TreeView viewAction method.");
      }
      return true;
    };

    TreeView.prototype.selectClade = function(node, checked) {
      var c, len, len1, q, ref, ref1, s, summary;
      if (node.leaf) {
        if (checked) {
          if (!node.selected) {
            viewController.select(node.genome, checked);
            if (viewController.views[2].constructor.name === 'SummaryView') {
              summary = viewController.views[2];
              summary.afterSelect(this.checked);
            }
          }
        } else {
          if (node.selected) {
            viewController.select(node.genome, checked);
            if (viewController.views[2].constructor.name === 'SummaryView') {
              summary = viewController.views[2];
              summary.afterSelect(this.checked);
            }
          }
        }
      } else {
        if (node.children) {
          ref = node.children;
          for (q = 0, len = ref.length; q < len; q++) {
            c = ref[q];
            this.selectClade(c, checked);
          }
        } else if (node._children) {
          ref1 = node._children;
          for (s = 0, len1 = ref1.length; s < len1; s++) {
            c = ref1[s];
            this.selectClade(c, checked);
          }
        }
      }
      return true;
    };

    TreeView.prototype.select = function(genome, isSelected) {
      var d, svgNodes, updateNode;
      if (user_groups_menu.runSelect || !user_groups_menu.groupSelected) {
        d = this._findLeaf(genome);
        svgNodes = this.canvas.selectAll("g.treenode");
        updateNode = svgNodes.filter(function(d) {
          return d.genome === genome;
        });
        if (updateNode) {
          updateNode.attr("class", (function(_this) {
            return function(d) {
              d.selected = isSelected;
              return _this._classList(d);
            };
          })(this));
          updateNode.select("circle").style("fill", (function(_this) {
            return function(d) {
              if (d.selected) {
                return "lightsteelblue";
              } else {
                return "#fff";
              }
            };
          })(this));
          this._percolateSelected(d.parent, isSelected);
          svgNodes.filter(function(d) {
            return !d.leaf;
          }).attr("class", (function(_this) {
            return function(d) {
              return _this._classList(d);
            };
          })(this));
        }
      }
      return true;
    };

    TreeView.prototype._percolateSelected = function(node, checked) {
      if (node == null) {
        return true;
      }
      if (checked) {
        node.num_selected++;
      } else {
        node.num_selected--;
      }
      if (node.num_selected === node.num_leaves) {
        node.internal_node_selected = 2;
      } else if (node.num_selected > 0) {
        node.internal_node_selected = 1;
      } else {
        node.internal_node_selected = 0;
      }
      this._percolateSelected(node.parent, checked);
      return true;
    };

    TreeView.prototype.dump = function(genomes) {
      var output, tokens;
      tokens = [];
      this._printNode(genomes, this.root, tokens);
      output = tokens.join('');
      return {
        ext: 'newick',
        type: 'text/plain',
        data: output
      };
    };

    TreeView.prototype._printNode = function(genomes, node, tokens) {
      var c, children, g, lab, len, q;
      if (node.leaf) {
        g = genomes.genome(node.genome);
        lab = genomes.label(g, genomes.visibleMeta);
        tokens.push("\"" + lab + "\"", ':', node.length);
      } else {
        children = node.children;
        if (node._children != null) {
          children = node._children;
        }
        tokens.push('(');
        for (q = 0, len = children.length; q < len; q++) {
          c = children[q];
          this._printNode(genomes, c, tokens);
          tokens.push(',');
        }
        tokens[tokens.length - 1] = ')';
        tokens.push("\"" + node.name + "\"", ':', node.length);
      }
      return true;
    };

    TreeView.prototype._step = function(d) {
      if (!isNaN(d.source.oldX) && !isNaN(d.source.oldY) && !isNaN(d.target.oldX) && !isNaN(d.target.oldY)) {
        return "M" + d.source.oldY + "," + d.source.oldX + "L" + d.source.oldY + "," + d.target.oldX + "L" + d.target.oldY + "," + d.target.oldX;
      } else {
        return "M" + d.source.y + "," + d.source.x + "L" + d.source.y + "," + d.target.x + "L" + d.target.y + "," + d.target.x;
      }
    };

    TreeView.prototype._prepTree = function() {
      var gPattern;
      this.trueRoot.root = true;
      this.trueRoot.x0 = this.height / 2;
      this.trueRoot.y0 = 0;
      gPattern = /^((?:public_|private_)\d+)\|/;
      this.leaves = [];
      return this._assignKeys(this.trueRoot, 0, gPattern);
    };

    TreeView.prototype._assignKeys = function(n, i, gPattern) {
      var len, len1, m, q, ref, ref1, res, s;
      n.id = i;
      n.storage = n.length * 1;
      i++;
      if (n.children != null) {
        n.num_selected = 0;
        n.daycare = n.children.slice();
        ref = n.children;
        for (q = 0, len = ref.length; q < len; q++) {
          m = ref[q];
          i = this._assignKeys(m, i, gPattern);
        }
      } else if (n._children != null) {
        n.num_selected = 0;
        n.daycare = n._children.slice();
        ref1 = n._children;
        for (s = 0, len1 = ref1.length; s < len1; s++) {
          m = ref1[s];
          i = this._assignKeys(m, i, gPattern);
        }
      }
      if ((n.leaf != null) && n.leaf === "true") {
        if (this.locusData != null) {
          res = gPattern.exec(n.name);
          if (res == null) {
            throw new SuperphyError("Invalid tree node key. Expecting: genome|locus. Recieved: " + n.name);
          }
          n.genome = res[1];
        } else {
          n.genome = n.name;
        }
        this.leaves.push(n);
      }
      return i;
    };

    TreeView.prototype._sync = function(genomes) {
      this.root = this._syncNode(this.trueRoot, genomes, 0);
      if ((genomes.genomeSetId !== this.currentGenomeSet) || this.resetWindow) {
        this._expansionLayout();
        this.currentGenomeSet = genomes.genomeSetId;
        this.resetWindow = false;
        this.reformat = true;
      }
      return true;
    };

    TreeView.prototype._syncNode = function(node, genomes, sumLengths) {
      var c, child, children, g, isExpanded, k, k2, ld, len, q, ref, ref1, ref2, u, v, v2;
      node.length = node.storage * 1;
      node.sum_length = sumLengths + node.length;
      if ((node.leaf != null) && node.leaf === "true") {
        g = genomes.genome(node.genome);
        if ((g != null) && g.visible) {
          node.viewname = g.viewname;
          node.selected = (g.isSelected != null) && g.isSelected;
          node.assignedGroup = g.assignedGroup;
          node.hidden = false;
          node.activeGroup = false;
          if (this.locusData != null) {
            ld = this.locusData.locusNode(node.name);
            node.viewname += ld[0];
            if (ld[1] != null) {
              node.assignedGroup = ld[1];
            }
          }
        } else {
          node.hidden = true;
        }
        if (!((node.metaCount != null) && (g == null))) {
          node.metaCount = genomes.countMeta(g);
        }
      } else {
        isExpanded = true;
        if (node._children != null) {
          isExpanded = false;
        }
        node.metaCount = {};
        children = [];
        ref = node.daycare;
        for (q = 0, len = ref.length; q < len; q++) {
          c = ref[q];
          u = this._syncNode(c, genomes, node.sum_length);
          if (!u.hidden) {
            children.push(u);
            ref1 = u.metaCount;
            for (k in ref1) {
              v = ref1[k];
              if (node.metaCount[k] == null) {
                node.metaCount[k] = {};
              }
              ref2 = u.metaCount[k];
              for (k2 in ref2) {
                v2 = ref2[k2];
                if (node.metaCount[k][k2] != null) {
                  node.metaCount[k][k2] += v2;
                } else {
                  node.metaCount[k][k2] = v2;
                }
              }
            }
          }
        }
        if (children.length === 0) {
          node.hidden = true;
        } else if (children.length === 1) {
          node.hidden = true;
          child = children[0];
          child.length += node.length;
          return child;
        } else {
          node.hidden = false;
          if (isExpanded) {
            node.children = children;
          } else {
            node._children = children;
          }
        }
      }
      return node;
    };

    TreeView.prototype._cloneNode = function(node) {
      var copy, k, v;
      copy = {};
      for (k in node) {
        v = node[k];
        if (!(k === 'children' || k === '_children')) {
          copy[k] = v;
        }
      }
      return copy;
    };

    TreeView.prototype._expansionLayout = function() {
      this._formatNode(this.root, 0);
      this.root.x0 = this.height / 2;
      this.root.y0 = 0;
      this.root.root = true;
      return true;
    };

    TreeView.prototype._formatNode = function(node, depth, parentNode) {
      var c, children, current_depth, isExpanded, len, q, r, record, ref;
      if (parentNode == null) {
        parentNode = null;
      }
      if (node.hidden) {
        return null;
      }
      current_depth = depth + 1;
      record = {};
      node.parent = parentNode;
      node.root = false;
      if ((node.leaf != null) && node.leaf === "true") {
        record['num_leaves'] = 1;
        record['outgroup'] = node.label;
        record['depth'] = current_depth;
        record['length'] = node.length;
        record['num_selected'] = (ref = node.selected) != null ? ref : {
          1: 0
        };
        return record;
      } else {
        isExpanded = true;
        children = node.children;
        if (node._children != null) {
          isExpanded = false;
          children = node._children;
        }
        if (current_depth < this.expandDepth) {
          node.children = children;
          node._children = null;
        } else if (isExpanded) {
          node._children = children;
          node.children = null;
        } else {
          node._children = children;
          node.children = null;
        }
        record = {
          num_leaves: 0,
          num_selected: 0,
          outgroup: '',
          depth: 1e6,
          length: 0
        };
        for (q = 0, len = children.length; q < len; q++) {
          c = children[q];
          r = this._formatNode(c, current_depth, node);
          record['num_leaves'] += r['num_leaves'];
          if (!(this.genomes.filtered > 0 || this.genomes.filterReset === true)) {
            record['num_leaves'] += r['num_selected'];
          }
          if ((record['depth'] > r['depth']) || (record['depth'] === r['depth'] && record['length'] < r['length'])) {
            record['depth'] = r['depth'];
            record['length'] = r['length'];
            record['outgroup'] = r['outgroup'];
          }
        }
        node.label = record['num_leaves'] + " genomes (outgroup: " + record['outgroup'] + ")";
        node.num_leaves = record['num_leaves'];
        node.num_selected = record['num_selected'];
        if (node.num_selected === node.num_leaves) {
          node.internal_node_selected = 2;
        } else if (node.num_selected > 0) {
          node.internal_node_selected = 1;
        } else {
          node.internal_node_selected = 0;
        }
      }
      return record;
    };

    TreeView.prototype._scale = function() {
      var farthest, lowest, padding, percCovered, xedge, yedge;
      farthest = d3.max(this.nodes, function(d) {
        return d.sum_length * 1;
      });
      lowest = d3.max(this.nodes, function(d) {
        return d.x;
      });
      percCovered = 0.10 * this.root.num_leaves;
      if (percCovered > 0.90) {
        percCovered = 0.90;
      }
      padding = 20;
      yedge = (this.width - padding) * percCovered;
      xedge = (this.height - padding) * percCovered;
      this.branch_scale_factor_y = yedge / farthest;
      this.branch_scale_factor_x = xedge / lowest;
      return true;
    };

    TreeView.prototype._expandCollapse = function(genomes, d, el) {
      var c, c2, c3, len, len1, len2, maxy, q, ref, ref1, ref2, s, svgNode, w;
      svgNode = d3.select(el);
      this.edgeNode = null;
      maxy = 0;
      if (d.children != null) {
        this.expand = false;
        d._children = d.children;
        d.children = null;
        this.edgeNode = d;
      } else {
        this.expand = true;
        d.children = d._children;
        d._children = null;
        ref = d.children;
        for (q = 0, len = ref.length; q < len; q++) {
          c = ref[q];
          if (c._children != null) {
            c.children = c._children;
            c._children = null;
          }
          if (c.children != null) {
            ref1 = c.children;
            for (s = 0, len1 = ref1.length; s < len1; s++) {
              c2 = ref1[s];
              if (c2._children != null) {
                c2.children = c2._children;
                c2._children = null;
              }
              if (c2.children != null) {
                ref2 = c2.children;
                for (w = 0, len2 = ref2.length; w < len2; w++) {
                  c3 = ref2[w];
                  if (c3.sum_length > maxy) {
                    maxy = c3.sum_length;
                    this.edgeNode = c3;
                  }
                }
              }
              if (c2.sum_length > maxy) {
                maxy = c2.sum_length;
                this.edgeNode = c2;
              }
            }
          }
          if (c.sum_length > maxy) {
            maxy = c.sum_length;
            this.edgeNode = c;
          }
        }
      }
      this.expansionContraction = true;
      this.update(genomes, d);
      return true;
    };

    TreeView.prototype.zoomed = function() {
      this.canvas.selectAll("g.treenode").attr("transform", (function(_this) {
        return function(d) {
          return _this._zTransform(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      this.canvas.selectAll("path.treelink").attr("d", (function(_this) {
        return function(d) {
          return _this._zTranslate(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      this.scaleBar.select("line").attr('transform', 'scale(' + d3.event.scale + ',1)');
      return true;
    };

    TreeView.prototype._zTranslate = function(d, xzoom, yzoom) {
      var sourceX, sourceY, targetX, targetY;
      sourceX = xzoom(d.source.y);
      sourceY = yzoom(d.source.x);
      targetX = xzoom(d.target.y);
      targetY = yzoom(d.target.x);
      return "M" + sourceX + "," + sourceY + "L" + sourceX + "," + targetY + "L" + targetX + "," + targetY;
    };

    TreeView.prototype._zTransform = function(d, xzoom, yzoom) {
      d.oldX = yzoom(d.x);
      d.oldY = xzoom(d.y);
      return "translate(" + xzoom(d.y) + "," + yzoom(d.x) + ")";
    };

    TreeView.prototype._classList = function(d) {
      var clsList;
      clsList = ['treenode'];
      if (d.selected) {
        clsList.push("selectedNode");
      }
      if (d.focus) {
        clsList.push("focusNode");
      }
      if (d.assignedGroup != null) {
        clsList.push("groupedNode" + d.assignedGroup);
      }
      if (d.activeGroup) {
        clsList.push("activeGroupNode");
      }
      if (d.internal_node_selected != null) {
        if (d.internal_node_selected === 2) {
          clsList.push("internalSNodeFull");
        } else if (d.internal_node_selected === 1) {
          clsList.push("internalSNodePart");
        }
      }
      return clsList.join(' ');
    };

    TreeView.prototype._findLeaf = function(genome) {
      var found, n;
      n = null;
      found = this.leaves.some(function(el, i) {
        if (el.genome === genome) {
          n = el;
          return true;
        } else {
          return false;
        }
      });
      if (!found) {
        throw new SuperphyError("No leaf node matching " + genome + " found.");
        return null;
      }
      return n;
    };

    TreeView.prototype._legend = function(el) {
      var cladeExpand, cladeSelect, colw, colw2, csColumn, ecColumn, expandCollapse, focusNode, genomeSelect, gsColumn, indent, lineh, lineh2, lineh3, lineh4, lineh5, lineh6, panZoom, pzRow, pzdx, pzdx2, pzdy, textdx, textdx2, textdy;
      lineh = 25;
      lineh2 = 40;
      lineh3 = 55;
      lineh4 = 70;
      lineh5 = 85;
      lineh6 = 100;
      textdx = ".6em";
      textdx2 = "2.5em";
      textdy = ".4em";
      pzdx = "3.2em";
      pzdx2 = "3.7em";
      pzdy = ".5em";
      indent = 8;
      colw = 245;
      colw2 = 480;
      if (this.style === 'select') {
        gsColumn = el.append("g").attr("transform", "translate(5," + lineh + ")");
        genomeSelect = gsColumn.append("g").attr("class", 'treenode');
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to select / unselect genome');
        genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Unselected genome');
        genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "lightsteelblue");
        genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Selected genome');
        genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh3 + ")");
        genomeSelect.append('rect').attr('width', 11).attr('height', 11).attr('x', -5.5).attr('y', -5.5).style('fill', 'steelblue');
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Active group genome');
        genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh4 + ")");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("stroke", "#ffa500").style("stroke-width", "3px");
        genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Searched genome');
        csColumn = el.append("g").attr("transform", "translate(" + colw + "," + lineh + ")");
        cladeSelect = csColumn.append("g").attr("class", 'treenode');
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to select / unselect clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('No genomes selected in clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode internalSNodePart').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Some genomes selected in clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode internalSNodeFull').attr("transform", "translate(" + indent + "," + lineh3 + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('All genomes selected in clade');
        ecColumn = el.append("g").attr("transform", "translate(" + colw2 + "," + lineh + ")");
        expandCollapse = ecColumn.append("g").attr("class", 'treenode');
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf0fe";
        });
        expandCollapse.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to collapse / expand clade');
        expandCollapse = ecColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf146";
        });
        expandCollapse.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Expanded clade');
        expandCollapse = ecColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf0fe";
        });
        expandCollapse.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Collapsed clade');
        pzRow = el.append("g").attr("transform", "translate(0,0)");
        panZoom = pzRow.append("g").attr("class", 'treenode');
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Pan');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx).attr("dy", pzdy).attr("text-anchor", "start").text('Click & Drag');
        panZoom = pzRow.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + ",0)");
        panZoom.append("text").attr("class", "slash").attr("dx", "-.4em").attr("dy", ".5em").attr("text-anchor", "start").text('Zoom');
        return panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx).attr("dy", pzdy).attr("text-anchor", "start").text('Scroll');
      } else {
        genomeSelect = el.append("g").attr("class", 'treenode').attr("transform", "translate(5,0)");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 8).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Select genome');
        cladeExpand = el.append("g").attr("class", 'treenode').attr("transform", "translate(5, " + lineh + ")");
        cladeExpand.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 4).attr("x", -1).text(function(d) {
          return "\uf0fe";
        });
        cladeExpand.append("text").attr("class", "slash").attr("dx", ".5em").attr("dy", ".5em").attr("text-anchor", "start").text('/');
        cladeExpand.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 8).attr("x", 17).text(function(d) {
          return "\uf146";
        });
        cladeExpand.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Expand / Collapse clade');
        panZoom = el.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + ",0)");
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Pan ');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx2).attr("dy", pzdy).attr("text-anchor", "start").text('Click & Drag');
        panZoom = el.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + "," + lineh + ")");
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Zoom');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx2).attr("dy", pzdy).attr("text-anchor", "start").text('Scroll');
        focusNode = el.append("g").attr("class", 'treenode focusNode').attr("transform", "translate(" + colw2 + ",0)");
        focusNode.append("circle").attr("r", 4).attr("cx", 8).attr("cy", 2);
        return focusNode.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Target genome');
      }
    };

    TreeView.prototype._treeOps = function(el, legendID) {
      var colButtonID, controls, expButtonID, findButtonID, findInputID, fitButtonID, num, opsHtml, resetButtonID, xStretchButtonID, yStretchButtonID;
      opsHtml = '';
      controls = '<div class="row">';
      controls += "<div class='col-sm-9 span9'><div class='btn-group' id='tree-controls'>";
      fitButtonID = "tree_fit_button" + this.elNum;
      controls += "<button id='" + fitButtonID + "' type='button' class='btn btn-default btn-sm'>Fit to window</button>";
      resetButtonID = "tree_reset_button" + this.elNum;
      controls += "<button id='" + resetButtonID + "' type='button' class='btn btn-default btn-sm'>Reset</button>";
      expButtonID = "tree_expand_button" + this.elNum;
      controls += "<button id='" + expButtonID + "' type='button' class='btn btn-default btn-sm'>Expand</button>";
      colButtonID = "tree_collapse_button" + this.elNum;
      controls += "<button id='" + colButtonID + "' type='button' class='btn btn-default btn-sm'>Collapse</button>";
      xStretchButtonID = "tree_xstretch_button" + this.elNum;
      controls += "<button id='" + xStretchButtonID + "' type='button' class='btn btn-default btn-sm'>X-stretch</button>";
      yStretchButtonID = "tree_ystretch_button" + this.elNum;
      controls += "<button id='" + yStretchButtonID + "' type='button' class='btn btn-default btn-sm'>Y-stretch</button>";
      controls += "</div></div>";
      findButtonID = "tree_find_button" + this.elNum;
      findInputID = "tree_find_input" + this.elNum;
      controls += "<div class='col-sm-3 span3'><div class='input-group input-prepend input-group-sm'>";
      controls += "<span class='input-group-btn'> <button id='" + findButtonID + "' class='btn btn-default btn-sm' type='button'>Search</button></span>";
      controls += "<input id='" + findInputID + "' type='text' class='form-control input-small'></div></div>";
      controls += "</div>";
      opsHtml += "" + controls;
      jQuery("<div class='tree_operations'>" + opsHtml + "</div>").appendTo(el);
      num = this.elNum - 1;
      jQuery("#" + findButtonID).click(function(e) {
        var searchString;
        e.preventDefault();
        searchString = jQuery("#" + findInputID).val();
        return viewController.highlightInView(searchString, num);
      });
      jQuery("#" + fitButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'fit_window');
      });
      jQuery("#" + resetButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'reset_window');
      });
      jQuery("#" + expButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'expand_tree');
      });
      jQuery("#" + colButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'collapse_tree');
      });
      jQuery("#" + xStretchButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'xstretch');
      });
      jQuery("#" + yStretchButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'ystretch');
      });
      return true;
    };

    TreeView.prototype.highlightGenomes = function(genomes, targetList) {
      var gs, l, len, len1, maxy, n, num, q, ref, s, targetNodes;
      this.nonMetaUpdate = true;
      ref = this.leaves;
      for (q = 0, len = ref.length; q < len; q++) {
        l = ref[q];
        l.focus = false;
      }
      if ((targetList != null) && targetList.length) {
        targetNodes = this._blowUpPath(targetList);
        if (targetNodes.length) {
          maxy = 0;
          this.edgeNode = null;
          for (s = 0, len1 = targetNodes.length; s < len1; s++) {
            n = targetNodes[s];
            if (n.sum_length > maxy) {
              maxy = n.sum_length;
              this.edgeNode = n;
            }
          }
          this.expansionContraction = true;
          num = this.elNum - 1;
          this.update(genomes);
          return viewController.viewAction(num, 'fit_window');
        } else {
          gs = targetList.join(', ');
          throw new SuperphyError("TreeView method highlightGenome error. Genome(s) " + gs + " not found.");
        }
      }
    };

    TreeView.prototype._blowUpPath = function(targetList) {
      var curr, g, len, n, q, targetNodes;
      targetNodes = [];
      for (q = 0, len = targetList.length; q < len; q++) {
        g = targetList[q];
        n = this._findLeaf(g);
        n.focus = true;
        targetNodes.push(n);
        curr = n.parent;
        while (curr) {
          if (curr._children != null) {
            curr.children = curr._children;
            curr._children = null;
          }
          curr = curr.parent;
        }
      }
      return targetNodes;
    };

    TreeView.prototype.expandTree = function(genomes) {
      this._expandOneLevel(this.root);
      this.reformat = true;
      this.update(genomes);
      return true;
    };

    TreeView.prototype.collapseTree = function(genomes) {
      var len, n, q, ref;
      this.levelTracker = 0;
      this.depths = [];
      ref = this.nodes;
      for (q = 0, len = ref.length; q < len; q++) {
        n = ref[q];
        if (n.leaf || (n._children != null)) {
          this.depths.push(n.depth);
          this.levelTracker = Math.max.apply(Math, this.depths);
        }
      }
      this._collapseOneLevel(this.root);
      this.reformat = true;
      this.update(genomes);
      return true;
    };

    TreeView.prototype._collapseOneLevel = function(n) {
      var c, len, q, ref;
      if (n.children != null) {
        ref = n.children;
        for (q = 0, len = ref.length; q < len; q++) {
          c = ref[q];
          this._collapseOneLevel(c);
        }
      }
      if ((n._children != null) || n.leaf) {
        if (n.depth === this.levelTracker) {
          if (n.parent.children !== null) {
            n.parent._children = n.parent.children;
            n.parent.children = null;
          }
        }
      }
      return true;
    };

    TreeView.prototype._expandOneLevel = function(n) {
      var c, len, q, ref;
      if ((n.oldX == null) && (this.launchPt.oldX != null)) {
        n.oldX = this.launchPt.oldX + (n.x - this.launchPt.x0);
      }
      if ((n.oldY == null) && (this.launchPt.oldY != null)) {
        n.oldY = this.launchPt.oldY + (n.y - this.launchPt.y0);
      }
      if (n.children != null) {
        ref = n.children;
        for (q = 0, len = ref.length; q < len; q++) {
          c = ref[q];
          this._expandOneLevel(c);
        }
      }
      if (n._children != null) {
        n.children = n._children;
        n._children = null;
      }
      return true;
    };

    return TreeView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_msa.coffee
   Desc: Multiple Sequence Alignment View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 9th, 2013
   */


  /*
   CLASS MsaView
    
   Multiple Sequence Alignment view
   
   Always locus-based
   Returns nothing to redirect/select (no click behavior defined)
   */

  MsaView = (function(superClass) {
    extend(MsaView, superClass);

    function MsaView(parentElem, style1, elNum, msaArgs) {
      var alignmentJSON;
      this.parentElem = parentElem;
      this.style = style1;
      this.elNum = elNum;
      if (!(msaArgs.length > 0)) {
        throw new SuperphyError('Missing argument. MsaView constructor requires JSON alignment object.');
      }
      alignmentJSON = msaArgs[0];
      this.locusData = null;
      if (msaArgs[1] != null) {
        this.locusData = msaArgs[1];
      }
      MsaView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this._formatAlignment(alignmentJSON);
    }

    MsaView.prototype.type = 'msa';

    MsaView.prototype.elName = 'genome_msa';

    MsaView.prototype.blockLen = 70;

    MsaView.prototype.nameLen = 25;

    MsaView.prototype.consLine = 'conservation_line';

    MsaView.prototype.posLine = 'position_line';

    MsaView.prototype.nuclClasses = {
      'A': 'nuclA',
      'G': 'nuclG',
      'C': 'nuclC',
      'T': 'nuclT',
      '*': 'consM',
      ' ': 'consMM',
      '-': 'nuclGAP'
    };

    MsaView.prototype.cssClass = 'msa_row_name';

    MsaView.prototype.maxRows = 26;

    MsaView.prototype.minRows = 0;

    MsaView.prototype.hasLocation = true;

    MsaView.prototype._formatAlignment = function(alignmentJSON) {
      var g, j, len, len1, loc, n, pos, posElem, q, ref, ref1, ref2, ref3, s, seq, seqLen, w;
      this.rowIDs = (function() {
        var results1;
        results1 = [];
        for (g in alignmentJSON) {
          results1.push(g);
        }
        return results1;
      })();
      if (alignmentJSON[this.rowIDs[0]].hasOwnProperty('contig_name')) {
        this.hasLocation = true;
      } else {
        this.hasLocation = false;
      }
      seqLen = alignmentJSON[this.rowIDs[0]]['seq'].length;
      this.alignment = {};
      ref = this.rowIDs;
      for (q = 0, len = ref.length; q < len; q++) {
        n = ref[q];
        this.alignment[n] = {
          'alignment': [],
          'seq': alignmentJSON[n]['seq'],
          'genome': alignmentJSON[n]['genome'],
          'locus': alignmentJSON[n]['locus'],
          'location': false
        };
        if (this.hasLocation) {
          loc = alignmentJSON[n]['start_pos'] + ".." + alignmentJSON[n]['end_pos'];
          if (alignmentJSON[n]['strand'] === -1) {
            loc = "complement(" + loc + ")";
          }
          loc = alignmentJSON[n]['contig_name'] + ("[" + loc + "]");
          this.alignment[n]['location'] = loc;
        }
      }
      this.alignment[this.consLine] = {
        'alignment': []
      };
      this.alignment[this.posLine] = {
        'alignment': []
      };
      this.numBlock = 0;
      for (j = s = 0, ref1 = seqLen, ref2 = this.blockLen; ref2 > 0 ? s <= ref1 : s >= ref1; j = s += ref2) {
        this.numBlock++;
        ref3 = this.rowIDs;
        for (w = 0, len1 = ref3.length; w < len1; w++) {
          n = ref3[w];
          seq = alignmentJSON[n]['seq'];
          this.alignment[n]['alignment'].push(this._formatBlock(seq.substr(j, this.blockLen)));
        }
        pos = j + 1;
        posElem = "<td class='msaPosition'>" + pos + "</td>";
        this.alignment[this.posLine]['alignment'].push(posElem);
      }
      return true;
    };

    MsaView.prototype._formatBlock = function(seq) {
      var c, chr, cls, html, q, ref;
      html = '';
      seq.toUpperCase();
      for (c = q = 0, ref = seq.length - 1; 0 <= ref ? q <= ref : q >= ref; c = 0 <= ref ? ++q : --q) {
        chr = seq.charAt(c);
        cls = this.nuclClasses[chr];
        html += "<td class='" + cls + "'>" + chr + "</td>";
      }
      return html;
    };

    MsaView.prototype.update = function(genomes) {
      var ft, msaElem, t1, t2;
      msaElem = jQuery("#" + this.elID);
      if (msaElem.length) {
        msaElem.empty();
        msaElem.append('<tbody></tbody>');
      } else {
        msaElem = jQuery("<table id='" + this.elID + "'><tbody></tbody></table>");
        jQuery(this.parentElem).append(msaElem);
      }
      t1 = new Date();
      this._appendRows(msaElem, genomes);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MsaView update elapsed time: ' + ft);
      return true;
    };

    MsaView.prototype._appendRows = function(el, genomes) {
      var a, consArray, g, genomeElem, genomeID, i, j, len, len1, loc, matches, n, name, nameCell, newLine, q, ref, ref1, row, rows, s, thiscls, tmp, visibleRows, w;
      genomeElem = {};
      visibleRows = [];
      tmp = {};
      newLine = '&#013;';
      ref = this.rowIDs;
      for (q = 0, len = ref.length; q < len; q++) {
        i = ref[q];
        a = this.alignment[i];
        genomeID = a['genome'];
        g = genomes.genome(genomeID);
        if (g.visible) {
          visibleRows.push(i);
          name = g.viewname;
          if (this.locusData != null) {
            name += this.locusData.locusString(i);
          }
          tmp[i] = name;
          thiscls = this.cssClass;
          if (g.cssClass != null) {
            thiscls = this.cssClass + ' ' + g.cssClass;
          }
          nameCell = "<td class='" + thiscls + "' data-genome='" + genomeID + "' ";
          if (this.hasLocation) {
            loc = a['location'];
            nameCell += " data-location='" + loc + "'";
          }
          nameCell += ">" + name + "</td>";
          genomeElem[i] = nameCell;
        }
      }
      n = visibleRows.length;
      if (n >= this.maxRows) {
        el.html(("<tr class='msa-info'><td>Multiple sequence alignment is displayed when number of visible rows is below " + this.maxRows + ".</td></tr>") + ("<tr class='msa-info'><td>Current number of rows: " + n + "</td></tr>") + "<tr class='msa-info'><td>To view, either download alignment or use the filter to reduce visible genomes.</td></tr>");
      } else if (n <= this.minRows) {
        el.html(("<tr class='msa-info'><td>Multiple sequence alignment is displayed when number of visible rows is above " + this.minRows + ".</td></tr>") + ("<tr class='msa-info'><td>Current number of rows: " + n + "</td></tr>"));
      } else {
        visibleRows.sort(function(a, b) {
          var aname, bname;
          aname = tmp[a];
          bname = tmp[b];
          if (aname > bname) {
            return 1;
          } else if (aname < bname) {
            return -1;
          } else {
            return 0;
          }
        });
        matches = this.cigarLine(visibleRows);
        rows = '';
        for (j = s = 0, ref1 = this.numBlock; 0 <= ref1 ? s < ref1 : s > ref1; j = 0 <= ref1 ? ++s : --s) {
          consArray = this.alignment[visibleRows[0]]['alignment'][j].split('');
          console.log(consArray.length);
          for (w = 0, len1 = visibleRows.length; w < len1; w++) {
            i = visibleRows[w];
            row = '<tr>';
            row += genomeElem[i] + this.alignment[i]['alignment'][j];
            row += '</tr>';
            rows += row;
          }
          row = '<tr>';
          row += '<td></td>' + matches[j];
          row += '</tr>';
          rows += row;
          row = '<tr>';
          row += this.alignment[this.posLine]['alignment'][j];
          row += '</tr>';
          rows += row;
        }
        el.append(rows);
        jQuery("td." + thiscls).tooltip({
          'placement': 'top',
          'title': function() {
            var elem, popup;
            elem = jQuery(this);
            popup = elem.text();
            if (elem.attr('data-location') != null) {
              popup += "\n\nlocation: " + elem.attr('data-location');
            }
            return popup;
          }
        });
      }
      return true;
    };

    MsaView.prototype.updateCSS = function(gset, genomes) {
      var msaEl;
      msaEl = jQuery("#" + this.elID);
      if (!((msaEl != null) && msaEl.length)) {
        throw new SuperphyError("DOM element for Msa view " + this.elID + " not found. Cannot call MsaView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    MsaView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, len, liEl, q, thiscls;
      cls = this.cssClass();
      for (q = 0, len = changedG.length; q < len; q++) {
        g = changedG[q];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        descriptor = "td[data-genome='" + g + "']";
        itemEl = el.find(descriptor);
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("Msa element for genome " + g + " not found in MsaView " + this.elID);
          return false;
        }
        console.log("Updating class to " + thiscls);
        liEl = itemEl.parents().eq(1);
        liEl.attr('class', thiscls);
      }
      return true;
    };

    MsaView.prototype.select = function(genome, isSelected) {
      return true;
    };

    MsaView.prototype.dump = function(genomes) {
      var a, g, genomeID, i, len, name, output, q, ref, seq;
      output = '';
      ref = this.rowIDs;
      for (q = 0, len = ref.length; q < len; q++) {
        i = ref[q];
        a = this.alignment[i];
        genomeID = a['genome'];
        g = genomes.genome(genomeID);
        if (g.visible) {
          name = g.viewname;
          if ((this.locusData != null) && (this.locusData[i] != null)) {
            name += this.locusData[i];
          }
          if (this.hasLocation) {
            name += ' location=' + a['location'];
          }
          seq = a['seq'];
          output += ">" + name + "\n" + seq + "\n";
        }
      }
      return {
        ext: 'fasta',
        type: 'text/plain',
        data: output
      };
    };

    MsaView.prototype.cigarLine = function(visibleRows) {
      var aa, c, consArray, consL, final, i, j, l, len, len1, q, r, ref, ref1, ref2, ref3, s, seq, w;
      consL = this.alignment[visibleRows[0]]["seq"].split('');
      l = consL.length - 1;
      ref = visibleRows.slice(1);
      for (q = 0, len = ref.length; q < len; q++) {
        r = ref[q];
        seq = this.alignment[r]["seq"];
        for (i = s = 0, ref1 = l; 0 <= ref1 ? s <= ref1 : s >= ref1; i = 0 <= ref1 ? ++s : --s) {
          c = consL[i];
          if (c !== '$') {
            if (c !== seq[i]) {
              consL[i] = '$';
            }
          }
        }
      }
      final = '';
      for (w = 0, len1 = consL.length; w < len1; w++) {
        c = consL[w];
        if (c === '$') {
          final += ' ';
        } else {
          final += '*';
        }
      }
      consArray = [];
      for (j = aa = 0, ref2 = l, ref3 = this.blockLen; ref3 > 0 ? aa <= ref2 : aa >= ref2; j = aa += ref3) {
        consArray.push(this._formatBlock(final.substr(j, this.blockLen)));
      }
      return consArray;
    };

    return MsaView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_tickers.coffee
   Desc: Multiple Superphy Ticker Classes. Tickers are single line summaries of current genome data
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 16th, 2013
   */


  /*
   MIXIN support
   
   The function adds instance properties to a class.
   */

  mixOf = function() {
    var Mixed, base, method, mixin, mixins, name, q, ref;
    base = arguments[0], mixins = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    Mixed = (function(superClass) {
      extend(Mixed, superClass);

      function Mixed() {
        return Mixed.__super__.constructor.apply(this, arguments);
      }

      return Mixed;

    })(base);
    for (q = mixins.length - 1; q >= 0; q += -1) {
      mixin = mixins[q];
      ref = mixin.prototype;
      for (name in ref) {
        method = ref[name];
        Mixed.prototype[name] = method;
      }
    }
    return Mixed;
  };


  /*
   CLASS TickerTemplate
   
   Template object for tickers. Defines required and
   common properties/methods. All ticker objects
   are descendants of the TickerTemplate.
   */

  TickerTemplate = (function() {
    function TickerTemplate(parentElem, elNum) {
      this.parentElem = parentElem;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    TickerTemplate.prototype.elNum = 1;

    TickerTemplate.prototype.elName = 'ticker';

    TickerTemplate.prototype.elID = void 0;

    TickerTemplate.prototype.parentElem = void 0;

    TickerTemplate.prototype.cssClass = void 0;

    TickerTemplate.prototype.flavor = void 0;

    TickerTemplate.prototype.update = function(genomes) {
      throw new SuperphyError("TickerTemplate method update() must be defined in child class (" + this.flavor + ").");
      return false;
    };

    return TickerTemplate;

  })();


  /*
   CLASS MetaTicker
    
   Counts number of a specified meta-data item
   */

  MetaTicker = (function(superClass) {
    extend(MetaTicker, superClass);

    function MetaTicker(parentElem, elNum, tickerArgs) {
      this.parentElem = parentElem;
      this.elNum = elNum;
      MetaTicker.__super__.constructor.call(this, this.parentElem, this.elNum);
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. MetaTicker constructor requires a string indicating meta-data type.');
      }
      this.metaType = tickerArgs[0];
    }

    MetaTicker.prototype.elName = 'meta_ticker';

    MetaTicker.prototype.cssClass = 'superphy_ticker_table';

    MetaTicker.prototype.flavor = 'meta';

    MetaTicker.prototype.noDataLabel = 'Not available';

    MetaTicker.prototype.update = function(genomes) {
      var bodyElem, bodyRow, countObj, ft, headElem, headRow, k, ks, len, q, t1, t2, tickerElem, v;
      tickerElem = jQuery("#" + this.elID);
      if (tickerElem.length) {
        tickerElem.empty();
      } else {
        tickerElem = jQuery("<table id='" + this.elID + "' class='" + this.cssClass + "'></table>");
        jQuery(this.parentElem).append(tickerElem);
      }
      t1 = new Date();
      countObj = {};
      this._updateCounts(countObj, genomes.pubVisible, genomes.public_genomes);
      this._updateCounts(countObj, genomes.pvtVisible, genomes.private_genomes);
      headElem = jQuery('<thead><tr></tr></thead>').appendTo(tickerElem);
      bodyElem = jQuery('<tbody><tr></tr></tbody>').appendTo(tickerElem);
      headRow = jQuery('<tr></tr>').appendTo(headElem);
      bodyRow = jQuery('<tr></tr>').appendTo(bodyElem);
      ks = ((function() {
        var results1;
        results1 = [];
        for (k in countObj) {
          results1.push(k);
        }
        return results1;
      })()).sort(a, b)(function() {
        if (a === this.noDataLabel) {
          return 1;
        }
        if (b === this.noDataLabel) {
          return -1;
        }
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      for (q = 0, len = ks.length; q < len; q++) {
        k = ks[q];
        v = countObj[k];
        headRow.append("<th>" + k + "</th>");
        bodyRow.append("<td>" + v + "</td>");
      }
      t2 = new Date();
      ft = t2 - t1;
      console.log('MetaTicker update elapsed time: ' + ft);
      return true;
    };

    MetaTicker.prototype._updateCounts = function(counts, visibleG, genomes) {
      var g, len, meta, q;
      meta = this.metaType;
      console.log('META' + meta);
      for (q = 0, len = visibleG.length; q < len; q++) {
        g = visibleG[q];
        if (genomes[g][meta] != null) {
          if (counts[genomes[g][meta]] != null) {
            counts[genomes[g][meta]]++;
          } else {
            counts[genomes[g][meta]] = 1;
          }
        } else {
          if (counts[this.noDataLabel] != null) {
            counts[this.noDataLabel]++;
          } else {
            counts[this.noDataLabel] = 1;
          }
        }
      }
      return true;
    };

    return MetaTicker;

  })(TickerTemplate);


  /*
   CLASS LocusTicker
    
   Counts number of a specified meta-data item
   */

  StxTicker = (function(superClass) {
    extend(StxTicker, superClass);

    function StxTicker(parentElem, elNum, tickerArgs) {
      this.parentElem = parentElem;
      this.elNum = elNum;
      StxTicker.__super__.constructor.call(this, this.parentElem, this.elNum, this.elNum);
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. StxTicker constructor requires a LocusController object.');
      }
      this.locusData = tickerArgs[0];
    }

    StxTicker.prototype.elName = 'stx_ticker';

    StxTicker.prototype.cssClass = 'superphy_ticker_table';

    StxTicker.prototype.flavor = 'stx';

    StxTicker.prototype.noDataLabel = 'NA';

    StxTicker.prototype.update = function(genomes) {
      var bodyElem, bodyRow, countObj, ft, headElem, headRow, k, ks, len, q, t1, t2, tickerElem, v;
      tickerElem = jQuery("#" + this.elID);
      if (tickerElem.length) {
        tickerElem.empty();
      } else {
        tickerElem = jQuery("<table id='" + this.elID + "' class='" + this.cssClass + "'></table>");
        jQuery(this.parentElem).append(tickerElem);
      }
      t1 = new Date();
      countObj = this.locusData.count(genomes);
      headElem = jQuery('<thead></thead>').appendTo(tickerElem);
      bodyElem = jQuery('<tbody></tbody>').appendTo(tickerElem);
      headRow = jQuery('<tr></tr>').appendTo(headElem);
      bodyRow = jQuery('<tr></tr>').appendTo(bodyElem);
      ks = (function() {
        var results1;
        results1 = [];
        for (k in countObj) {
          results1.push(k);
        }
        return results1;
      })();
      ks.sort(function(a, b) {
        if (a === this.noDataLabel) {
          return 1;
        }
        if (b === this.noDataLabel) {
          return -1;
        }
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      for (q = 0, len = ks.length; q < len; q++) {
        k = ks[q];
        v = countObj[k];
        headRow.append("<th>" + k + "</th>");
        bodyRow.append("<td>" + v + "</td>");
      }
      t2 = new Date();
      ft = t2 - t1;
      console.log('StxTicker update elapsed time: ' + ft);
      return true;
    };

    return StxTicker;

  })(TickerTemplate);


  /*
   CLASS Histogram
    
   Histogram mixin
   */

  Histogram = (function() {
    function Histogram() {}

    Histogram.prototype.init = function() {
      var bins, margin;
      margin = {
        top: 40,
        right: 30,
        bottom: 40,
        left: 30
      };
      this.width = 300 - margin.left - margin.right;
      this.height = 250 - margin.top - margin.bottom;
      bins = [
        {
          'val': 0,
          'key': '0'
        }, {
          'val': 1,
          'key': '1'
        }, {
          'val': 2,
          'key': '2'
        }, {
          'val': 3,
          'key': '3'
        }, {
          'val': 4,
          'key': '4'
        }, {
          'val': 5,
          'key': '>=5'
        }
      ];
      this.x = d3.scale.ordinal().domain(bins.map(function(d) {
        return d.val;
      })).rangeRoundBands([0, this.width], .05);
      this.x2 = d3.scale.ordinal().domain(bins.map(function(d) {
        return d.key;
      })).rangeRoundBands([0, this.width], .05);
      this.xAxis = d3.svg.axis().scale(this.x2).orient("bottom");
      this.histogram = d3.layout.histogram().bins([0, 1, 2, 3, 4, 5, 6]);
      this.parentElem.append("<div id='" + this.elID + "' class='" + this.cssClass + "'></div>");
      this.canvas = d3.select("#" + this.elID).append("svg").attr("width", this.width + margin.left + margin.right).attr("height", this.height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      this.formatCount = d3.format(",.0f");
      return this.canvas.append("g").attr("class", "x axis").attr("transform", "translate(0," + this.height + ")").call(this.xAxis).append("text").attr("dy", ".75em").attr("y", 23).attr("x", this.width / 2).attr("text-anchor", "middle").text('Number of Alleles');
    };

    Histogram.prototype.updateHistogram = function(values) {
      var histData, i, maxSteps, maxY, newBars, q, ref, steps, svgBars, yTop;
      histData = this.histogram(values);
      steps = [10, 50, 100, 200, 500, 800, 1000, 1200, 1500, 2000, 5000, 8000, 10000, 20000, 50000, 80000, 100000];
      maxSteps = steps.length;
      maxY = d3.max(histData, function(d) {
        return d.y;
      });
      yTop = NaN;
      for (i = q = 0, ref = maxSteps; q <= ref; i = q += 1) {
        if (maxY < steps[i]) {
          yTop = steps[i];
          break;
        }
      }
      this.y = d3.scale.linear().domain([0, yTop]).range([this.height, 0]);
      svgBars = this.canvas.selectAll("g.histobar").data(histData);
      svgBars.attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.x(d.x) + "," + _this.y(d.y) + ")";
        };
      })(this));
      svgBars.select("rect").attr("x", 0).attr("width", this.x.rangeBand()).attr("height", (function(_this) {
        return function(d) {
          return _this.height - _this.y(d.y);
        };
      })(this));
      svgBars.select("text").attr("dy", ".75em").attr("y", -14).attr("x", this.x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.y > 0) {
            return _this.formatCount(d.y);
          } else {
            return '';
          }
        };
      })(this));
      svgBars.exit().remove();
      newBars = svgBars.enter().append("g").attr("class", "histobar").attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.x(d.x) + "," + _this.y(d.y) + ")";
        };
      })(this));
      newBars.append("rect").attr("x", 0).attr("width", this.x.rangeBand()).attr("height", (function(_this) {
        return function(d) {
          return _this.height - _this.y(d.y);
        };
      })(this));
      newBars.append("text").attr("dy", ".75em").attr("y", -14).attr("x", this.x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.y > 0) {
            return _this.formatCount(d.y);
          } else {
            return '';
          }
        };
      })(this));
      return true;
    };

    return Histogram;

  })();


  /*
   CLASS MatrixTicker
    
   Histogram of allele frequency for multiple genes
   */

  MatrixTicker = (function(superClass) {
    extend(MatrixTicker, superClass);

    function MatrixTicker(parentElem, elNum, genomes, tickerArgs) {
      var alleles, genes, tmp;
      this.parentElem = parentElem;
      this.elNum = elNum;
      MatrixTicker.__super__.constructor.call(this, this.parentElem, this.elNum, this.elNum);
      if (genomes == null) {
        throw new SuperphyError('Missing argument. MatrixTicker constructor requires GenomeController object.');
      }
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. MatrixTicker constructor requires a JSON object containing: nodes, links object.');
      }
      tmp = tickerArgs[0];
      genes = tmp['nodes'];
      alleles = tmp['links'];
      this._doCounts(genomes, genes, alleles);
      this.init();
    }

    MatrixTicker.prototype.elName = 'matrix_ticker';

    MatrixTicker.prototype.cssClass = 'matrix_histogram';

    MatrixTicker.prototype.flavor = 'matrix';

    MatrixTicker.prototype.noDataLabel = 'NA';

    MatrixTicker.prototype.update = function(genomes) {
      var ft, g, len, len1, n, q, ref, ref1, s, t1, t2, values;
      t1 = new Date();
      values = [];
      ref = genomes.pubVisible.concat(genomes.pvtVisible);
      for (q = 0, len = ref.length; q < len; q++) {
        g = ref[q];
        ref1 = this.geneList;
        for (s = 0, len1 = ref1.length; s < len1; s++) {
          n = ref1[s];
          if (!((this.counts[g] != null) && (this.counts[g][n] != null))) {
            throw new SuperphyError("Count not defined for genome " + g + " and gene " + n + ".");
          }
          values.push(this.counts[g][n]);
        }
      }
      this.updateHistogram(values);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MatrixTicker update elapsed time: ' + ft);
      return true;
    };

    MatrixTicker.prototype._doCounts = function(genomes, genes, alleles) {
      var g, gList, len, len1, n, numAlleles, q, ref, s;
      gList = Object.keys(genomes.public_genomes).concat(Object.keys(genomes.private_genomes));
      this.geneList = Object.keys(genes);
      this.counts = {};
      for (q = 0, len = gList.length; q < len; q++) {
        g = gList[q];
        this.counts[g] = {};
        ref = this.geneList;
        for (s = 0, len1 = ref.length; s < len1; s++) {
          n = ref[s];
          numAlleles = 0;
          if ((alleles[g] != null) && (alleles[g][n] != null)) {
            numAlleles = alleles[g][n].length;
          }
          this.counts[g][n] = numAlleles;
        }
      }
      return true;
    };

    return MatrixTicker;

  })(mixOf(TickerTemplate, Histogram));


  /*
   CLASS AlleleTicker
    
   Histogram of allele frequency for one gene
   */

  AlleleTicker = (function(superClass) {
    extend(AlleleTicker, superClass);

    function AlleleTicker(parentElem, elNum, tickerArgs) {
      this.parentElem = parentElem;
      this.elNum = elNum;
      AlleleTicker.__super__.constructor.call(this, this.parentElem, this.elNum, this.elNum);
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. AlleleTicker constructor requires a LocusController object.');
      }
      this.locusData = tickerArgs[0];
      this.init();
    }

    AlleleTicker.prototype.elName = 'allele_ticker';

    AlleleTicker.prototype.cssClass = 'allele_histogram';

    AlleleTicker.prototype.flavor = 'allele';

    AlleleTicker.prototype.noDataLabel = 'NA';

    AlleleTicker.prototype.update = function(genomes) {
      var ft, t1, t2, values;
      t1 = new Date();
      values = this.locusData.count(genomes);
      this.updateHistogram(values);
      t2 = new Date();
      ft = t2 - t1;
      console.log('AlleleTicker update elapsed time: ' + ft);
      return true;
    };

    return AlleleTicker;

  })(mixOf(TickerTemplate, Histogram));


  /*
  
  
   File: superphy_matrix.coffee
   Desc: Genome x Gene table showing # of alleles
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 24th, 2013
   */


  /*
   CLASS MatrixView
    
   Gene Allele Matrix view
   
   Always genome based
   Links to individual genes
   */

  MatrixView = (function(superClass) {
    extend(MatrixView, superClass);

    function MatrixView(parentElem, style1, elNum, genomes, matrixArgs) {
      var alleles, dd, ddDiv, dialog, dialog2, gList, genes, nList, num, tmp;
      this.parentElem = parentElem;
      this.style = style1;
      this.elNum = elNum;
      if (genomes == null) {
        throw new SuperphyError('Missing argument. MatrixView constructor requires GenomeController object.');
      }
      if (!(matrixArgs.length > 0)) {
        throw new SuperphyError('Missing argument. MatrixView constructor requires JSON object containing: nodes, links.');
      }
      tmp = matrixArgs[0];
      genes = tmp['nodes'];
      alleles = tmp['links'];
      gList = Object.keys(genomes.public_genomes).concat(Object.keys(genomes.private_genomes));
      nList = Object.keys(genes);
      this.cellWidth = 20;
      this.margin = {
        top: 150,
        right: 0,
        bottom: 0,
        left: 250
      };
      this.height = gList.length * this.cellWidth;
      this.width = nList.length * this.cellWidth;
      this.dim = {
        w: this.width + this.margin.right + this.margin.left,
        h: this.height + this.margin.top + this.margin.bottom
      };
      MatrixView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this._computeMatrix(gList, genes, alleles);
      this.geneOrders = {
        name: d3.range(this.nGenes).sort((function(_this) {
          return function(a, b) {
            return d3.ascending(_this.geneNodes[a].name, _this.geneNodes[b].name);
          };
        })(this)),
        count: d3.range(this.nGenes).sort((function(_this) {
          return function(a, b) {
            return _this.geneNodes[b].count - _this.geneNodes[a].count;
          };
        })(this))
      };
      this.geneOrders['group'] = this.geneOrders['count'];
      this.orderType = 'name';
      this.z = d3.scale.linear().domain([0, 4]).clamp(true);
      this.x = d3.scale.ordinal().rangeBands([0, this.width]);
      this.cssClass = 'superphy-matrix';
      this.parentElem.append("<div id='" + this.elID + "' class='" + this.cssClass + "'></div>");
      ddDiv = jQuery('<div class="matrixSort"><span>Order:</span> </div>').appendTo("#" + this.elID);
      dd = jQuery('<select name="matrix-sort">' + '<option value="name" selected="selected"> by Name</option>' + '<option value="count"> by Frequency</option>' + '<option value="group"> by Group</option>' + '</select>').appendTo(ddDiv);
      num = this.elNum - 1;
      dd.change(function() {
        var sortType;
        sortType = this.value;
        return viewController.viewAction(num, 'matrix_sort', sortType);
      });
      this.wrap = d3.select("#" + this.elID).append("div").attr("class", "matrix-container").append("svg").attr("width", this.dim.w).attr("height", this.dim.h);
      this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      this.canvas.append("rect").attr("class", "matrixBackground").attr("width", this.width).attr("height", this.height);
      this.formatCount = d3.format(",.0f");
      dialog = jQuery('#dialog-matrix-row-select');
      if (!dialog.length) {
        dialog = jQuery('<div id="dialog-matrix-row-select"></div>').appendTo('body');
        dialog.text("Jump to genome information page?").dialog({
          title: 'Genome Information',
          autoOpen: false,
          resizable: false,
          height: 160,
          modal: true,
          buttons: {
            Yes: function() {
              var id;
              id = jQuery(this).data("row-id");
              window.location.href = "/superphy/strains/info?genome=" + id;
              return jQuery(this).dialog("close");
            },
            Cancel: function() {
              return jQuery(this).dialog("close");
            }
          }
        });
      }
      dialog2 = jQuery('#dialog-matrix-col-select');
      if (!dialog2.length) {
        dialog2 = jQuery('<div id="dialog-matrix-col-select"></div>').appendTo('body');
        dialog2.text("Jump to gene page?").dialog({
          title: 'Detailed Gene Information',
          autoOpen: false,
          resizable: false,
          height: 160,
          modal: true,
          buttons: {
            Yes: function() {
              var id;
              id = jQuery(this).data("col-id");
              window.location.href = "/superphy/genes/info?gene=" + id;
              return jQuery(this).dialog("close");
            },
            Cancel: function() {
              return jQuery(this).dialog("close");
            }
          }
        });
      }
      true;
    }

    MatrixView.prototype.type = 'matrix';

    MatrixView.prototype.elName = 'genome_matrix';

    MatrixView.prototype.duration = 500;

    MatrixView.prototype._computeMatrix = function(gList, genes, alleles) {
      var aa, g, gObj, i, len, len1, len2, len3, n, nList, numAlleles, q, ref, ref1, s, w;
      nList = Object.keys(genes);
      this.nGenomes = gList.length;
      this.nGenes = nList.length;
      this.genomeNodes = [];
      this.matrix = [];
      i = 0;
      for (q = 0, len = gList.length; q < len; q++) {
        g = gList[q];
        gObj = {
          id: i,
          genome: g,
          count: 0
        };
        this.genomeNodes.push(gObj);
        this.matrix[i] = d3.range(this.nGenes).map(function(j) {
          return {
            x: j,
            y: i,
            z: 0,
            i: null
          };
        });
        i++;
      }
      this.geneNodes = [];
      i = 0;
      for (s = 0, len1 = nList.length; s < len1; s++) {
        g = nList[s];
        gObj = {
          id: i,
          gene: g,
          name: genes[g],
          count: 0
        };
        this.geneNodes.push(gObj);
        i++;
      }
      i = 0;
      ref = this.genomeNodes;
      for (w = 0, len2 = ref.length; w < len2; w++) {
        g = ref[w];
        ref1 = this.geneNodes;
        for (aa = 0, len3 = ref1.length; aa < len3; aa++) {
          n = ref1[aa];
          numAlleles = 0;
          if ((alleles[g.genome] != null) && (alleles[g.genome][n.gene] != null)) {
            numAlleles = alleles[g.genome][n.gene].length;
          }
          g.count += numAlleles;
          n.count += numAlleles;
          this.matrix[g.id][n.id].z = numAlleles;
          this.matrix[g.id][n.id].i = i;
          i++;
        }
      }
      return true;
    };

    MatrixView.prototype.update = function(genomes) {
      var dt, genomesExit, newCols, newRows, svgGenes, svgGenomes, t1, t2, that;
      t1 = new Date();
      this._sync(genomes);
      this.height = this.cellWidth * this.currN;
      this.y = d3.scale.ordinal().rangeBands([0, this.height]);
      this.y.domain(this.genomeOrders[this.orderType]);
      this.x.domain(this.geneOrders[this.orderType]);
      this.canvas.selectAll(".matrixBackground").attr("height", this.height);
      svgGenomes = this.canvas.selectAll("g.matrixrow").data(this.currNodes, function(d) {
        return d.id;
      });
      svgGenomes.attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).select("text.matrixlabel").text(function(d) {
        return d.viewname;
      });
      svgGenomes.selectAll("g.matrixcell title").text(function(d) {
        return d.title;
      });
      that = this;
      newRows = svgGenomes.enter().append("g").attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).attr("transform", function(d, i) {
        return "translate(0,0)";
      }).each(function(d) {
        return that._row(this, that.matrix[d.id], that.x, that.y, that.z);
      });
      newRows.append("line").attr("x2", this.width);
      newRows.append("text").attr("class", "matrixlabel").attr("x", -6).attr("y", this.y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "end").text(function(d) {
        return d.viewname;
      }).on("click", function(d) {
        return jQuery('#dialog-matrix-row-select').data('row-id', d.genome).dialog('open');
      });
      svgGenes = this.canvas.selectAll("g.matrixcolumn").data(this.geneNodes, function(d) {
        return d.id;
      });
      svgGenes.selectAll("line").attr("x1", -this.height);
      newCols = svgGenes.enter().append("g").attr("class", "matrixcolumn").attr("transform", function(d, i) {
        return "translate(" + 0 + ")rotate(-90)";
      });
      newCols.append("line").attr("x1", -this.height);
      newCols.append("text").attr("class", "matrixlabel").attr("x", 6).attr("y", this.y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "start").text(function(d) {
        return d.name;
      }).on("click", function(d) {
        return jQuery('#dialog-matrix-col-select').data('col-id', d.gene).dialog('open');
      });
      this._assumePositions();
      genomesExit = svgGenomes.exit().transition().duration(this.duration).attr("transform", function(d) {
        return "translate(0,0)";
      }).remove();
      t2 = new Date();
      dt = new Date(t2 - t1);
      console.log('MatrixView update elapsed time (s): ' + dt.getMilliseconds());
      return true;
    };

    MatrixView.prototype._sync = function(genomes) {
      var c, g, i, len, len1, n, q, ref, ref1, s;
      this.currNodes = [];
      this.currN = 0;
      ref = this.genomeNodes;
      for (q = 0, len = ref.length; q < len; q++) {
        n = ref[q];
        g = genomes.genome(n.genome);
        if (g.visible) {
          n.viewname = g.viewname;
          n.selected = (g.isSelected != null) && g.isSelected;
          if (g.assignedGroup != null) {
            n.assignedGroup = g.assignedGroup;
          } else {
            n.assignedGroup = 0;
          }
          n.index = this.currN;
          this.currNodes.push(n);
          this.currN++;
          i = 0;
          ref1 = this.matrix[n.id];
          for (s = 0, len1 = ref1.length; s < len1; s++) {
            c = ref1[s];
            c.title = "genome: " + n.viewname + ", gene: " + this.geneNodes[i].name;
            i++;
          }
        }
      }
      this.genomeOrders = {
        name: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            return d3.ascending(_this.currNodes[a].viewname, _this.currNodes[b].viewname);
          };
        })(this)),
        count: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            return _this.currNodes[b].count - _this.currNodes[a].count;
          };
        })(this)),
        group: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            var gdiff;
            gdiff = _this.currNodes[b].assignedGroup - _this.currNodes[a].assignedGroup;
            if (gdiff === 0) {
              return _this.currNodes[b].count - _this.currNodes[a].count;
            } else {
              return gdiff;
            }
          };
        })(this))
      };
      return true;
    };

    MatrixView.prototype._row = function(svgRow, rowData, x, y, z) {
      var newCells, num, svgCells;
      svgCells = d3.select(svgRow).selectAll(".matrixcell").data(rowData, function(d) {
        return d.i;
      });
      num = this.elNum - 1;
      newCells = svgCells.enter().append("g").attr("class", "matrixcell").attr("transform", (function(_this) {
        return function(d, i) {
          return "translate(" + _this.x(d.x) + ",0)";
        };
      })(this)).on("mouseover", (function(_this) {
        return function(p) {
          return _this._mouseover(p);
        };
      })(this)).on("mouseout", this._mouseout);
      newCells.append("rect").attr("x", 0).attr("width", x.rangeBand()).attr("height", y.rangeBand()).style("fill-opacity", function(d) {
        return z(d.z);
      });
      newCells.append("text").attr("dy", ".32em").attr("y", x.rangeBand() / 2).attr("x", x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.z > 0) {
            return _this.formatCount(d.z);
          } else {
            return '';
          }
        };
      })(this));
      newCells.append("title").text(function(d) {
        return d.title;
      });
      return true;
    };

    MatrixView.prototype._assumePositions = function() {
      var that, transit;
      that = this;
      transit = this.canvas.transition().duration(this.duration);
      transit.selectAll(".matrixrow").attr("transform", function(d, i) {
        return "translate(0," + that.y(d.index) + ")";
      }).selectAll(".matrixcell").attr("x", function(d) {
        return that.x(d.x);
      }).attr("transform", (function(_this) {
        return function(d, i) {
          return "translate(" + that.x(d.x) + ",0)";
        };
      })(this));
      transit.selectAll(".matrixcolumn").attr("transform", function(d, i) {
        return "translate(" + that.x(i) + ")rotate(-90)";
      });
      return true;
    };

    MatrixView.prototype._mouseover = function(p) {
      d3.selectAll(".matrixrow text").classed("matrixActive", function(d, i) {
        return d.index === p.y;
      });
      return d3.selectAll(".matrixcolumn text").classed("matrixActive", function(d, i) {
        return i === p.x;
      });
    };

    MatrixView.prototype._mouseout = function() {
      return d3.selectAll("text").classed("matrixActive", false);
    };

    MatrixView.prototype._classList = function(d) {
      var clsList;
      clsList = ['matrixrow'];
      if (d.selected) {
        clsList.push("selectedRow");
      }
      if (d.assignedGroup != null) {
        clsList.push("groupedRow" + d.assignedGroup);
      }
      return clsList.join(' ');
    };

    MatrixView.prototype.viewAction = function(genomes, argArray) {
      var event, ref;
      event = argArray.shift();
      if (event === 'matrix_sort') {
        this.orderType = argArray[0];
        if (ref = this.orderType, indexOf.call(Object.keys(this.geneOrders), ref) < 0) {
          throw new SuperphyError("Unrecognized order type: " + this.orderType + " in MatrixView viewAction method.");
        }
        this.update(genomes);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in MatrixView viewAction method.");
      }
      return true;
    };

    MatrixView.prototype.dump = function(genomes) {
      var g, len, len1, len2, n, numAlleles, q, ref, ref1, ref2, row, rows, s, w;
      rows = [];
      row = [];
      row.push("#");
      ref = this.geneNodes;
      for (q = 0, len = ref.length; q < len; q++) {
        n = ref[q];
        row.push(n.name);
      }
      rows.push(row.join("\t"));
      ref1 = this.currNodes;
      for (s = 0, len1 = ref1.length; s < len1; s++) {
        g = ref1[s];
        row = [];
        row.push(g.viewname);
        ref2 = this.geneNodes;
        for (w = 0, len2 = ref2.length; w < len2; w++) {
          n = ref2[w];
          numAlleles = this.matrix[g.id][n.id].z;
          row.push(numAlleles);
        }
        rows.push(row.join("\t"));
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: rows.join("\n")
      };
    };

    MatrixView.prototype.updateCSS = function(gset, genomes) {
      var g, genomeList, len, len1, q, ref, ref1, s, svgNodes;
      genomeList = {};
      if (gset["public"] != null) {
        ref = gset["public"];
        for (q = 0, len = ref.length; q < len; q++) {
          g = ref[q];
          genomeList[g] = genomes.public_genomes[g];
        }
      }
      if (gset["private"] != null) {
        ref1 = gset["private"];
        for (s = 0, len1 = ref1.length; s < len1; s++) {
          g = ref1[s];
          genomeList[g] = genomes.private_genomes[g];
        }
      }
      svgNodes = this.canvas.selectAll("g.matrixrow");
      svgNodes.filter(function(d) {
        return genomeList[d.genome] != null;
      }).attr("class", (function(_this) {
        return function(d) {
          g = genomeList[d.genome];
          d.viewname = g.viewname;
          d.selected = (g.isSelected != null) && g.isSelected;
          if (g.assignedGroup != null) {
            d.assignedGroup = g.assignedGroup;
          } else {
            d.assignedGroup = 0;
          }
          return _this._classList(d);
        };
      })(this));
      return true;
    };

    MatrixView.prototype.select = function(genome, isSelected) {
      return true;
    };

    return MatrixView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_table.coffee
   Desc: Attribute Table View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: May 27th, 2013
   */


  /*
   CLASS TableView
    
   Attribute Table view
   
   Always genome-based
   Returns genome ID to redirect/select when genome list item is clicked
   */

  TableView = (function(superClass) {
    extend(TableView, superClass);

    function TableView(parentElem, style1, elNum, tableArgs) {
      this.parentElem = parentElem;
      this.style = style1;
      this.elNum = elNum;
      if ((tableArgs != null) && (tableArgs[0] != null)) {
        this.locusData = tableArgs[0];
      }
      TableView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.sortField = 'displayname';
      this.sortAsc = true;
    }

    TableView.prototype.activeGroup = [];

    TableView.prototype.type = 'table';

    TableView.prototype.elName = 'genome_table';

    TableView.prototype.locusData = null;

    TableView.prototype.update = function(genomes) {
      var activeGroup, divElem, ft, t1, t2, table, tableElem, visibleGenomes;
      tableElem = jQuery("#" + this.elID + " table");
      if (tableElem.length) {
        tableElem.empty();
      } else {
        divElem = jQuery("<div id='" + this.elID + "' class='groups-table superphy-table'/>");
        tableElem = jQuery("<table />").appendTo(divElem);
        jQuery(this.parentElem).append(divElem);
      }
      t1 = new Date();
      table = '';
      table += this._appendHeader(genomes);
      table += '<tbody>';
      visibleGenomes = genomes.pubVisible.concat(genomes.pvtVisible);
      if (this.sortField === 'alleles') {
        if (!this.locusData) {
          throw new SuperphyError("Request to sort by allele count when locusData object is not defined");
        }
        table += this._appendGenomes(this.locusData.sort(visibleGenomes, this.sortAsc, genomes), genomes, this.style);
      } else {
        table += this._appendGenomes(genomes.sort(visibleGenomes, this.sortField, this.sortAsc), genomes, this.style, false);
      }
      table += '</tbody>';
      tableElem.append(table);
      this._actions(tableElem, this.style);
      t2 = new Date();
      ft = t2 - t1;
      console.log('TableView update elapsed time: ' + ft);
      activeGroup = this.activeGroup;
      $('.genome-table-checkbox').each(function() {
        if (genomes.genome(this.value).isSelected) {
          $("#active-group-circle-" + this.value).css('fill', 'lightsteelblue');
          return $(this).parents('tr:first').children().each(function() {
            return $(this).css('background-color', 'lightsteelblue');
          });
        } else {
          return $("#active-group-circle-" + this.value).css('fill', '#fff');
        }
      });
      d3.selectAll('.active-group-symbol').filter(function(d) {
        return activeGroup.indexOf(this.id) > -1;
      }).style('opacity', '1');
      return true;
    };

    TableView.prototype.intro = function() {
      var tableIntro;
      tableIntro = [];
      tableIntro.push({
        element: document.querySelector('.groups-table'),
        intro: "These are the names of the genomes in the database.  Check the boxes to select each genome.",
        position: 'right'
      });
      return tableIntro;
    };

    TableView.prototype._template = function(tmpl, values) {
      var html;
      html = null;
      if (tmpl === 'tr') {
        html = "<tr>" + values.row + "</tr>";
      } else if (tmpl === 'th') {
        html = "<th><a class='genome-table-sort' href='#' data-genomesort='" + values.type + "'>" + values.name + " <i class='fa " + values.sortIcon + "'></i></a></th>";
      } else if (tmpl === 'td') {
        html = "<td>" + values.data + "</td>";
      } else if (tmpl === 'td1_redirect') {
        html = "<td class='" + values.klass + "'>" + values.name + " <a class='genome-table-link' href='#' data-genome='" + values.g + "' title='Genome " + values.shortName + " info'><i class='fa fa-search'></i></a></td>";
      } else if (tmpl === 'td1_select') {
        html = "<td class='" + values.klass + "'><div class='checkbox'><label><input class='checkbox genome-table-checkbox' type='checkbox' value='" + values.g + "' " + values.checked + "/> <svg class='active-group-symbol' id='" + values.g + "' opacity='0' width='15' height='15'><rect y='4' width='11' height='11' style='fill: rgb(70, 130, 180)'></rect> <circle id='active-group-circle-" + values.g + "' r='4' cy='9.5' cx='5.5' style='stroke:steelblue;stroke-width:1.5;'></circle></svg>" + values.name + "</label></div></td>";
      } else if (tmpl === 'spacer') {
        html = "<tr class='genome-table-spacer'><td>---- USER-SUBMITTED GENOMES ----</td></tr>";
      } else {
        throw new SuperphyError("Unknown template type " + tmpl + " in TableView method _template");
      }
      return html;
    };

    TableView.prototype._appendHeader = function(genomes) {
      var i, len, len1, q, ref, s, sortIcon, t, tName, table, v, values;
      table = '<thead><tr>';
      values = [];
      i = -1;
      if (this.sortField === 'displayname') {
        sortIcon = 'fa-sort-asc';
        if (!this.sortAsc) {
          sortIcon = 'fa-sort-desc';
        }
        values[++i] = {
          type: 'displayname',
          name: 'Genome',
          sortIcon: sortIcon
        };
      } else {
        values[++i] = {
          type: 'displayname',
          name: 'Genome',
          sortIcon: 'fa-sort'
        };
      }
      if (this.locusData != null) {
        sortIcon = null;
        if (this.sortField === 'alleles') {
          sortIcon = 'fa-sort-asc';
          if (!this.sortAsc) {
            sortIcon = 'fa-sort-desc';
          }
        } else {
          sortIcon = 'fa-sort';
        }
        values[++i] = {
          type: 'alleles',
          name: 'Copies',
          sortIcon: sortIcon
        };
      }
      ref = genomes.mtypes;
      for (q = 0, len = ref.length; q < len; q++) {
        t = ref[q];
        if (!genomes.visibleMeta[t]) {
          continue;
        }
        tName = genomes.metaMap[t];
        sortIcon = null;
        if (t === this.sortField) {
          sortIcon = 'fa-sort-asc';
          if (!this.sortAsc) {
            sortIcon = 'fa-sort-desc';
          }
        } else {
          sortIcon = 'fa-sort';
        }
        values[++i] = {
          type: t,
          name: tName,
          sortIcon: sortIcon
        };
      }
      for (s = 0, len1 = values.length; s < len1; s++) {
        v = values[s];
        table += this._template('th', v);
      }
      table += '</tr></thead>';
      return table;
    };

    TableView.prototype._appendGenomes = function(visibleG, genomes, style, priv) {
      var checked, cls, d, g, gObj, len, len1, len2, name, q, ref, ref1, row, s, table, thiscls, w;
      cls = this.cssClass();
      table = '';
      for (q = 0, len = visibleG.length; q < len; q++) {
        g = visibleG[q];
        row = '';
        gObj = genomes.genome(g);
        thiscls = cls;
        if (gObj.cssClass != null) {
          thiscls = cls + ' ' + gObj.cssClass;
        }
        name = gObj.meta_array[0];
        if (style === 'redirect') {
          row += this._template('td1_redirect', {
            g: g,
            name: name,
            shortName: gObj.meta_array[0],
            klass: thiscls
          });
          if (this.locusData != null) {
            d = this.locusData.countString(g);
            row += this._template('td', {
              data: d
            });
          }
          ref = gObj.meta_array.slice(1);
          for (s = 0, len1 = ref.length; s < len1; s++) {
            d = ref[s];
            row += this._template('td', {
              data: d
            });
          }
          table += this._template('tr', {
            row: row
          });
        } else if (style === 'select') {
          checked = '';
          if (gObj.isSelected) {
            checked = 'checked';
          }
          row += this._template('td1_select', {
            g: g,
            name: name,
            klass: thiscls,
            checked: checked
          });
          if (this.locusData != null) {
            d = this.locusData.countString(g);
            row += this._template('td', {
              data: d
            });
          }
          ref1 = gObj.meta_array.slice(1);
          for (w = 0, len2 = ref1.length; w < len2; w++) {
            d = ref1[w];
            row += this._template('td', {
              data: d
            });
          }
          table += this._template('tr', {
            row: row
          });
        } else {
          return false;
        }
      }
      return table;
    };

    TableView.prototype._actions = function(tableEl, style) {
      var num;
      num = this.elNum - 1;
      tableEl.find('.genome-table-sort').click(function(e) {
        var sortField;
        e.preventDefault();
        sortField = this.dataset.genomesort;
        return viewController.viewAction(num, 'sort', sortField);
      });
      if (style === 'select') {
        tableEl.find('.genome-table-checkbox').click(function(e) {
          var summary;
          viewController.select(this.value, this.checked);
          if (viewController.views[2].constructor.name === 'SummaryView') {
            summary = viewController.views[2];
            summary.afterSelect(this.checked);
          }
          if ($('#groups_map')[0] != null) {
            if (this.checked != null) {
              viewController.views[0].mapController.allMarkers[this.value].setIcon(viewController.views[0].mapController.circleIconFill);
            } else {
              viewController.views[0].mapController.allMarkers[this.value].setIcon(viewController.views[0].mapController.circleIcon);
            }
            viewController.views[0].matchSelected(this);
          }
          if ($('#strains_map')[0] != null) {
            viewController.views[2].mapController.updateVisible();
            return viewController.views[2].matchSelected(this);
          }
        });
      }
      if (style === 'redirect') {
        return tableEl.find('.genome-table-link').click(function(e) {
          var gid, summary;
          e.preventDefault();
          gid = this.dataset.genome;
          viewController.select(gid, true);
          if (viewController.views[2].constructor.name === 'SummaryView') {
            summary = viewController.views[2];
            return summary.afterSelect(true);
          }
        });
      }
    };

    TableView.prototype.updateActiveGroup = function(usrGrp) {
      var activeGroup, descriptor, g, itemEl, len, q, ref;
      $('.genome-table-checkbox').prop('checked', false);
      $("circle.active-group-symbol").each(function() {
        return $(this).css('fill', '#fff');
      });
      $('.genome-table-checkbox').each(function() {
        return $(this).parents('tr:first').children().css('background-color', '#fff');
      });
      this.activeGroup = usrGrp.active_group.public_list.concat(usrGrp.active_group.private_list);
      activeGroup = this.activeGroup;
      d3.selectAll('.active-group-symbol').filter(function(d) {
        return activeGroup.indexOf(this.id) > -1;
      }).style('opacity', '1');
      d3.selectAll('.active-group-symbol').filter(function(d) {
        return activeGroup.indexOf(this.id) === -1;
      }).style('opacity', '0');
      ref = this.activeGroup;
      for (q = 0, len = ref.length; q < len; q++) {
        g = ref[q];
        itemEl = null;
        if (this.style === 'select') {
          descriptor = "td input[value='" + g + "']";
          itemEl = jQuery(descriptor);
        } else {
          return false;
        }
        itemEl.prop('checked', true);
        $("#active-group-circle-" + g).css('fill', 'lightsteelblue');
        $("input[value=" + g + "]").each(function() {
          return $(this).parents('tr:first').children().css('background-color', 'lightsteelblue');
        });
      }
      return true;
    };

    TableView.prototype.updateCSS = function(gset, genomes) {
      var tableEl;
      tableEl = jQuery("#" + this.elID);
      if (!((tableEl != null) && tableEl.length)) {
        throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call TableView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(tableEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(tableEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    TableView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, dataEl, descriptor, g, itemEl, len, q, thiscls;
      cls = this.cssClass();
      for (q = 0, len = changedG.length; q < len; q++) {
        g = changedG[q];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        dataEl = null;
        if (this.style === 'redirect') {
          descriptor = "td > a[data-genome='" + g + "']";
          itemEl = el.find(descriptor);
          if (!((itemEl != null) && itemEl.length && genomes[g].visible === true)) {
            continue;
          }
          dataEl = itemEl.parent();
        } else if (this.style === 'select') {
          descriptor = "td input[value='" + g + "']";
          itemEl = el.find(descriptor);
          if (!((itemEl != null) && itemEl.length && genomes[g].visible === true)) {
            continue;
          }
          dataEl = itemEl.parents().eq(1);
        } else {
          return false;
        }
        dataEl.attr('class', thiscls);
      }
      return true;
    };

    TableView.prototype.select = function(genome, isSelected) {
      var descriptor, itemEl;
      if (user_groups_menu.runSelect || !user_groups_menu.groupSelected) {
        itemEl = null;
        if (this.style === 'select') {
          descriptor = "td input[value='" + genome + "']";
          itemEl = jQuery(descriptor);
        } else {
          return false;
        }
        itemEl.prop('checked', isSelected);
        if (isSelected) {
          $("#active-group-circle-" + genome).css('fill', 'lightsteelblue');
          $("#map-active-group-circle-" + genome).css('fill', 'lightsteelblue');
          $("#" + genome + ".mapped-genome").css('background-color', 'lightsteelblue');
          $("input[value=" + genome + "]").each(function() {
            $(this).prop('checked', true);
            return $(this).parents('tr:first').children().css('background-color', 'lightsteelblue');
          });
        } else {
          $("#active-group-circle-" + genome).css('fill', '#fff');
          $("#map-active-group-circle-" + genome).css('fill', '#fff');
          $("#" + genome + ".mapped-genome").css('background-color', '#fff');
          $("input[value=" + genome + "]").each(function() {
            $(this).prop('checked', false);
            return $(this).parents('tr:first').children().css('background-color', '#fff');
          });
        }
      }
      return true;
    };

    TableView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, ref, ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var len, q, ref, results1;
        ref = genomes.mtypes;
        results1 = [];
        for (q = 0, len = ref.length; q < len; q++) {
          k = ref[q];
          results1.push(genomes.metaMap[k]);
        }
        return results1;
      })();
      header.unshift("Superphy ID", "Genome name");
      output += "#" + header.join("\t") + "\n";
      ref = genomes.public_genomes;
      for (id in ref) {
        g = ref[id];
        output += id + "\t" + genomes.label(g, fullMeta, "\t") + "\n";
      }
      ref1 = genomes.private_genomes;
      for (id in ref1) {
        g = ref1[id];
        output += id + "\t" + genomes.label(g, fullMeta, "\t") + "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    TableView.prototype.viewAction = function(genomes, argArray) {
      var event;
      event = argArray.shift();
      if (event === 'sort') {
        this._sort(genomes, argArray[0]);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in TableView viewAction method.");
      }
      return true;
    };

    TableView.prototype._sort = function(genomes, field) {
      if (field === this.sortField) {
        if (this.sortAsc) {
          this.sortAsc = false;
        } else {
          this.sortAsc = true;
        }
      } else {
        this.sortField = field;
        this.sortAsc = true;
      }
      console.log([field, this.sortField, this.sortAsc].join(', '));
      return this.update(genomes);
    };

    return TableView;

  })(ViewTemplate);


  /*
  
   File: superphy_map.coffee
   Desc: Objects & functions for managing geospatial views in Superphy
   Author: Akiff Manji akiff.manji@gmail.com
   Date: May 6, 2014
   */

  MapView = (function(superClass) {
    var expandedList;

    extend(MapView, superClass);

    function MapView(parentElem, style1, elNum, genomeController, mapArgs) {
      var buttonEl, input, inputGpEl, manifestRow, map, mapCanvasEl, mapManifest, mapManifestEl, mapRow, mapSearchEl, mapSearchRow, mapSplitLayout, menu, menuRow, resetEl, resetMapView, searchEl;
      this.parentElem = parentElem;
      this.style = style1;
      this.elNum = elNum;
      this.genomeController = genomeController;
      this.mapArgs = mapArgs;
      MapView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.sortField = 'isolation_country';
      this.sortAsc = 'true';
      this.locationMetaFields = {
        'isolation_country': 'Country',
        'isolation_province_state': 'Province/State',
        'isolation_city': 'City'
      };
      mapSplitLayout = jQuery('<div class="map-split-layout row"></div>').appendTo(jQuery(this.parentElem));
      mapSearchEl = jQuery('<div class="map-search-wrapper col-md-9 span6"></div>').appendTo(mapSplitLayout);
      mapSearchRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapSearchEl);
      searchEl = jQuery('<div class="col-md-9 span9"></div>').appendTo(mapSearchRow);
      resetEl = jQuery('<div class="col-md-3 span3"></div>').appendTo(mapSearchRow);
      mapRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapSearchEl);
      map = jQuery('<div class="col-md-12 span12" style="padding-right:0px"></div>').appendTo(mapRow);
      mapCanvasEl = jQuery('<div class="map-canvas"></div>').appendTo(map);
      inputGpEl = jQuery('<div class="input-group input-append"></div></div>').appendTo(searchEl);
      input = jQuery('<input type="text" class="form-control map-search-location input-xlarge" placeholder="Enter a search location">').appendTo(inputGpEl);
      buttonEl = jQuery('<span class="input-group-btn"><button class="btn btn-default map-search-button" type="button"><span class="fa fa-search"></span></button></span>').appendTo(inputGpEl);
      resetMapView = jQuery('<button id="reset-map-view" type="button" class="btn btn-link">Reset Map View</button>').appendTo(resetEl);
      mapManifestEl = jQuery('<div class="map-manifest-wrapper col-md-3 span6"></div>').appendTo(mapSplitLayout);
      menuRow = jQuery('<div class="row"></div>').appendTo(mapManifestEl);
      menu = jQuery('<div class="map-menu col-md-12 span12"></div>').appendTo(menuRow);
      manifestRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapManifestEl);
      mapManifest = jQuery('<div class="col-md-12 span12" style="padding-left:0px;padding-top:40px"></div>').appendTo(manifestRow);
      mapManifestEl = jQuery('<div class="map-manifest"></div>').appendTo(mapManifest);
      this.locationController = this.getLocationController(this.mapArgs[0], this.elNum);
      this.mapController = this.getCartographer(this.mapArgs[0], this.locationController);
      jQuery(this.parentElem).data('views-index', this.elNum);
      resetEl.click((function(_this) {
        return function(e) {
          e.preventDefault();
          return _this.mapController.resetMapView();
        };
      })(this));
    }

    MapView.prototype.activeGroup = [];

    MapView.prototype.bonsaiObj = {};

    MapView.prototype.type = 'map';

    MapView.prototype.elName = 'genome_map';

    MapView.prototype.mapView = true;

    expandedList = [];

    MapView.prototype.update = function(genomes) {
      var aa, ab, divElem, el, ft, i, len, len1, len2, len3, len4, mapManifest, pubVis, pvtVis, q, ref, ref1, ref2, ref3, s, t1, t2, tableElem, unknownsOff, w;
      console.log("Starting MapView Update");
      t1 = new Date();
      $('.map-list').find('.expanded').each(function() {
        return expandedList.push(this.id);
      });
      tableElem = jQuery("#" + this.elID + " table");
      if (tableElem.length) {
        tableElem.empty();
      } else {
        divElem = jQuery("<div id='" + this.elID + "' class='map-table superphy-table' style='margin-left:0px;width:400px'/>");
        tableElem = jQuery("<table />").appendTo(divElem);
        mapManifest = jQuery(".map-manifest").append(divElem);
        $('.map-manifest').prop('id', this.elID + "_list");
      }
      unknownsOff = false;
      $('.map-split-layout').css('max-width', '1500px');
      pubVis = [];
      pvtVis = [];
      if (this.locationController == null) {
        pubVis = genomes.pubVisible;
        pvtVis = genomes.pvtVisible;
      } else {
        this.mapController.resetMarkers();
        ref = this.mapController.visibleLocations;
        for (q = 0, len = ref.length; q < len; q++) {
          i = ref[q];
          if (indexOf.call(genomes.pubVisible, i) >= 0) {
            pubVis.push(i);
          }
        }
        ref1 = this.mapController.visibleLocations;
        for (s = 0, len1 = ref1.length; s < len1; s++) {
          i = ref1[s];
          if (indexOf.call(genomes.pvtVisible, i) >= 0) {
            pvtVis.push(i);
          }
        }
        if (!unknownsOff) {
          ref2 = this.locationController.pubNoLocations;
          for (w = 0, len2 = ref2.length; w < len2; w++) {
            i = ref2[w];
            if (indexOf.call(genomes.pubVisible, i) >= 0) {
              pubVis.push(i);
            }
          }
        }
        if (!unknownsOff) {
          ref3 = this.locationController.pvtNoLocations;
          for (aa = 0, len3 = ref3.length; aa < len3; aa++) {
            i = ref3[aa];
            if (indexOf.call(genomes.pvtVisible, i) >= 0) {
              pvtVis.push(i);
            }
          }
        }
      }
      tableElem.append(this.bonsaiMapList(genomes));
      this._actions(tableElem, this.style);
      for (ab = 0, len4 = expandedList.length; ab < len4; ab++) {
        el = expandedList[ab];
        $("#" + el).removeClass('collapsed');
        $("#" + el).addClass('expanded');
      }
      $('.map-list').bonsai({
        expandAll: false,
        checkboxes: true,
        createInputs: 'checkbox'
      });
      this.bonsaiActions(genomes);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MapView update elapsed time: ' + ft);
      return true;
    };

    MapView.prototype.bonsaiMapList = function(genomes) {
      var aa, ab, ac, ad, ae, af, ag, ah, ai, aj, cities, city, countries, country, country2Sub, g, genome, genomeList, i, len, len1, len10, len11, len12, len2, len3, len4, len5, len6, len7, len8, len9, q, ref, ref1, ref2, ref3, ref4, ref5, s, sub2City, subcountries, subcountry, table, w;
      table = "<ol class='map-list'>";
      country2Sub = {};
      sub2City = {};
      this.bonsaiObj = {};
      ref = this.mapController.visibleLocations;
      for (q = 0, len = ref.length; q < len; q++) {
        g = ref[q];
        genome = genomes.genome(g);
        if (genome.isolation_country != null) {
          country = genome.isolation_country;
        } else {
          country = "zzzN/A";
        }
        if (genome.isolation_province_state != null) {
          subcountry = genome.isolation_province_state;
        } else {
          subcountry = "zzzN/A";
        }
        if (genome.isolation_city != null) {
          city = genome.isolation_city;
        } else {
          city = "zzzN/A";
        }
        country2Sub[country] = [];
        sub2City[subcountry] = [];
      }
      ref1 = this.mapController.visibleLocations;
      for (s = 0, len1 = ref1.length; s < len1; s++) {
        g = ref1[s];
        genome = genomes.genome(g);
        if (genome.isolation_country != null) {
          country = genome.isolation_country;
        } else {
          country = "zzzN/A";
        }
        if (genome.isolation_province_state != null) {
          subcountry = genome.isolation_province_state;
        } else {
          subcountry = "zzzN/A";
        }
        if (genome.isolation_city != null) {
          city = genome.isolation_city;
        } else {
          city = "zzzN/A";
        }
        this.bonsaiObj[country] = {};
        if (!(country2Sub[country].indexOf(subcountry) > -1)) {
          country2Sub[country].push(subcountry);
        }
        if (!(sub2City[subcountry].indexOf(city) > -1)) {
          sub2City[subcountry].push(city);
        }
      }
      ref2 = this.mapController.visibleLocations;
      for (w = 0, len2 = ref2.length; w < len2; w++) {
        g = ref2[w];
        genome = genomes.genome(g);
        if (genome.isolation_country != null) {
          country = genome.isolation_country;
        } else {
          country = "zzzN/A";
        }
        if (genome.isolation_province_state != null) {
          subcountry = genome.isolation_province_state;
        } else {
          subcountry = "zzzN/A";
        }
        if (genome.isolation_city != null) {
          city = genome.isolation_city;
        } else {
          city = "zzzN/A";
        }
        ref3 = country2Sub[country];
        for (aa = 0, len3 = ref3.length; aa < len3; aa++) {
          i = ref3[aa];
          this.bonsaiObj[country][i] = {};
          ref4 = sub2City[i];
          for (ab = 0, len4 = ref4.length; ab < len4; ab++) {
            city = ref4[ab];
            this.bonsaiObj[country][i][city] = [];
          }
        }
      }
      ref5 = this.mapController.visibleLocations;
      for (ac = 0, len5 = ref5.length; ac < len5; ac++) {
        g = ref5[ac];
        genome = genomes.genome(g);
        if (genome.isolation_country != null) {
          country = genome.isolation_country;
        } else {
          country = "zzzN/A";
        }
        if (genome.isolation_province_state != null) {
          subcountry = genome.isolation_province_state;
        } else {
          subcountry = "zzzN/A";
        }
        if (genome.isolation_city != null) {
          city = genome.isolation_city;
        } else {
          city = "zzzN/A";
        }
        if (this.bonsaiObj[country][subcountry][city] != null) {
          this.bonsaiObj[country][subcountry][city].push(g);
        }
      }
      countries = Object.keys(this.bonsaiObj).sort();
      for (ad = 0, len6 = countries.length; ad < len6; ad++) {
        country = countries[ad];
        subcountries = Object.keys(this.bonsaiObj[country]).sort();
        table += "<li id=" + country + " class='country'><label style='font-weight:normal;margin-top:2px;margin-left:5px;'>" + country + "</label>";
        table += "<ol>";
        for (ae = 0, len7 = subcountries.length; ae < len7; ae++) {
          subcountry = subcountries[ae];
          cities = Object.keys(this.bonsaiObj[country][subcountry]).sort();
          if (subcountry !== "zzzN/A") {
            table += "<li id=" + subcountry + " class='subcountry'><label style='font-weight:normal;margin-top:2px;margin-left:5px;'>" + subcountry + "</label>";
            table += "<ol>";
            for (af = 0, len8 = cities.length; af < len8; af++) {
              city = cities[af];
              genomeList = this.bonsaiObj[country][subcountry][city].sort(function(a, b) {
                var A, B, aA, aN, bA, bN, reA, reN;
                A = genomes.genome(a).displayname;
                B = genomes.genome(b).displayname;
                reA = /[^a-zA-Z]/g;
                reN = /[^0-9]/g;
                aA = A.replace(reA, '');
                bA = B.replace(reA, '');
                if (aA === bA) {
                  aN = parseInt(A.replace(reN, ''), 10);
                  bN = parseInt(B.replace(reN, ''), 10);
                  if (aN === bN) {
                    return 0;
                  } else if (aN > bN) {
                    return 1;
                  } else {
                    return -1;
                  }
                } else {
                  if (aA > bA) {
                    return 1;
                  } else {
                    return -1;
                  }
                }
              });
              if (city !== "zzzN/A") {
                table += "<li id=" + city + " class='city'><label style='font-weight:normal;margin-top:2px;margin-left:5px;'>" + city + "</label>";
                table += "<ol>";
                for (ag = 0, len9 = genomeList.length; ag < len9; ag++) {
                  g = genomeList[ag];
                  genome = genomes.genome(g);
                  table += "<li id=" + g + " class='mapped-genome'><div> <svg class='map-active-group-symbol' id='" + g + "' opacity='0' width='15' height='15'> <rect y='4' width='11' height='11' style='fill: rgb(70, 130, 180)'></rect> <circle id='map-active-group-circle-" + g + "' r='4' cy='9.5' cx='5.5' style='stroke:steelblue;stroke-width:1.5;'></circle> </svg><label style='font-weight:normal;margin-top:2px;margin-left:5px;'>" + genome.displayname + "</label></div></li>";
                }
                table += "</ol></li>";
              } else {
                for (ah = 0, len10 = genomeList.length; ah < len10; ah++) {
                  g = genomeList[ah];
                  genome = genomes.genome(g);
                  table += "<li id=" + g + " class='no-city mapped-genome'><div> <svg class='map-active-group-symbol' id='" + g + "' opacity='0' width='15' height='15'> <rect y='4' width='11' height='11' style='fill: rgb(70, 130, 180)'></rect> <circle id='map-active-group-circle-" + g + "' r='4' cy='9.5' cx='5.5' style='stroke:steelblue;stroke-width:1.5;'></circle> </svg><label style='font-weight:normal;margin-top:2px;margin-left:5px;'>" + genome.displayname + "</label></div></li>";
                }
              }
            }
            table += "</ol></li>";
          } else {
            for (ai = 0, len11 = cities.length; ai < len11; ai++) {
              city = cities[ai];
              genomeList = this.bonsaiObj[country][subcountry][city].sort(function(a, b) {
                var A, B, aA, aN, bA, bN, reA, reN;
                A = genomes.genome(a).displayname;
                B = genomes.genome(b).displayname;
                reA = /[^a-zA-Z]/g;
                reN = /[^0-9]/g;
                aA = A.replace(reA, '');
                bA = B.replace(reA, '');
                if (aA === bA) {
                  aN = parseInt(A.replace(reN, ''), 10);
                  bN = parseInt(B.replace(reN, ''), 10);
                  if (aN === bN) {
                    return 0;
                  } else if (aN > bN) {
                    return 1;
                  } else {
                    return -1;
                  }
                } else {
                  if (aA > bA) {
                    return 1;
                  } else {
                    return -1;
                  }
                }
              });
              for (aj = 0, len12 = genomeList.length; aj < len12; aj++) {
                g = genomeList[aj];
                genome = genomes.genome(g);
                table += "<li id=" + g + " class='no-subcountry mapped-genome'><div> <svg class='map-active-group-symbol' id='" + g + "' opacity='0' width='15' height='15'> <rect y='4' width='11' height='11' style='fill: rgb(70, 130, 180)'></rect> <circle id='map-active-group-circle-" + g + "' r='4' cy='9.5' cx='5.5' style='stroke:steelblue;stroke-width:1.5;'></circle> </svg><label style='font-weight:normal;margin-top:2px;margin-left:5px;'>" + genome.displayname + "</label></div></li>";
              }
            }
          }
        }
        table += "</ol></li>";
      }
      table = table + "</ol>";
      return table;
    };

    MapView.prototype.matchSelected = function(input) {
      var checkbox, children, gGChildren, grandChildren, grandParent, grandParentCBox, greatGrand, greatGrandCBox, mapGenome, numChecked1, numChecked2, numChecked3, parent, parentCBox;
      mapGenome = $("#" + input.value + ".mapped-genome");
      checkbox = mapGenome.find('input[type=checkbox]:first');
      if (input.checked) {
        mapGenome.addClass('selected');
        checkbox.prop('checked', true);
      } else {
        mapGenome.removeClass('selected');
        checkbox.prop('checked', false);
      }
      parent = mapGenome.parent().closest('li');
      parentCBox = parent.find('input[type=checkbox]:first');
      if (parent.hasClass('city')) {
        grandParent = mapGenome.closest('.subcountry');
        grandParentCBox = grandParent.find('input[type=checkbox]:first');
        greatGrand = mapGenome.closest('.country');
        greatGrandCBox = greatGrand.find('input[type=checkbox]:first');
      }
      if (parent.hasClass('subcountry')) {
        grandParent = mapGenome.closest('.country');
        grandParentCBox = grandParent.find('input[type=checkbox]:first');
      }
      if (parent != null) {
        children = parent.find('.mapped-genome');
      }
      if (grandParent != null) {
        grandChildren = grandParent.find('.mapped-genome');
      }
      if (greatGrand != null) {
        gGChildren = greatGrand.find('.mapped-genome');
      }
      if (parent != null) {
        numChecked1 = children.filter(function() {
          return $(this).hasClass('selected');
        }).length;
      }
      if (grandParent != null) {
        numChecked2 = grandChildren.filter(function() {
          return $(this).hasClass('selected');
        }).length;
      }
      if (greatGrand != null) {
        numChecked3 = gGChildren.filter(function() {
          return $(this).hasClass('selected');
        }).length;
      }
      if (children.length) {
        if (numChecked1 === 0) {
          parentCBox.prop('indeterminate', false);
          parentCBox.prop('checked', false);
          if (grandParent != null) {
            grandParentCBox.prop('indeterminate', false);
            grandParentCBox.prop('checked', false);
          }
          if (greatGrand != null) {
            greatGrandCBox.prop('indeterminate', false);
            greatGrandCBox.prop('checked', false);
          }
        } else if (numChecked1 === children.length) {
          parentCBox.prop('indeterminate', false);
          parentCBox.prop('checked', true);
          if (grandParent != null) {
            if (numChecked2 === grandChildren.length) {
              grandParentCBox.prop('indeterminate', false);
              grandParentCBox.prop('checked', true);
            } else if (numChecked2 < grandChildren.length) {
              grandParentCBox.prop('indeterminate', true);
              grandParentCBox.prop('checked', false);
            }
          }
          if (greatGrand != null) {
            if (numChecked3 === gGChildren.length) {
              greatGrandCBox.prop('indeterminate', false);
              greatGrandCBox.prop('checked', true);
            } else if (numChecked3 < gGChildren.length) {
              greatGrandCBox.prop('indeterminate', true);
              greatGrandCBox.prop('checked', false);
            }
          }
        } else {
          parentCBox.prop('indeterminate', true);
          if (grandParent != null) {
            grandParentCBox.prop('indeterminate', true);
          }
          if (greatGrand != null) {
            greatGrandCBox.prop('indeterminate', true);
          }
        }
      } else {
        parentCBox.prop('indeterminate', false);
        if (grandParent != null) {
          grandParentCBox.prop('indeterminate', false);
        }
        if (greatGrand != null) {
          greatGrandCBox.prop('indeterminate', false);
        }
      }
      return true;
    };

    MapView.prototype.bonsaiActions = function(genomes) {
      var activeGroup, children, that;
      activeGroup = this.activeGroup;
      that = this;
      $('.country, .subcountry, .city').each(function() {
        var checkbox;
        checkbox = $(this).find('input[type=checkbox]:first');
        if (checkbox.is(':checked')) {
          checkbox.prop('checked', false);
        }
        if (checkbox.is(':indeterminate')) {
          return checkbox.prop('indeterminate', false);
        }
      });
      $('.mapped-genome').each(function() {
        if ($(this).find('input[type=checkbox]:first').is(':checked')) {
          $(this).find('input[type=checkbox]:first').prop('checked', false);
        }
        $(this).find('input[type=checkbox]:first').val(this.id);
        if (activeGroup.indexOf(this.id) > -1) {
          return $(this).addClass('in-active-group');
        } else {
          return $(this).removeClass('in-active-group');
        }
      });
      $('.mapped-genome').find('input[type=checkbox]:first').click(function(e) {
        var summary;
        viewController.select(this.value, this.checked);
        if (viewController.views[2].constructor.name === 'SummaryView') {
          summary = viewController.views[2];
          summary.afterSelect(this.checked);
        }
        if (this.checked) {
          $(this).parent().addClass('selected');
          $(this).parent().css('background-color', 'lightsteelblue');
          if (that.activeGroup.indexOf(this.value) > -1) {
            return that.mapController.allMarkers[this.value].setIcon(that.mapController.squareIconFill);
          } else {
            return that.mapController.allMarkers[this.value].setIcon(that.mapController.circleIconFill);
          }
        } else {
          $(this).parent().removeClass('selected');
          $(this).parent().css('background-color', '#fff');
          if (that.activeGroup.indexOf(this.value) > -1) {
            return that.mapController.allMarkers[this.value].setIcon(that.mapController.squareIcon);
          } else {
            return that.mapController.allMarkers[this.value].setIcon(that.mapController.circleIcon);
          }
        }
      });
      children = [];
      $('.country, .subcountry, .city').find('input[type=checkbox]:first').click(function(e) {
        var c, len, len1, q, ref, s, summary, v;
        children = $(this).parent().find('.mapped-genome');
        for (q = 0, len = children.length; q < len; q++) {
          c = children[q];
          ref = viewController.views;
          for (s = 0, len1 = ref.length; s < len1; s++) {
            v = ref[s];
            v.select(c.id, this.checked);
          }
          if (this.checked) {
            genomes.genome(c.id).isSelected = true;
            if (that.activeGroup.indexOf(c.id) > -1) {
              that.mapController.allMarkers[c.id].setIcon(that.mapController.squareIconFill);
            } else {
              that.mapController.allMarkers[c.id].setIcon(that.mapController.circleIconFill);
            }
          } else {
            genomes.genome(c.id).isSelected = false;
            if (that.activeGroup.indexOf(c.id) > -1) {
              that.mapController.allMarkers[c.id].setIcon(that.mapController.squareIcon);
            } else {
              that.mapController.allMarkers[c.id].setIcon(that.mapController.circleIcon);
            }
          }
        }
        if (viewController.views[2].constructor.name === 'SummaryView') {
          summary = viewController.views[2];
          return summary.afterSelect(this.checked);
        }
      });
      $('.mapped-genome').each(function() {
        if (genomes.genome(this.id).isSelected) {
          $(this).addClass('selected');
          $("#map-active-group-circle-" + this.id).css('fill', 'lightsteelblue');
          return $(this).css('background-color', 'lightsteelblue');
        } else {
          $("#map-active-group-circle-" + this.id).css('fill', '#fff');
          $(this).css('background-color', '#fff');
          return $(this).removeClass('selected');
        }
      });
      children = [];
      $('.in-active-group, .selected').each(function() {
        var gGChildren, grandChildren, grandParent, grandParentCBox, greatGrand, greatGrandCBox, numChecked1, numChecked2, numChecked3, parent, parentCBox, self;
        self = $(this).find('input[type=checkbox]:first');
        if ($(this).hasClass('selected')) {
          self.prop('checked', true);
        } else {
          self.prop('checked', false);
        }
        parent = $(this).parent().closest('li');
        parentCBox = parent.find('input[type=checkbox]:first');
        if (parent.hasClass('city')) {
          grandParent = $(this).closest('.subcountry');
          grandParentCBox = grandParent.find('input[type=checkbox]:first');
          greatGrand = $(this).closest('.country');
          greatGrandCBox = greatGrand.find('input[type=checkbox]:first');
        }
        if (parent.hasClass('subcountry')) {
          grandParent = $(this).closest('.country');
          grandParentCBox = grandParent.find('input[type=checkbox]:first');
        }
        if (parent != null) {
          children = parent.find('.mapped-genome');
        }
        if (grandParent != null) {
          grandChildren = grandParent.find('.mapped-genome');
        }
        if (greatGrand != null) {
          gGChildren = greatGrand.find('.mapped-genome');
        }
        if (parent != null) {
          numChecked1 = children.filter(function() {
            return $(this).hasClass('selected');
          }).length;
        }
        if (grandParent != null) {
          numChecked2 = grandChildren.filter(function() {
            return $(this).hasClass('selected');
          }).length;
        }
        if (greatGrand != null) {
          numChecked3 = gGChildren.filter(function() {
            return $(this).hasClass('selected');
          }).length;
        }
        if (children.length) {
          if (numChecked1 === 0) {
            parentCBox.prop('indeterminate', false);
            parentCBox.prop('checked', false);
            if (grandParent != null) {
              grandParentCBox.prop('indeterminate', false);
              grandParentCBox.prop('checked', false);
            }
            if (greatGrand != null) {
              greatGrandCBox.prop('indeterminate', false);
              return greatGrandCBox.prop('checked', false);
            }
          } else if (numChecked1 === children.length) {
            parentCBox.prop('indeterminate', false);
            parentCBox.prop('checked', true);
            if (grandParent != null) {
              if (numChecked2 === grandChildren.length) {
                grandParentCBox.prop('indeterminate', false);
                grandParentCBox.prop('checked', true);
              } else if (numChecked2 < grandChildren.length) {
                grandParentCBox.prop('indeterminate', true);
                grandParentCBox.prop('checked', false);
              }
            }
            if (greatGrand != null) {
              if (numChecked3 === gGChildren.length) {
                greatGrandCBox.prop('indeterminate', false);
                return greatGrandCBox.prop('checked', true);
              } else if (numChecked3 < gGChildren.length) {
                greatGrandCBox.prop('indeterminate', true);
                return greatGrandCBox.prop('checked', false);
              }
            }
          } else {
            parentCBox.prop('indeterminate', true);
            if (grandParent != null) {
              grandParentCBox.prop('indeterminate', true);
            }
            if (greatGrand != null) {
              return greatGrandCBox.prop('indeterminate', true);
            }
          }
        } else {
          parentCBox.prop('indeterminate', false);
          if (grandParent != null) {
            grandParentCBox.prop('indeterminate', false);
          }
          if (greatGrand != null) {
            return greatGrandCBox.prop('indeterminate', false);
          }
        }
      });
      d3.selectAll('.map-active-group-symbol').filter(function(d) {
        return activeGroup.indexOf(this.id) > -1;
      }).style('opacity', '1');
      return true;
    };

    MapView.prototype.intro = function() {
      var mapIntro;
      mapIntro = [];
      mapIntro.push({
        element: document.querySelector('.map-canvas'),
        intro: "This map displays the location of genomes around the world.",
        position: 'right'
      });
      mapIntro.push({
        element: document.querySelector('.map-manifest'),
        intro: "The genomes corresponding to locations on the map are shown here.  Only genomes with location data will appear here.  Check the boxes to select a region or a specific genome.",
        position: 'left'
      });
      mapIntro.push({
        element: document.querySelector('.map-search-location'),
        intro: "Input a location here to see genomes found in that region.",
        position: 'right'
      });
      mapIntro.push({
        element: document.querySelector('#reset-map-view'),
        intro: "Clicking this will reset the map view.",
        position: 'bottom'
      });
      return mapIntro;
    };

    MapView.prototype._appendHeader = function(genomes) {
      var i, len, q, ref, sortIcon, table, tk, tv, v, values;
      table = '<thead><tr>';
      values = [];
      i = -1;
      if (this.sortField === 'displayname') {
        sortIcon = 'fa-sort-asc';
        if (!this.sortAsc) {
          sortIcon = 'fa-sort-desc';
        }
        values[++i] = {
          type: 'displayname',
          name: 'Genome',
          sortIcon: sortIcon
        };
      } else {
        values[++i] = {
          type: 'displayname',
          name: 'Genome',
          sortIcon: 'fa-sort'
        };
      }
      ref = this.locationMetaFields;
      for (tk in ref) {
        tv = ref[tk];
        sortIcon = null;
        if (tk === this.sortField) {
          sortIcon = 'fa-sort-asc';
          if (!this.sortAsc) {
            sortIcon = 'fa-sort-desc';
          }
        } else {
          sortIcon = 'fa-sort';
        }
        values[++i] = {
          type: tk,
          name: tv,
          sortIcon: sortIcon
        };
      }
      for (q = 0, len = values.length; q < len; q++) {
        v = values[q];
        table += this._template('th', v);
      }
      table += '</tr></thead>';
      return table;
    };

    MapView.prototype._appendGenomes = function(visibleG, genomes, style, priv) {
      var checked, cls, g, gObj, k, len, location, name, q, ref, ref1, ref2, ref3, ref4, ref5, row, table, thiscls, v;
      cls = this.cssClass();
      table = '';
      if (priv && visibleG.length) {
        table += this._template('spacer', null);
      }
      for (q = 0, len = visibleG.length; q < len; q++) {
        g = visibleG[q];
        row = '';
        gObj = genomes[g];
        thiscls = cls;
        if (gObj.cssClass != null) {
          thiscls = cls + ' ' + gObj.cssClass;
        }
        name = gObj.meta_array[0];
        if (this.locusData != null) {
          name += this.locusData.genomeString(g);
        }
        if (gObj.isolation_location != null) {
          location = true;
        }
        if (gObj.isolation_location == null) {
          location = false;
        }
        if (style === 'redirect') {
          row += this._template('td1_redirect', {
            g: g,
            name: name,
            shortName: gObj.meta_array[0],
            klass: thiscls
          });
          ref = this.locationMetaFields;
          for (k in ref) {
            v = ref[k];
            if (location) {
              row += this._template('td1_location', {
                location: (ref1 = this.mapController.allMarkers[g][k]) != null ? ref1 : 'NA'
              });
            }
          }
          ref2 = this.locationMetaFields;
          for (k in ref2) {
            v = ref2[k];
            if (!location) {
              row += this._template('td1_nolocation', {
                location: 'Unknown'
              });
            }
          }
          table += this._template('tr', {
            row: row
          });
        } else if (style === 'select') {
          checked = '';
          if (gObj.isSelected) {
            checked = 'checked';
          }
          row += this._template('td1_select', {
            g: g,
            name: name,
            klass: thiscls,
            checked: checked
          });
          ref3 = this.locationMetaFields;
          for (k in ref3) {
            v = ref3[k];
            if (location) {
              row += this._template('td1_location', {
                location: (ref4 = this.mapController.allMarkers[g][k]) != null ? ref4 : 'NA'
              });
            }
          }
          ref5 = this.locationMetaFields;
          for (k in ref5) {
            v = ref5[k];
            if (!location) {
              row += this._template('td1_nolocation', {
                location: 'Unknown'
              });
            }
          }
          table += this._template('tr', {
            row: row
          });
        } else {
          return false;
        }
      }
      return table;
    };

    MapView.prototype._template = function(tmpl, values) {
      var html;
      html = null;
      if (tmpl === 'tr') {
        html = "<tr>" + values.row + "</tr>";
      } else if (tmpl === 'th') {
        html = "<th><a class='genome-table-sort' href='#' data-genomesort='" + values.type + "'>" + values.name + " <i class='fa " + values.sortIcon + "'></i></a></th>";
      } else if (tmpl === 'td') {
        html = "<td>" + values.data + "</td>";
      } else if (tmpl === 'td1_redirect') {
        html = "<td class='" + values.klass + "'>" + values.name + " <a class='genome-table-link' href='#' data-genome='" + values.g + "' title='Genome " + values.shortName + " info'><i class='fa fa-search'></i></a></td>";
      } else if (tmpl === 'td1_select') {
        html = "<td class='" + values.klass + "'><div class='checkbox'><label><input class='checkbox genome-table-checkbox map-genome' type='checkbox' value='" + values.g + "' " + values.checked + "/> <svg class='map-active-group-symbol' id='" + values.g + "' opacity='0' width='15' height='15'><rect y='4' width='11' height='11' style='fill: rgb(70, 130, 180)'></rect> <circle id='map-active-group-circle-" + values.g + "' r='4' cy='9.5' cx='5.5' style='stroke:steelblue;stroke-width:1.5;'></circle></svg>" + values.name + "</label></div></td>";
      } else if (tmpl === 'td1_location') {
        html = "<td>" + values.location + "</td>";
      } else if (tmpl === 'td1_nolocation') {
        html = "<td class='no-loc'>" + values.location + "</td>";
      } else if (tmpl === 'spacer') {
        html = "<tr class='genome-table-spacer'><td>---- USER-SUBMITTED GENOMES ----</td></tr>";
      } else {
        throw new SuperphyError("Unknown template type " + tmpl + " in TableView method _template");
      }
      return html;
    };

    MapView.prototype.updateActiveGroup = function(usrGrp) {
      var activeGroup, children, g, genomes, len, marker, marker_id, q, ref, ref1;
      this.activeGroup = usrGrp.active_group.public_list.concat(usrGrp.active_group.private_list);
      activeGroup = this.activeGroup;
      genomes = this.genomeController;
      ref = this.mapController.allMarkers;
      for (marker_id in ref) {
        marker = ref[marker_id];
        if ((marker.getIcon()).fillColor === "steelblue") {
          marker.setIcon(this.mapController.circleIcon);
        }
      }
      ref1 = this.activeGroup;
      for (q = 0, len = ref1.length; q < len; q++) {
        g = ref1[q];
        if (this.mapController.allMarkers[g] != null) {
          this.mapController.allMarkers[g].setIcon(this.mapController.squareIconFill);
        }
      }
      $('.mapped-genome').each(function() {
        var checkbox;
        checkbox = $(this).find('input[type=checkbox]:first');
        if (checkbox.is(':checked')) {
          checkbox.prop('checked', false);
        }
        if (activeGroup.indexOf(this.id) > -1) {
          $(this).addClass('in-active-group selected');
          checkbox.prop('checked', true);
          $("#map-active-group-circle-" + this.id).css('fill', 'lightsteelblue');
          return $(this).css('background-color', 'lightsteelblue');
        } else {
          $(this).removeClass('in-active-group selected');
          $("#map-active-group-circle-" + this.id).css('fill', '#fff');
          return $(this).css('background-color', '#fff');
        }
      });
      $('.country, .subcountry, .city').each(function() {
        var checkbox;
        checkbox = $(this).find('input[type=checkbox]:first');
        if (checkbox.is(':checked')) {
          checkbox.prop('checked', false);
        }
        if (checkbox.is(':indeterminate')) {
          return checkbox.prop('indeterminate', false);
        }
      });
      children = [];
      $('.in-active-group').each(function() {
        var gGChildren, grandChildren, grandParent, grandParentCBox, greatGrand, greatGrandCBox, numChecked1, numChecked2, numChecked3, parent, parentCBox;
        parent = $(this).parent().closest('li');
        parentCBox = parent.find('input[type=checkbox]:first');
        if (parent.hasClass('city')) {
          grandParent = $(this).closest('.subcountry');
          grandParentCBox = grandParent.find('input[type=checkbox]:first');
          greatGrand = $(this).closest('.country');
          greatGrandCBox = greatGrand.find('input[type=checkbox]:first');
        }
        if (parent.hasClass('subcountry')) {
          grandParent = $(this).closest('.country');
          grandParentCBox = grandParent.find('input[type=checkbox]:first');
        }
        if (parent != null) {
          children = parent.find('.mapped-genome');
        }
        if (grandParent != null) {
          grandChildren = grandParent.find('.mapped-genome');
        }
        if (greatGrand != null) {
          gGChildren = greatGrand.find('.mapped-genome');
        }
        if (parent != null) {
          numChecked1 = children.filter(function() {
            return $(this).hasClass('in-active-group');
          }).length;
        }
        if (grandParent != null) {
          numChecked2 = grandChildren.filter(function() {
            return $(this).hasClass('in-active-group');
          }).length;
        }
        if (greatGrand != null) {
          numChecked3 = gGChildren.filter(function() {
            return $(this).hasClass('in-active-group');
          }).length;
        }
        if (children.length) {
          if (numChecked1 === 0) {
            parentCBox.prop('indeterminate', false);
            parentCBox.prop('checked', false);
            if (grandParent != null) {
              grandParentCBox.prop('indeterminate', false);
              grandParentCBox.prop('checked', false);
            }
            if (greatGrand != null) {
              greatGrandCBox.prop('indeterminate', false);
              return greatGrandCBox.prop('checked', false);
            }
          } else if (numChecked1 === children.length) {
            parentCBox.prop('indeterminate', false);
            parentCBox.prop('checked', true);
            if (grandParent != null) {
              if (numChecked2 === grandChildren.length) {
                grandParentCBox.prop('indeterminate', false);
                grandParentCBox.prop('checked', true);
              } else if (numChecked2 < grandChildren.length) {
                grandParentCBox.prop('indeterminate', true);
                grandParentCBox.prop('checked', false);
              }
            }
            if (greatGrand != null) {
              if (numChecked3 === gGChildren.length) {
                greatGrandCBox.prop('indeterminate', false);
                return greatGrandCBox.prop('checked', true);
              } else if (numChecked3 < gGChildren.length) {
                greatGrandCBox.prop('indeterminate', true);
                return greatGrandCBox.prop('checked', false);
              }
            }
          } else {
            parentCBox.prop('indeterminate', true);
            if (grandParent != null) {
              grandParentCBox.prop('indeterminate', true);
            }
            if (greatGrand != null) {
              return greatGrandCBox.prop('indeterminate', true);
            }
          }
        } else {
          parentCBox.prop('indeterminate', false);
          if (grandParent != null) {
            grandParentCBox.prop('indeterminate', false);
          }
          if (greatGrand != null) {
            return greatGrandCBox.prop('indeterminate', false);
          }
        }
      });
      d3.selectAll('.map-active-group-symbol').filter(function(d) {
        return activeGroup.indexOf(this.id) === -1;
      }).style('opacity', '0');
      d3.selectAll('.map-active-group-symbol').filter(function(d) {
        return activeGroup.indexOf(this.id) > -1;
      }).style('opacity', '1');
      return true;
    };

    MapView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, ref, ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var results1;
        results1 = [];
        for (k in fullMeta) {
          results1.push(genomes.metaMap[k]);
        }
        return results1;
      })();
      header.unshift("Genome name");
      header.push("Location");
      output += "#" + header.join("\t") + "\n";
      ref = genomes.public_genomes;
      for (id in ref) {
        g = ref[id];
        output += genomes.label(g, fullMeta, "\t") + "\t";
        output += g.isolation_location ? JSON.parse(g.isolation_location[0]).formatted_address : "N/A";
        output += "\n";
      }
      ref1 = genomes.private_genomes;
      for (id in ref1) {
        g = ref1[id];
        output += genomes.label(g, fullMeta, "\t") + "\t";
        output += g.isolation_location ? JSON.parse(g.isolation_location[0]).formatted_address : "N/A";
        output += "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    MapView.prototype.getCartographer = function(mapType, locationController) {
      var cartographTypes, cartographer, elem;
      elem = this.parentElem;
      mapType = mapType != null ? mapType : 'base';
      cartographTypes = {
        'base': (function(_this) {
          return function() {
            return new Cartographer(jQuery(elem), [locationController]);
          };
        })(this),
        'dot': (function(_this) {
          return function() {
            return new DotCartographer(jQuery(elem), [locationController]);
          };
        })(this),
        'satellite': (function(_this) {
          return function() {
            return new SatelliteCartographer(jQuery(elem), [locationController]);
          };
        })(this),
        'infoSatellite': (function(_this) {
          return function() {
            return new InfoSatelliteCartographer(jQuery(elem), [locationController, _this.mapArgs[1]]);
          };
        })(this),
        'geophy': (function(_this) {
          return function() {
            return new GeophyCartographer(jQuery(elem), [locationController, _this.mapArgs[1]]);
          };
        })(this)
      };
      cartographer = cartographTypes[mapType]();
      cartographer.cartograPhy();
      return cartographer;
    };

    MapView.prototype.getLocationController = function(mapType, viewNum) {
      var cartographTypes, controller;
      cartographTypes = {
        'base': (function(_this) {
          return function() {
            return null;
          };
        })(this),
        'dot': (function(_this) {
          return function() {
            return null;
          };
        })(this),
        'satellite': (function(_this) {
          return function() {
            return new LocationController(_this.genomeController, _this.parentElem, viewNum);
          };
        })(this),
        'infoSatellite': (function(_this) {
          return function() {
            return new LocationController(_this.genomeController, _this.parentElem, viewNum);
          };
        })(this),
        'geophy': (function(_this) {
          return function() {
            return new LocationController(_this.genomeController, _this.parentElem, viewNum);
          };
        })(this)
      };
      controller = cartographTypes[mapType]();
      return controller;
    };

    return MapView;

  })(TableView);


  /*
    CLASS SelectionMapView
   */

  SelectionMapView = (function(superClass) {
    extend(SelectionMapView, superClass);

    function SelectionMapView(selParentElem, selStyle, selElNum, selGenomeController, selMapArgs) {
      this.selParentElem = selParentElem;
      this.selStyle = selStyle;
      this.selElNum = selElNum;
      this.selGenomeController = selGenomeController;
      this.selMapArgs = selMapArgs;
      SelectionMapView.__super__.constructor.call(this, this.selParentElem, this.selStyle, this.selElNum, this.selGenomeController, this.selMapArgs);
    }

    SelectionMapView.prototype.update = function(genomes) {
      var selectedEl, selectedElParent;
      SelectionMapView.__super__.update.apply(this, arguments);
      selectedEl = jQuery('.genome_map_item a[data-genome="' + this.mapController.selectedGenomeId + '"]');
      selectedElParent = selectedEl.parent();
      selectedElParent.prepend('<p style="padding:0px;margin:0px">Target genome: </p>');
      selectedElParent.css({
        "font-weight": "bold",
        "margin-bottom": "5px"
      });
      jQuery('.superphy-table table tbody').prepend('<tr>' + selectedElParent + '</tr>');
      selectedEl.remove();
      return true;
    };

    return SelectionMapView;

  })(MapView);


  /*
    CLASS Cartographer
  
    Handles map drawing and location searching
   */

  Cartographer = (function() {
    function Cartographer(cartographDiv, cartograhOpt) {
      this.cartographDiv = cartographDiv;
      this.cartograhOpt = cartograhOpt;
      this.pinPoint = bind(this.pinPoint, this);
      this.defaultCenter = new google.maps.LatLng(-0.000, 0.000);
      this.mapOptions = {
        center: this.defaultCenter,
        zoom: 1,
        streetViewControl: false,
        mapTypeId: google.maps.MapTypeId.ROADMAP
      };
      this.mapBounds;
      this.map = new google.maps.Map(jQuery(this.cartographDiv).find('.map-canvas')[0], this.mapOptions);
      jQuery('.map-search-button').bind('click', {
        context: this
      }, this.pinPoint);
    }

    Cartographer.prototype.cartograPhy = function() {
      return true;
    };

    Cartographer.prototype.pinPoint = function(e) {
      var queryLocation;
      e.preventDefault();
      queryLocation = jQuery('.map-search-location').val();
      jQuery.ajax({
        type: "POST",
        url: '/superphy/strains/geocode',
        data: {
          'address': queryLocation
        }
      }).done((function(_this) {
        return function(data) {
          var bounds, northEast, results, southWest;
          results = JSON.parse(data);
          _this.map.setCenter(results.geometry.location);
          northEast = new google.maps.LatLng(results.geometry.viewport.northeast.lat, results.geometry.viewport.northeast.lng);
          southWest = new google.maps.LatLng(results.geometry.viewport.southwest.lat, results.geometry.viewport.southwest.lng);
          bounds = new google.maps.LatLngBounds(southWest, northEast);
          return _this.map.fitBounds(bounds);
        };
      })(this)).fail((function() {
        return alert("Could not get coordinates for: " + queryLocation + ". Please enter in another search query");
      }));
      return true;
    };

    Cartographer.prototype.resetMapView = function() {
      this.map.setZoom(1);
      this.map.setCenter(this.defaultCenter);
      return true;
    };

    return Cartographer;

  })();


  /*
    CLASS DotCartographer
  
    Handles map drawing and location searching
    Allows for pinpointing locations
   */

  DotCartographer = (function(superClass) {
    extend(DotCartographer, superClass);

    function DotCartographer(dotCartographDiv, dotCartograhOpt) {
      this.dotCartographDiv = dotCartographDiv;
      this.dotCartograhOpt = dotCartograhOpt;
      this.resetMap = bind(this.resetMap, this);
      this.pinPoint = bind(this.pinPoint, this);
      DotCartographer.__super__.constructor.call(this, this.dotCartographDiv, this.dotCartograhOpt);
    }

    DotCartographer.prototype.latLng = null;

    DotCartographer.prototype.marker = null;

    DotCartographer.prototype.cartograPhy = function() {
      DotCartographer.__super__.cartograPhy.apply(this, arguments);
      google.maps.event.addListener(this.map, 'click', (function(_this) {
        return function(event) {
          return _this.plantFlag(event.latLng);
        };
      })(this));
      return true;
    };

    DotCartographer.prototype.pinPoint = function(e) {
      var queryLocation;
      e.preventDefault();
      queryLocation = jQuery('.map-search-location').val();
      jQuery.ajax({
        type: "POST",
        url: '/superphy/strains/geocode',
        data: {
          'address': queryLocation
        }
      }).done((function(_this) {
        return function(data) {
          var bounds, northEast, results, southWest;
          results = JSON.parse(data);
          _this.map.setCenter(results.geometry.location);
          northEast = new google.maps.LatLng(results.geometry.viewport.northeast.lat, results.geometry.viewport.northeast.lng);
          southWest = new google.maps.LatLng(results.geometry.viewport.southwest.lat, results.geometry.viewport.southwest.lng);
          bounds = new google.maps.LatLngBounds(southWest, northEast);
          _this.map.fitBounds(bounds);
          _this.latLng = results.geometry.location;
          return _this.plantFlag(_this.latLng, _this.map);
        };
      })(this)).fail((function() {
        return alert("Could not get coordinates for: " + queryLocation + ". Please enter in another search query");
      }));
      return true;
    };

    DotCartographer.prototype.plantFlag = function(location) {
      if (this.marker != null) {
        this.marker.setMap(null);
      }
      this.marker = new google.maps.Marker({
        position: location,
        map: this.map
      });
      this.marker.setTitle(this.marker.getPosition().toString());
      this.map.panTo(this.marker.getPosition());
      return true;
    };

    DotCartographer.prototype.resetMap = function() {
      var c, x;
      x = this.map.getZoom();
      c = this.map.getCenter();
      google.maps.event.trigger(this.map, 'resize');
      this.map.setZoom(x);
      this.map.setCenter(c);
      return true;
    };

    return DotCartographer;

  })(Cartographer);


  /*
    CLASS SatelliteCartographer
  
    Handles map drawing and location searching
    Displays multiple markers on map
    Handles marker clustering
    Displays list of genomes 
    Alters genome list when map viewport changes
   */

  SatelliteCartographer = (function(superClass) {
    extend(SatelliteCartographer, superClass);

    function SatelliteCartographer(satelliteCartographDiv, satelliteCartograhOpt) {
      this.satelliteCartographDiv = satelliteCartographDiv;
      this.satelliteCartograhOpt = satelliteCartograhOpt;
      this.resetMarkers = bind(this.resetMarkers, this);
      this.resetMap = bind(this.resetMap, this);
      SatelliteCartographer.__super__.constructor.call(this, this.satelliteCartographDiv, this.satelliteCartograhOpt);
      this.circleIcon = '../App/Pictures/red_circle.png';

      /*
      @circleIcon = {
        path: google.maps.SymbolPath.CIRCLE
        fillColor: '#FF0000'
        fillOpacity: 0
        scale: 5
        strokeColor: '#FF0000'
        strokeWeight: 2
        }
       */
      this.circleIconFill = '../App/Pictures/red_circle_fill.png';

      /*
      @circleIconFill = {
        path: google.maps.SymbolPath.CIRCLE
        fillColor: '#FF0000'
        fillOpacity: 0.8
        scale: 5
        strokeColor: '#FF0000'
        strokeWeight: 2
        }
       */
      this.squareIcon = {
        path: 'M -1 -1 L 1 -1 L 1 1 L -1 1 z',
        fillColor: 'steelblue',
        fillOpacity: 0,
        scale: 5,
        strokeColor: 'steelblue',
        strokeWeight: 2
      };
      this.squareIconFill = {
        path: 'M -1 -1 L 1 -1 L 1 1 L -1 1 z',
        fillColor: 'steelblue',
        fillOpacity: 0.8,
        scale: 5,
        strokeColor: 'steelblue',
        strokeWeight: 2
      };
      this.locationController = this.satelliteCartograhOpt[0];
      this.allMarkers = jQuery.extend(this.locationController.pubMarkers, this.locationController.pvtMarkers);
      this.setMarkers(this.allMarkers);
    }

    SatelliteCartographer.prototype.cartograPhy = function() {
      SatelliteCartographer.__super__.cartograPhy.apply(this, arguments);
      google.maps.event.addListener(this.map, 'zoom_changed', (function(_this) {
        return function() {
          return _this.markerClusterer.clearMarkers();
        };
      })(this));
      google.maps.event.addListener(this.map, 'bounds_changed', (function(_this) {
        return function() {
          return _this.markerClusterer.clearMarkers();
        };
      })(this));
      google.maps.event.addListener(this.map, 'resize', (function(_this) {
        return function() {
          return _this.markerClusterer.clearMarkers();
        };
      })(this));
      google.maps.event.addListener(this.map, 'idle', (function(_this) {
        return function() {
          return viewController.views[_this.locationController.viewNum - 1].update(viewController.genomeController);
        };
      })(this));
      return true;
    };

    SatelliteCartographer.prototype.updateVisible = function() {
      var genomes, marker, marker_id, ref, ref1, ref2;
      if (typeof user_groups_menu !== "undefined" && user_groups_menu !== null) {
        this.activeGroup = user_groups_menu.active_group.public_list.concat(user_groups_menu.active_group.private_list);
      }
      genomes = this.locationController.genomeController;
      this.visibleLocations = [];
      this.clusteredMarkers = [];
      ref = this.allMarkers;
      for (marker_id in ref) {
        marker = ref[marker_id];
        if (this.map.getBounds() !== void 0 && this.map.getBounds().contains(marker.getPosition()) && ((ref1 = marker.feature_id, indexOf.call(genomes.pubVisible, ref1) >= 0) || (ref2 = marker.feature_id, indexOf.call(genomes.pvtVisible, ref2) >= 0))) {
          if (this.activeGroup.indexOf(marker_id) > -1) {
            if (genomes.genome(marker_id).isSelected) {
              marker.setIcon(this.squareIconFill);
            } else {
              marker.setIcon(this.squareIcon);
            }
          } else if (genomes.genome(marker_id).isSelected) {
            marker.setIcon(this.circleIconFill);
          } else {
            marker.setIcon(this.circleIcon);
          }
          this.clusteredMarkers.push(marker);
          this.visibleLocations.push(marker.feature_id);
        }
      }
      return true;
    };

    SatelliteCartographer.prototype.setMarkers = function(markerList) {
      var circleIcon, genomeList, genomes, marker, marker_id, mcOptions;
      genomes = this.locationController.genomeController;
      genomeList = genomes.pubVisible.concat(genomes.pvtVisible);
      circleIcon = '../App/Pictures/red_circle.png';

      /*
      circleIcon = {
        path: google.maps.SymbolPath.CIRCLE
        fillColor: '#FF0000'
        fillOpacity: 0
        scale: 5
        strokeColor: '#FF0000'
        strokeWeight: 2
        }
       */
      this.clusteredMarkers = [];
      for (marker_id in markerList) {
        marker = markerList[marker_id];
        marker.setMap(this.map);
        marker.setIcon(circleIcon);
        this.clusteredMarkers.push(marker);
      }
      mcOptions = {
        gridSize: 50,
        maxZoom: 15
      };
      this.markerClusterer = new MarkerClusterer(this.map, this.clusteredMarkers, mcOptions);
      return true;
    };

    SatelliteCartographer.prototype.resetMap = function() {
      var c, x;
      x = this.map.getZoom();
      c = this.map.getCenter();
      google.maps.event.trigger(this.map, 'resize');
      this.map.setZoom(x);
      this.map.setCenter(c);
      this.resetMarkers();
      return true;
    };

    SatelliteCartographer.prototype.resetMarkers = function() {
      this.updateVisible();
      this.markerClusterer.clearMarkers();
      this.markerClusterer.addMarkers(this.clusteredMarkers);
      return true;
    };

    return SatelliteCartographer;

  })(Cartographer);

  GeophyCartographer = (function(superClass) {
    extend(GeophyCartographer, superClass);

    function GeophyCartographer(geophyCartographDiv, geophyCartograhOpt) {
      this.geophyCartographDiv = geophyCartographDiv;
      this.geophyCartograhOpt = geophyCartograhOpt;
      this.genomeGroupColor = this.geophyCartograhOpt[1];
      GeophyCartographer.__super__.constructor.call(this, this.geophyCartographDiv, this.geophyCartograhOpt);
    }

    GeophyCartographer.prototype.setMarkers = function(markerList) {
      var aqua, blue, brown, circleIcon, colors, green, grey, len, lime, marker, mcOptions, orange, pink, purple, q, red;
      blue = '#1f77b4';
      orange = '#ff7f0e';
      green = '#2ca02c';
      red = '#d62728';
      purple = '#9467bd';
      brown = '#8c564b';
      pink = '#e377c2';
      grey = '#7f7f7f';
      lime = '#bcbd22';
      aqua = '#17becf';
      colors = {
        'group1Color': blue,
        'group2Color': orange,
        'group3Color': green,
        'group4Color': red,
        'group5Color': purple,
        'group6Color': pink,
        'group7Color': brown,
        'group8Color': grey,
        'group9Color': aqua,
        'group10Color': lime
      };
      for (q = 0, len = markerList.length; q < len; q++) {
        marker = markerList[q];
        circleIcon = {
          path: google.maps.SymbolPath.CIRCLE,
          fillColor: colors["group" + this.genomeGroupColor[marker.feature_id] + "Color"],
          fillOpacity: 0.8,
          scale: 5,
          strokeColor: colors["group" + this.genomeGroupColor[marker.feature_id] + "Color"],
          strokeWeight: 1
        };
        marker.setMap(this.map);
        marker.setIcon(circleIcon);
      }
      mcOptions = {
        gridSize: 50,
        maxZoom: 15
      };
      this.markerClusterer = new MarkerClusterer(this.map, markerList, mcOptions);
      return true;
    };

    return GeophyCartographer;

  })(SatelliteCartographer);


  /*
    CLASS InfoSatelliteCartographer
  
    Handles map drawing and location searching
    Displays multiple markers on map
    Handles marker clustering
    Displays list of genomes 
    Alters genome list when map viewport changes
    Highlights selected genome on map from search query
   */

  InfoSatelliteCartographer = (function(superClass) {
    extend(InfoSatelliteCartographer, superClass);

    function InfoSatelliteCartographer(infoSatelliteCartographDiv, infoSatelliteCartograhOpt) {
      var ref;
      this.infoSatelliteCartographDiv = infoSatelliteCartographDiv;
      this.infoSatelliteCartograhOpt = infoSatelliteCartograhOpt;
      InfoSatelliteCartographer.__super__.constructor.call(this, this.infoSatelliteCartographDiv, this.infoSatelliteCartograhOpt);
      this.selectedGenomeId = this.infoSatelliteCartograhOpt[1];
      this.selectedGenome = (ref = window.viewController.genomeController.private_genomes[this.selectedGenomeId]) != null ? ref : window.viewController.genomeController.public_genomes[this.selectedGenomeId];
      this.selectedGenomeLocation = this.locationController._parseLocation(this.selectedGenome);
    }

    InfoSatelliteCartographer.prototype.cartograPhy = function() {
      InfoSatelliteCartographer.__super__.cartograPhy.apply(this, arguments);
      this.showSelectedGenome(this.selectedGenomeLocation, this.map);
      return this.showLegend();
    };

    InfoSatelliteCartographer.prototype.showSelectedGenome = function(location, map) {
      var markerLatLng, maxZndex, overlay, zInd;
      if (location == null) {
        throw new SuperphyError('Location cannot be determined or location is undefined (not specified)!');
        return 0;
      }
      maxZndex = google.maps.Marker.MAX_ZINDEX;
      zInd = maxZndex + 1;
      markerLatLng = new google.maps.LatLng(location.centerLatLng);
      return overlay = new CartographerOverlay(map, location.centerLatLng, location.locationFormattedAddress);
    };

    InfoSatelliteCartographer.prototype.showLegend = function() {
      return jQuery('.map-search-table').append('<tr> <td> <div class="map-legend"> <div class="col-md-3"> <div class="row"> <div class="col-xs-3"> <img class="map-legend-marker-img" src="/superphy/App/Pictures/marker_icon_green.png"> </div> <div class="col-xs-9"> <p class="legendlabel1">Target genome</p> </div> </div> </div> </div> </td> </tr>');
    };

    return InfoSatelliteCartographer;

  })(SatelliteCartographer);

  CartographerOverlay = (function() {
    function CartographerOverlay(map1, latLng, title) {
      this.map = map1;
      this.latLng = latLng;
      this.title = title;
      this.setMap(this.map);
      this.div = null;
    }

    CartographerOverlay.prototype = new google.maps.OverlayView();

    CartographerOverlay.prototype.onAdd = function() {
      var div, panes, selectedMarker, svg;
      div = document.createElement('div');
      div.id = "selectedGenome";
      div.style.borderStyle = 'none';
      div.style.borderWidth = '0px';
      div.style.position = 'absolute';
      div.style.width = '15px';
      div.style.height = '15px';
      div.style.cursor = 'pointer';
      svg = d3.select(div).append('svg').attr('height', '15px').attr('width', '15px');
      selectedMarker = svg.append("g").attr('transform', 'translate(0,0)');
      selectedMarker.append("circle").attr('cx', 7.5).attr('cy', 7.5).attr('r', '5px').style({
        'fill': '#ffc966',
        'stroke': '#ffa500',
        'stroke-width': '3px',
        'fill-opacity': '0.5'
      });
      selectedMarker.append("title").text(this.title);
      this.div = div;
      panes = this.getPanes();
      return panes.floatPane.appendChild(div);
    };

    CartographerOverlay.prototype.onRemove = function() {
      this.div.parentNode.removeChild(this.div);
      return this.div = null;
    };

    CartographerOverlay.prototype.draw = function() {
      var div, location, overlayProjection;
      overlayProjection = this.getProjection();
      location = overlayProjection.fromLatLngToDivPixel(this.latLng);
      div = this.div;
      div.style.left = (location.x - 7.5) + 'px';
      return div.style.top = (location.y - 7.5) + 'px';
    };

    return CartographerOverlay;

  })();

  LocationController = (function() {
    function LocationController(genomeController, parentElem, viewNum1) {
      this.genomeController = genomeController;
      this.parentElem = parentElem;
      this.viewNum = viewNum1;
      this._populateLocations(this.genomeController);
    }

    LocationController.prototype.pubLocations = null;

    LocationController.prototype.pvtLocations = null;

    LocationController.prototype.pubNoLocations = null;

    LocationController.prototype.pvtNoLocations = null;

    LocationController.prototype.pubMarkers = null;

    LocationController.prototype.pvtMarkers = null;

    LocationController.prototype._populateLocations = function(genomes) {
      var private_genome, pubGenomeId, pubMarker, pubMarkerObj, public_genome, pvtGenomeId, pvtMarker, pvtMarkerObj, ref, ref1;
      this.pubLocations = [];
      this.pvtLocations = [];
      this.pubNoLocations = [];
      this.pvtNoLocations = [];
      this.pubMarkers = {};
      this.pvtMarkers = {};
      ref = genomes.public_genomes;
      for (pubGenomeId in ref) {
        public_genome = ref[pubGenomeId];
        if (!((public_genome.isolation_location != null) && public_genome.isolation_location !== "")) {
          this.pubNoLocations.push(pubGenomeId);
        } else {
          pubMarkerObj = this._parseLocation(public_genome);
          this.pubLocations.push(pubGenomeId);
          public_genome.isolation_country = pubMarkerObj['locationCountry'];
          public_genome.isolation_province_state = pubMarkerObj['locationProvinceState'];
          public_genome.isolation_city = pubMarkerObj['locationCity'];
          pubMarker = new google.maps.Marker({
            position: pubMarkerObj['centerLatLng'],
            title: public_genome.uniquename,
            feature_id: pubGenomeId,
            uniquename: public_genome.uniquename,
            location: pubMarkerObj['locationFormattedAddress'],
            isolation_country: pubMarkerObj['locationCountry'],
            isolation_province_state: pubMarkerObj['locationProvinceState'],
            isolation_city: pubMarkerObj['locationCity'],
            privacy: 'public'
          });
          this.pubMarkers[pubGenomeId] = pubMarker;
        }
      }
      ref1 = genomes.private_genomes;
      for (pvtGenomeId in ref1) {
        private_genome = ref1[pvtGenomeId];
        if (!((private_genome.isolation_location != null) && private_genome.isolation_location !== "")) {
          this.pvtNoLocations.push(pvtGenomeId);
        } else {
          pvtMarkerObj = this._parseLocation(private_genome);
          this.pvtLocations.push(pvtGenomeId);
          private_genome.isolation_country = pvtMarkerObj['locationCountry'];
          private_genome.isolation_province_state = pvtMarkerObj['locationProvinceState'];
          private_genome.isolation_city = pvtMarkerObj['locationCity'];
          pvtMarker = new google.maps.Marker({
            position: pvtMarkerObj['centerLatLng'],
            title: private_genome.uniquename,
            feature_id: pvtGenomeId,
            uniquename: private_genome.uniquename,
            location: pvtMarkerObj['locationFormattedAddress'],
            isolation_country: pvtMarkerObj['locationCountry'],
            isolation_province_state: pvtMarkerObj['locationProvinceState'],
            isolation_city: pvtMarkerObj['locationCity'],
            privacy: 'private'
          });
          this.pvtMarkers[pvtGenomeId] = pvtMarker;
        }
      }
      return true;
    };

    LocationController.prototype._parseLocation = function(genome) {
      var add_cmp, centerLatLng, genomeLocation, len, locationAddressComponents, locationCenter, locationCenterLat, locationCenterLng, locationCoordinates, locationFormattedAddress, locationViewPortNE, locationViewPortNELat, locationViewPortNELng, locationViewPortSW, locationViewPortSWLat, locationViewPortSWLng, markerBounds, markerObj, neLatLng, q, ref, ref1, swLatLng;
      genomeLocation = JSON.parse(genome.isolation_location[0]);
      locationFormattedAddress = genomeLocation.formatted_address;
      locationCoordinates = genomeLocation.geometry;
      locationCenter = locationCoordinates.location;
      locationCenterLat = locationCenter.lat;
      locationCenterLng = locationCenter.lng;
      locationViewPortSW = locationCoordinates.viewport.southwest;
      locationViewPortSWLat = locationViewPortSW.lat;
      locationViewPortSWLng = locationViewPortSW.lng;
      locationViewPortNE = locationCoordinates.viewport.northeast;
      locationViewPortNELat = locationViewPortNE.lat;
      locationViewPortNELng = locationViewPortNE.lng;
      locationAddressComponents = {
        'country': void 0,
        'administrative_area_level_1': void 0,
        'locality': void 0
      };
      ref = genomeLocation.address_components;
      for (q = 0, len = ref.length; q < len; q++) {
        add_cmp = ref[q];
        if (ref1 = add_cmp.types[0], indexOf.call(Object.keys(locationAddressComponents), ref1) >= 0) {
          locationAddressComponents[add_cmp.types[0]] = add_cmp.long_name;
        }
      }
      centerLatLng = new google.maps.LatLng(locationCenterLat, locationCenterLng);
      swLatLng = new google.maps.LatLng(locationViewPortSWLat, locationViewPortSWLng);
      neLatLng = new google.maps.LatLng(locationViewPortNELat, locationViewPortNELng);
      markerBounds = new google.maps.LatLngBounds(swLatLng, neLatLng);
      markerObj = {};
      markerObj['locationFormattedAddress'] = locationFormattedAddress;
      markerObj['locationCountry'] = locationAddressComponents['country'];
      markerObj['locationProvinceState'] = locationAddressComponents['administrative_area_level_1'];
      markerObj['locationCity'] = locationAddressComponents['locality'];
      markerObj['centerLatLng'] = centerLatLng;
      markerObj['markerBounds'] = markerBounds;
      return markerObj;
    };

    return LocationController;

  })();

  GeoPhy = (function() {
    function GeoPhy(publicGenomes1, privateGenomes1, viewController1, userGroups, treeDiv, mapDiv, sumDiv, tableDiv, mapTableDiv) {
      this.publicGenomes = publicGenomes1;
      this.privateGenomes = privateGenomes1;
      this.viewController = viewController1;
      this.userGroups = userGroups;
      this.treeDiv = treeDiv;
      this.mapDiv = mapDiv;
      this.sumDiv = sumDiv;
      this.tableDiv = tableDiv;
      this.mapTableDiv = mapTableDiv;
    }

    GeoPhy.prototype.publicSubsetGenomes = {};

    GeoPhy.prototype.privateSubsetGenomes = {};

    GeoPhy.prototype.genomeController = null;

    GeoPhy.prototype.init = function(boolShowall) {
      if ((this.userGroups == null) || (this.userGroups != null) && boolShowall) {
        this._showall();
      } else if ((this.userGroups != null) && !boolShowall) {
        this._filter();
      }
      this.viewController.sideBar($('#search-utilities'));
      this.viewController.createView('tree', this.treeDiv, tree);
      this.viewController.createView('summary', this.sumDiv);
      this.viewController.createView('table', this.tableDiv);
      return true;
    };

    GeoPhy.prototype._getPublicSubset = function(public_genomes, selected_groups) {
      var public_subset_genomes;
      public_subset_genomes = {};
      jQuery.each(selected_groups, function(gp_num, gp) {
        return jQuery.each(gp, function(i, v) {
          if (public_genomes[v]) {
            return public_subset_genomes[v] = public_genomes[v];
          }
        });
      });
      return public_subset_genomes;
    };

    GeoPhy.prototype._getPrivateSubset = function(private_genomes, selected_groups) {
      var private_subset_genomes;
      private_subset_genomes = {};
      jQuery.each(selected_groups, function(gp_num, gp) {
        return jQuery.each(gp, function(i, v) {
          if (private_genomes[v]) {
            return private_subset_genomes[v] = private_genomes[v];
          }
        });
      });
      return private_subset_genomes;
    };

    GeoPhy.prototype._appendLegend = function(divEl, groups) {
      var aqua, blue, brown, buttonEl, clearFormEl, colors, div, gList, gNum, green, grey, hiddenFormEl, legendEl, lime, markerLegend, orange, panelEl, pink, purple, red, rowEl, submitEl, svg;
      blue = '#1f77b4';
      orange = '#ff7f0e';
      green = '#2ca02c';
      red = '#d62728';
      purple = '#9467bd';
      brown = '#8c564b';
      pink = '#e377c2';
      grey = '#7f7f7f';
      lime = '#bcbd22';
      aqua = '#17becf';
      colors = {
        'group1Color': blue,
        'group2Color': orange,
        'group3Color': green,
        'group4Color': red,
        'group5Color': purple,
        'group6Color': pink,
        'group7Color': brown,
        'group8Color': grey,
        'group9Color': aqua,
        'group10Color': lime
      };
      legendEl = jQuery('<div class="col-md-12 panel panel-default"></div>');
      panelEl = jQuery('<div class="panel-body"></div>').appendTo(legendEl);
      rowEl = jQuery('<div class="row"></div>').appendTo(panelEl);
      divEl.prepend(legendEl);
      for (gNum in groups) {
        gList = groups[gNum];
        console.log(gNum);
        div = document.createElement('div');
        div.className = "col-md-1";
        svg = d3.select(div).append('svg').attr('height', '20px').attr('width', '100px');
        markerLegend = svg.append("g").attr('transform', 'translate(0,0)');
        markerLegend.append("circle").attr('cx', 10).attr('cy', 10).attr('r', '5px').style({
          'fill': colors["group" + gNum + "Color"],
          'fill-opacity': '1.0'
        });
        markerLegend.append("text").attr("class", "legendlabel2").attr("dx", 20).attr("dy", 15).attr("text-anchor", "start").text("Group " + gNum);
        rowEl.append(div);
      }
      submitEl = jQuery("<div class='compare-genome-groups row'></div>").appendTo(panelEl);
      divEl = jQuery("<div class='col-md-12'></div>").appendTo(submitEl);
      clearFormEl = jQuery("<button class='btn btn-danger' onclick='location.reload()'><span class='fa fa-times'></span> Reset Form</button>").appendTo(divEl);
      buttonEl = jQuery("<button type='submit' class='btn btn-primary' value='Submit' form='groups-compare-form'><span class='fa fa-check'></span> Show All Groups</button>").appendTo(divEl);
      hiddenFormEl = jQuery('#groups-compare-form');
      buttonEl.click((function(_this) {
        return function(e) {
          var genome, groupGenomes, i, len, q, ref, s;
          e.preventDefault();
          jQuery("<input type='hidden' name='show-all' value='1'>").appendTo(hiddenFormEl);
          for (i = q = 1, ref = _this.viewController.groups.length; q <= ref; i = q += 1) {
            groupGenomes = jQuery("#genome_group" + i + " .genome_group_item");
            for (s = 0, len = groupGenomes.length; s < len; s++) {
              genome = groupGenomes[s];
              jQuery("<input type='hidden' name='group" + i + "-genome' value='" + (jQuery(genome).find('a').data('genome')) + "'>").appendTo(hiddenFormEl);
            }
          }
          jQuery("<input type='hidden' name='num-groups' value='" + _this.viewController.groups.length + "'>").appendTo(hiddenFormEl);
          return hiddenFormEl.submit();
        };
      })(this));
      return true;
    };

    GeoPhy.prototype._showall = function() {
      var gpColors;
      this._setViewController(this.publicGenomes, this.privateGenomes);
      if (this.userGroups != null) {
        gpColors = this._prepareGroups();
      }
      this.viewController.createView('map', this.mapDiv, ['satellite']);
      return true;
    };

    GeoPhy.prototype._filter = function() {
      var gpColors;
      this.publicSubsetGenomes = this._getPublicSubset(this.publicGenomes, this.userGroups);
      this.privateSubsetGenomes = this._getPrivateSubset(this.privateGenomes, this.userGroups);
      this._setViewController(this.publicSubsetGenomes, this.privateSubsetGenomes);
      jQuery('#groups-compare').hide();
      gpColors = this._prepareGroups();
      this.viewController.createView('map', this.mapDiv, ['geophy'], gpColors);
      this._appendLegend(jQuery('#groups-geophy'), this.userGroups);
      return true;
    };

    GeoPhy.prototype._setViewController = function(pubList, pvtList) {
      var addMore, filter, submit;
      this.viewController.init(pubList, pvtList, 'multi_select', '/superphy/groups/geophy');
      addMore = true;
      submit = true;
      filter = true;
      return true;
    };

    GeoPhy.prototype._createSubmitForm = function() {
      var elem, form, parentTarget, resetButtonEl, submitButtonEl, submitEl, wrapper;
      elem = jQuery('#geophy-control');
      parentTarget = 'geophy-control-panel-body';
      wrapper = jQuery('<div class="panel panel-default" id="geophy-control-panel"></div>');
      elem.append(wrapper);
      form = jQuery("<div class='panel-body' id='" + parentTarget + "'></div>");
      wrapper.append(form);
      submitEl = jQuery('<div class="row"></div>');
      submitButtonEl = jQuery('<div class="col-md-2 col-md-offset-4"><button id="group-browse-highlight" type="submit" value="Submit" form="geophy-form" class="btn btn-success"><span class="fa fa-exchange"></span> Highlight Genomes</button></div>').appendTo(submitEl);
      resetButtonEl = jQuery('<div class="col-md-2"><button id="group-browse-reset" type="button" form="geophy-form" class="btn btn-danger"><span class="fa fa-times"></span> Reset Views</button></div>').appendTo(submitEl);
      submitButtonEl.click((function(_this) {
        return function(e) {
          e.preventDefault();
          console.log("Button Clicked");
          _this.viewController.filterViews('selection');
          return true;
        };
      })(this));
      resetButtonEl.click((function(_this) {
        return function(e) {
          var g, len, len1, q, ref, ref1, s;
          e.preventDefault();
          _this.viewController.resetFilter();
          ref = _this.viewController.genomeController.pubVisible;
          for (q = 0, len = ref.length; q < len; q++) {
            g = ref[q];
            _this.viewController.select(g, false);
          }
          ref1 = _this.viewController.genomeController.pvtVisible;
          for (s = 0, len1 = ref1.length; s < len1; s++) {
            g = ref1[s];
            _this.viewController.select(g, false);
          }
          jQuery('#reset-map-view').click();
          return true;
        };
      })(this));
      form.append(submitEl);
      return true;
    };

    GeoPhy.prototype._prepareGroups = function() {
      var gId, gList, gNum, genomeGroupColor, len, q, ref, userMaxGroupNum;
      genomeGroupColor = {};
      userMaxGroupNum = Math.max.apply(Math, Object.keys(this.userGroups));
      while (userMaxGroupNum > this.viewController.groups.length) {
        this.viewController.addGroupFormRow($("#group-form-block"));
      }
      ref = this.userGroups;
      for (gNum in ref) {
        gList = ref[gNum];
        for (q = 0, len = gList.length; q < len; q++) {
          gId = gList[q];
          this.viewController.select(gId, true);
          genomeGroupColor[gId] = gNum;
        }
        this.viewController.addToGroup(parseInt(gNum));
      }
      return genomeGroupColor;
    };

    if (!root.GeoPhy) {
      root.GeoPhy = GeoPhy;
    }

    return GeoPhy;

  })();


  /*
  
   File: superphy_summary.coffee
   Desc: Meta-data Summary class
   Author: Jason Masih jason.masih@phac-aspc.gc.ca
   Date: March 4th, 2015
   */


  /*
  
   CLASS SummaryView
  
   Group/selection meta-data summary view 
  
   Creates stacked bar representation of meta-data for genome group/selection
   */

  SummaryView = (function(superClass) {
    extend(SummaryView, superClass);

    function SummaryView(parentElem, style1, elNum, genomes1, summaryArgs) {
      var all_genomes, g, len, len1, len2, m, q, ref, ref1, s, totalCount, w;
      this.parentElem = parentElem;
      this.style = style1;
      this.elNum = elNum;
      this.genomes = genomes1;
      this.width = 1350;
      this.height = 200;
      this.offset = 150;
      this.genomeCounter = "No genomes selected";
      this.groupTracker = "No group selected";
      this.selectionInfo = $("<p>" + this.genomeCounter + "</p>").appendTo('#selection-info');
      this.activeGroupInfo = $("<p>" + this.groupTracker + "</p>").appendTo('#active-group-info');
      this.svgSelection = d3.select('#selection-svg').append('svg').attr('class', 'summaryPanel').attr('width', this.width + this.offset).attr('height', this.height);
      this.svgActiveGroup = d3.select('#active-group-svg').append('svg').attr('class', 'summaryPanel').attr('width', this.width + this.offset).attr('height', this.height);
      this.mtypesDisplayed = ['serotype', 'isolation_host', 'isolation_source', 'syndrome', 'stx1_subtype', 'stx2_subtype'];
      this.colours = {
        'serotype': ['#236932', '#468554', '#6AA276', '#8DBE98', '#B0DABA', '#D4F7DC', '#e9fbed'],
        'isolation_host': ['#a70209', '#b3262c', '#c04a4f', '#cc6e72', '#d99295', '#e5b6b8', '#f2dadb'],
        'isolation_source': ['#3741ae', '#535cb9', '#7077c5', '#8c92d0', '#a9addc', '#c5c8e7', '#e2e3f3'],
        'syndrome': ['#962ba6', '#a549b2', '#b467bf', '#c385cc', '#d2a4d8', '#e1c2e5', '#f0e0f2'],
        'stx1_subtype': ['#F05C00', '#EF7123', '#EE8746', '#ED9D69', '#ECB28C', '#EBC8AF', '#EADED2'],
        'stx2_subtype': ['#35a6a7', '#51b2b3', '#6ebfc0', '#8bcccc', '#a8d8d9', '#c5e5e5', '#e2f2f2']
      };
      totalCount = {};
      ref = this.mtypesDisplayed;
      for (q = 0, len = ref.length; q < len; q++) {
        m = ref[q];
        totalCount[m] = {};
      }
      all_genomes = (Object.keys(this.genomes.public_genomes)).concat(Object.keys(this.genomes.private_genomes));
      for (s = 0, len1 = all_genomes.length; s < len1; s++) {
        g = all_genomes[s];
        this.countMeta(totalCount, this.genomes.genome(g), true);
      }
      this.metaOntology = {};
      this.tt_mtitle = {};
      ref1 = this.mtypesDisplayed;
      for (w = 0, len2 = ref1.length; w < len2; w++) {
        m = ref1[w];
        this.selectionCount[m] = {};
        this.metaOntology[m] = [];
        this.tt_mtitle[m] = new String();
        this.metaOntology[m] = Object.keys(totalCount[m]).sort(function(a, b) {
          return totalCount[m][b] - totalCount[m][a];
        });
        if (m === "isolation_host" || m === "isolation_source") {
          this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
          this.tt_mtitle[m] = this.tt_mtitle[m].replace("_", " ");
          this.tt_mtitle[m] = this.tt_mtitle[m].slice(0, 10) + this.tt_mtitle[m].charAt(10).toUpperCase() + this.tt_mtitle[m].slice(11);
        }
        if (m === "syndrome") {
          this.tt_mtitle[m] = "Symptoms/Diseases";
        }
        if (m === "stx1_subtype" || m === "stx2_subtype") {
          this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
          this.tt_mtitle[m] = this.tt_mtitle[m].replace("_", " ");
          this.tt_mtitle[m] = this.tt_mtitle[m].slice(0, 5) + this.tt_mtitle[m].charAt(5).toUpperCase() + this.tt_mtitle[m].slice(6);
        }
        if (m === "serotype") {
          this.tt_mtitle[m] = m.charAt(0).toUpperCase() + m.slice(1);
        }
      }
      SummaryView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
    }

    SummaryView.prototype.selection = [];

    SummaryView.prototype.selectionCount = {};

    SummaryView.prototype.activeGroup = [];

    SummaryView.prototype.activeGroupCount = {};

    SummaryView.prototype.type = 'summary';

    SummaryView.prototype.elName = 'meta_summary';

    SummaryView.prototype.sumView = true;

    SummaryView.prototype.update = function(genomes) {
      return true;
    };

    SummaryView.prototype.updateActiveGroup = function(usrGrp) {
      var aa, ab, g, len, len1, len2, len3, len4, m, q, ref, ref1, ref2, ref3, ref4, s, tempActiveGroup, w;
      ref = this.mtypesDisplayed;
      for (q = 0, len = ref.length; q < len; q++) {
        m = ref[q];
        this.activeGroupCount[m] = {};
        this.selectionCount[m] = {};
      }
      tempActiveGroup = [];
      this.activeGroup = [];
      this.activeGroup = usrGrp.active_group.public_list.concat(usrGrp.active_group.private_list);
      ref1 = this.activeGroup;
      for (s = 0, len1 = ref1.length; s < len1; s++) {
        g = ref1[s];
        if (this.genomes.genome(g).visible) {
          tempActiveGroup.push(g);
        }
      }
      this.activeGroup = tempActiveGroup;
      if (this.genomes.filterReset) {
        ref2 = this.activeGroup;
        for (w = 0, len2 = ref2.length; w < len2; w++) {
          g = ref2[w];
          this.genomes.genome(g).isSelected = true;
        }
      }
      this.selection = [];
      this.selection = this.selection.concat(this.activeGroup);
      if (this.selection.length === 0) {
        this.genomeCounter = 'No genomes selected';
        $('#selection-buttons').empty();
      }
      if (this.selection.length === 1) {
        this.genomeCounter = '1 genome selected';
        if ($('#selection-buttons').find('.form-group')[0] == null) {
          this.groupEditForm('#selection-buttons', usrGrp);
        }
      }
      if (this.selection.length > 1) {
        this.genomeCounter = this.selection.length + ' genomes selected';
        if ($('#selection-buttons').find('.form-group')[0] == null) {
          this.groupEditForm('#selection-buttons', usrGrp);
        }
      }
      $('#selection-info').html("<p>" + this.genomeCounter + "</p>");
      if (this.activeGroup.length === 0) {
        this.groupTracker = 'No group selected';
        $('#active-group-buttons').empty();
      }
      if (this.activeGroup.length === 1) {
        this.groupTracker = "Active Group: " + usrGrp.active_group.group_name + " (" + this.activeGroup.length + " genome)";
        if ($('#active-group-buttons').find('.form-group')[0] == null) {
          this.groupEditForm('#active-group-buttons', usrGrp);
        }
      }
      if (this.activeGroup.length > 1) {
        this.groupTracker = "Active Group: " + usrGrp.active_group.group_name + " (" + this.activeGroup.length + " genomes)";
        if ($('#active-group-buttons').find('.form-group')[0] == null) {
          this.groupEditForm('#active-group-buttons', usrGrp);
        }
      }
      $('#active-group-info').html("<p>" + this.groupTracker + "</p>");
      ref3 = this.activeGroup;
      for (aa = 0, len3 = ref3.length; aa < len3; aa++) {
        g = ref3[aa];
        this.countMeta(this.activeGroupCount, this.genomes.genome(g), true);
      }
      ref4 = this.selection;
      for (ab = 0, len4 = ref4.length; ab < len4; ab++) {
        g = ref4[ab];
        this.countMeta(this.selectionCount, this.genomes.genome(g), true);
      }
      this.createMeters(this.activeGroupCount, this.svgActiveGroup, this.activeGroup);
      this.createMeters(this.selectionCount, this.svgSelection, this.selection);
      return true;
    };

    SummaryView.prototype.groupEditForm = function(buttonsID, usrGrp) {
      var custom_select, group_create_button, group_delete_button, group_update, group_update_button, group_update_button_row1, group_update_button_row2, group_update_input, group_update_input_row;
      group_update = jQuery('<div class="form-group" style="margin-bottom:0px"></div>').appendTo(buttonsID);
      if (usrGrp.username === "") {
        custom_select = jQuery('<p>Please <a href="/superphy/user/login">sign in</a> to view your custom groups</p>');
        group_update_button_row1 = jQuery('<div class="row" style="margin-top:5px;padding:2px"></div>').appendTo(group_update);
        if (buttonsID === '#selection-buttons') {
          group_delete_button = jQuery('<div class="col-md-6"><button class="btn btn-sm" type="button">Clear selection</button></div></div>').appendTo(group_update_button_row1);
          group_update_input_row = jQuery('<div style="margin-top:5px"><p>Please <a href="/superphy/user/login">sign in</a> to create a group from your selection or update a group</p></div>').appendTo(group_update);
          group_update_input_row = jQuery('<div class="row" style="margin-top:5px;margin-left:8px"></div>').appendTo(group_update);
        }
        if (buttonsID === '#active-group-buttons') {
          group_delete_button = jQuery('<div class="col-md-12"><button class="btn btn-sm" type="button">Clear active group</button></div>').appendTo(group_update_button_row1);
          group_update_input_row = jQuery('<div style="margin-top:5px"><p>Please <a href="/superphy/user/login">sign in</a> to view your custom groups</p></div>').appendTo(group_update);
          group_update_input_row = jQuery('<div class="row" style="margin-top:5px;margin-left:8px"></div>').appendTo(group_update);
        }
        if (group_delete_button != null) {
          group_delete_button.click((function(_this) {
            return function(e) {
              var g, len, len1, q, ref, s, selection, summary, v;
              e.preventDefault();
              if (buttonsID === '#selection-buttons') {
                _this.clearSelection = true;
                selection = [];
                selection = selection.concat(_this.selection);
                for (q = 0, len = selection.length; q < len; q++) {
                  g = selection[q];
                  ref = viewController.views;
                  for (s = 0, len1 = ref.length; s < len1; s++) {
                    v = ref[s];
                    v.select(g, false);
                  }
                  viewController.genomeController.genome(g).isSelected = false;
                }
                if (viewController.views[2].constructor.name === 'SummaryView') {
                  summary = viewController.views[2];
                  summary.afterSelect(_this.checked);
                }
                viewController.views[0].bonsaiActions(viewController.genomeController);
                _this.clearSelection = false;
              }
              if (buttonsID === '#active-group-buttons') {
                return usrGrp._updateSelections({
                  select_public_ids: [],
                  select_private_ids: []
                }, "", "public");
              }
            };
          })(this));
        }
      } else {
        custom_select = jQuery('<select id="custom_group_collections" class="form-control" placeholder="Select custom group(s)..."></select>');
        group_update_input_row = jQuery('<div class="row" style="margin-top:5px"></div>').appendTo(group_update);
        if (buttonsID === '#selection-buttons') {
          group_update_input = jQuery('<div class="col-xs-12">' + '<input class="form-control input-sm" type="text" id="create_group_name_input_summary" placeholder="Group Name">' + '<input style="margin-top:5px" class="form-control input-sm" type="text" id="create_collection_name_input_summary" placeholder="Collection Name">' + '<input style="margin-top:5px" class="form-control input-sm" type="text" id="create_description_input_summary" placeholder="Description">' + '</div>').appendTo(group_update_input_row);
        }
        group_update_button_row1 = jQuery('<div class="row" style="margin-top:5px;padding:2px"></div>').appendTo(group_update);
        group_update_button_row2 = jQuery('<div class="row" style="padding:2px"></div>').appendTo(group_update);
        if (buttonsID === '#selection-buttons') {
          group_create_button = jQuery('<div class="col-md-6"><button class="btn btn-sm" type="button">Create from selection</button></div></div>').appendTo(group_update_button_row1);
          group_update_button = jQuery('<div class="col-md-6"><button class="btn btn-sm" type="button">Update with selection</button></div></div>').appendTo(group_update_button_row2);
          group_delete_button = jQuery('<div class="col-md-6"><button class="btn btn-sm" type="button">Clear selection</button></div></div>').appendTo(group_update_button_row1);
        }
        if (buttonsID === '#active-group-buttons') {
          group_delete_button = jQuery('<div class="col-md-12"><button class="btn btn-sm" type="button">Clear active group</button></div>').appendTo(group_update_button_row1);
        }
        if (group_create_button != null) {
          group_create_button.click((function(_this) {
            return function(e) {
              var data, data_str, g, g_obj, ref, ref1;
              e.preventDefault();
              data = [];
              ref = usrGrp.viewController.genomeController.public_genomes;
              for (g in ref) {
                g_obj = ref[g];
                if (g_obj.isSelected) {
                  data.push('genome=' + g);
                }
              }
              ref1 = usrGrp.viewController.genomeController.private_genomes;
              for (g in ref1) {
                g_obj = ref1[g];
                if (g_obj.isSelected) {
                  data.push('genome=' + g);
                }
              }
              data_str = data.join('&');
              return jQuery.ajax({
                type: "GET",
                url: '/superphy/collections/create?' + data_str,
                data: {
                  'name': $('#create_group_name_input_summary').val(),
                  'category': $('#create_collection_name_input_summary').val(),
                  'description': $('#create_description_input_summary').val()
                }
              }).done(function(data) {
                var ref2, ref3;
                console.log(data);
                if (data.success === 1) {
                  if ($('#create_group_name_input_error')) {
                    $('#create_group_name_input_error').remove();
                  }
                  ref2 = usrGrp.viewController.genomeController.public_genomes;
                  for (g in ref2) {
                    g_obj = ref2[g];
                    if (g_obj.isSelected) {
                      if (!(g_obj.groups.indexOf(data.group_id) > -1)) {
                        g_obj.groups.push(data.group_id);
                      }
                    }
                  }
                  ref3 = usrGrp.viewController.genomeController.private_genomes;
                  for (g in ref3) {
                    g_obj = ref3[g];
                    if (g_obj.isSelected) {
                      if (!(g_obj.groups.indexOf(data.group_id) > -1)) {
                        g_obj.groups.push(data.group_id);
                      }
                    }
                  }
                  $('#user-groups-selectize-form').remove();
                  return usrGrp.appendGroupForm(data.groups);
                } else if (data.success === 0) {
                  if ($('#create_group_name_input_error')) {
                    $('#create_group_name_input_error').remove();
                  }
                  return $('#create_group_name_input').after("<p id='create_group_name_input_error' style ='color:red;'>" + data.error + "</p>");
                }
              }).fail((function(error) {
                return console.log(error);
              }));
            };
          })(this));
        }
        if (group_update_button != null) {
          group_update_button.click((function(_this) {
            return function(e) {
              var data, data_str, g, g_obj, group_id, name, ref, ref1;
              data = [];
              ref = usrGrp.viewController.genomeController.public_genomes;
              for (g in ref) {
                g_obj = ref[g];
                if (g_obj.isSelected) {
                  data.push('genome=' + g);
                }
              }
              ref1 = usrGrp.viewController.genomeController.private_genomes;
              for (g in ref1) {
                g_obj = ref1[g];
                if (g_obj.isSelected) {
                  data.push('genome=' + g);
                }
              }
              data_str = data.join('&');
              name = $('#create_group_name_input_summary').val();
              group_id = usrGrp.user_custom_groups[name];
              console.log(name);
              console.log(group_id);
              e.preventDefault();
              return jQuery.ajax({
                type: "GET",
                url: '/superphy/collections/update?' + data_str,
                data: {
                  'group_id': group_id,
                  'name': name,
                  'category': $('#create_collection_name_input_summary').val(),
                  'description': $('#create_description_input_summary').val()
                }
              }).done(function(data) {
                var ref2, ref3;
                console.log(data);
                if (data.success === 1) {
                  ref2 = usrGrp.viewController.genomeController.public_genomes;
                  for (g in ref2) {
                    g_obj = ref2[g];
                    if (g_obj.isSelected) {
                      if (!(g_obj.groups.indexOf(data.group_id) > -1)) {
                        g_obj.groups.push(data.group_id);
                      }
                    }
                  }
                  ref3 = usrGrp.viewController.genomeController.private_genomes;
                  for (g in ref3) {
                    g_obj = ref3[g];
                    if (g_obj.isSelected) {
                      if (!(g_obj.groups.indexOf(data.group_id) > -1)) {
                        g_obj.groups.push(data.group_id);
                      }
                    }
                  }
                  $('#user-groups-selectize-form').remove();
                  return usrGrp.appendGroupForm(data.groups);
                }
              }).fail((function(error) {
                return console.log(error);
              }));
            };
          })(this));
        }
        if (group_delete_button != null) {
          group_delete_button.click((function(_this) {
            return function(e) {
              var g, len, len1, q, ref, s, selection, summary, v;
              e.preventDefault();
              if (buttonsID === '#selection-buttons') {
                _this.clearSelection = true;
                selection = [];
                selection = selection.concat(_this.selection);
                for (q = 0, len = selection.length; q < len; q++) {
                  g = selection[q];
                  ref = viewController.views;
                  for (s = 0, len1 = ref.length; s < len1; s++) {
                    v = ref[s];
                    v.select(g, false);
                  }
                  viewController.genomeController.genome(g).isSelected = false;
                }
                if (viewController.views[2].constructor.name === 'SummaryView') {
                  summary = viewController.views[2];
                  summary.afterSelect(_this.checked);
                }
                viewController.views[0].bonsaiActions(viewController.genomeController);
                _this.clearSelection = false;
              }
              if (buttonsID === '#active-group-buttons') {
                return usrGrp._updateSelections({
                  select_public_ids: [],
                  select_private_ids: []
                }, "", "public");
              }
            };
          })(this));
        }
      }
      return usrGrp._processGroups(usrGrp);
    };

    SummaryView.prototype.countMeta = function(count, genome, isSelected) {
      if (isSelected) {
        if (count['serotype'][genome.serotype] != null) {
          count['serotype'][genome.serotype] += 1;
        } else {
          count['serotype'][genome.serotype] = 1;
        }
        if (count['isolation_host'][genome.isolation_host] != null) {
          count['isolation_host'][genome.isolation_host] += 1;
        } else {
          count['isolation_host'][genome.isolation_host] = 1;
        }
        if (count['isolation_source'][genome.isolation_source] != null) {
          count['isolation_source'][genome.isolation_source] += 1;
        } else {
          count['isolation_source'][genome.isolation_source] = 1;
        }
        if (count['syndrome'][genome.syndrome] != null) {
          count['syndrome'][genome.syndrome] += 1;
        } else {
          count['syndrome'][genome.syndrome] = 1;
        }
        if (count['stx1_subtype'][genome.stx1_subtype] != null) {
          count['stx1_subtype'][genome.stx1_subtype] += 1;
        } else {
          count['stx1_subtype'][genome.stx1_subtype] = 1;
        }
        if (count['stx2_subtype'][genome.stx2_subtype] != null) {
          count['stx2_subtype'][genome.stx2_subtype] += 1;
        } else {
          count['stx2_subtype'][genome.stx2_subtype] = 1;
        }
      } else {
        if (count['serotype'][genome.serotype] > 0) {
          count['serotype'][genome.serotype] -= 1;
        } else {
          count['serotype'][genome.serotype] = 0;
        }
        if (count['isolation_host'][genome.isolation_host] > 0) {
          count['isolation_host'][genome.isolation_host] -= 1;
        } else {
          count['isolation_host'][genome.isolation_host] = 0;
        }
        if (count['isolation_source'][genome.isolation_source] > 0) {
          count['isolation_source'][genome.isolation_source] -= 1;
        } else {
          count['isolation_source'][genome.isolation_source] = 0;
        }
        if (count['syndrome'][genome.syndrome] > 0) {
          count['syndrome'][genome.syndrome] -= 1;
        } else {
          count['syndrome'][genome.syndrome] = 0;
        }
        if (count['stx1_subtype'][genome.stx1_subtype] > 0) {
          count['stx1_subtype'][genome.stx1_subtype] -= 1;
        } else {
          count['stx1_subtype'][genome.stx1_subtype] = 0;
        }
        if (count['stx2_subtype'][genome.stx2_subtype] > 0) {
          count['stx2_subtype'][genome.stx2_subtype] -= 1;
        } else {
          count['stx2_subtype'][genome.stx2_subtype] = 0;
        }
      }
      return count;
    };

    SummaryView.prototype.select = function(genome, isSelected) {
      var len, m, q, ref;
      if (user_groups_menu.runSelect || !user_groups_menu.groupSelected) {
        this.selectionCount = {};
        ref = this.mtypesDisplayed;
        for (q = 0, len = ref.length; q < len; q++) {
          m = ref[q];
          this.selectionCount[m] = {};
        }
        if (isSelected) {
          if (!(this.selection.indexOf(genome) > -1)) {
            this.selection.push(genome);
          }
        } else {
          this.selection.splice(this.selection.indexOf(genome), 1);
        }
        return true;
      }
    };

    SummaryView.prototype.intro = function() {
      var tableIntro;
      tableIntro = [];
      tableIntro.push({
        element: document.querySelector('#groups_summary'),
        intro: "This panel displays genome meta-data in a proportional bar representation. Each bar represents a meta-data category and each segment represents the frequency of each meta-data type.  Hovering over each segment will display more information. Tabs allow for toggling between summaries for selected genomes and for the active group.  Groups can also be created/edited from selected genomes.",
        position: 'bottom'
      });
      return tableIntro;
    };

    SummaryView.prototype.afterSelect = function(isSelected) {
      var g, len, q, ref;
      if (this.selection.length === 0) {
        this.genomeCounter = 'No genomes selected';
        $('#selection-buttons').empty();
      }
      if (this.selection.length === 1) {
        this.genomeCounter = '1 genome selected';
        if ($('#selection-buttons').find('.form-group')[0] == null) {
          this.groupEditForm('#selection-buttons', user_groups_menu);
        }
      }
      if (this.selection.length > 1) {
        this.genomeCounter = this.selection.length + ' genomes selected';
        if ($('#selection-buttons').find('.form-group')[0] == null) {
          this.groupEditForm('#selection-buttons', user_groups_menu);
        }
      }
      $('#selection-info').html("<p>" + this.genomeCounter + "</p>");
      ref = this.selection;
      for (q = 0, len = ref.length; q < len; q++) {
        g = ref[q];
        this.countMeta(this.selectionCount, this.genomes.genome(g), true);
      }
      this.createMeters(this.selectionCount, this.svgSelection, this.selection);
      return true;
    };

    SummaryView.prototype.createMeters = function(sumCount, svgView, countType) {
      var bar_count, i, j, len, len1, length, m, other_count, pos, q, ref, ref1, s, sumBar, totalSelected, tt_data, tt_mtype, tt_mtype_last, tt_sub_table, tt_table, tt_table_partial, width, x, y;
      if (countType != null) {
        totalSelected = countType.length;
      } else {
        totalSelected = 0;
      }
      svgView.selectAll('rect.summaryMeter').remove();
      tt_sub_table = {};
      tt_table_partial = {};
      tt_table = {};
      other_count = {};
      ref = this.mtypesDisplayed;
      for (q = 0, len = ref.length; q < len; q++) {
        m = ref[q];
        tt_sub_table[m] = new String();
        tt_table_partial[m] = new String();
        tt_table[m] = new String();
        other_count[m] = 0;
        i = 0;
        while (i < this.metaOntology[m].length) {
          if (i > 5 && (sumCount[m][this.metaOntology[m][i]] != null)) {
            other_count[m] += sumCount[m][this.metaOntology[m][i]];
          }
          tt_mtype = this.metaOntology[m][i].charAt(0).toUpperCase() + this.metaOntology[m][i].slice(1);
          if (sumCount[m][this.metaOntology[m][i]] > 0) {
            if (i >= 6) {
              tt_sub_table[m] += "<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + sumCount[m][this.metaOntology[m][i]] + "</td></tr>";
              tt_table[m] = tt_table_partial[m] + ("<tbody class='other-row' onclick=\"$('.after-other').slideToggle(100);\"><tr><td>[+] Other</td><td style='text-align:right'\">" + other_count[m] + "</td></tr></tbody><tbody class='after-other'>" + tt_sub_table[m] + "</tbody>");
            } else {
              tt_table_partial[m] += "<tr><td>" + tt_mtype + "</td><td style='text-align:right'>" + sumCount[m][this.metaOntology[m][i]] + "</td></tr>";
              tt_mtype_last = tt_mtype;
              tt_table[m] = tt_table_partial[m];
            }
          }
          i++;
        }
      }
      y = 0;
      ref1 = this.mtypesDisplayed;
      for (s = 0, len1 = ref1.length; s < len1; s++) {
        m = ref1[s];
        y += 30;
        svgView.selectAll('g.sumBar_' + m).remove();
        sumBar = svgView.append('g').attr('class', 'sumBar_' + m);
        sumBar.append('text').attr('y', y + 15).text(function() {
          var meta_label;
          if (m === "isolation_host" || m === "isolation_source") {
            meta_label = m.charAt(0).toUpperCase() + m.slice(1);
            meta_label = meta_label.replace("_", " ");
            meta_label = meta_label.slice(0, 10) + meta_label.charAt(10).toUpperCase() + meta_label.slice(11);
          }
          if (m === "syndrome") {
            meta_label = "Symptoms/Diseases";
          }
          if (m === "stx1_subtype" || m === "stx2_subtype") {
            meta_label = m.charAt(0).toUpperCase() + m.slice(1);
            meta_label = meta_label.replace("_", " ");
            meta_label = meta_label.slice(0, 5) + meta_label.charAt(5).toUpperCase() + meta_label.slice(6);
          }
          if (m === "serotype") {
            meta_label = m.charAt(0).toUpperCase() + m.slice(1);
          }
          if (totalSelected === 0) {
            meta_label = '';
          }
          return meta_label;
        });
        width = [];
        i = 0;
        j = 0;
        x = 0;
        if (this.metaOntology[m].length < 7) {
          bar_count = this.metaOntology[m].length;
        } else {
          bar_count = 7;
        }
        while (i < bar_count) {
          if (i < 6 && (sumCount[m][this.metaOntology[m][i]] != null) && totalSelected > 0) {
            width[i] = this.width * (sumCount[m][this.metaOntology[m][i]] / totalSelected);
          } else if (i === 6 && totalSelected > 0 && (this.metaOntology[m][i] != null)) {
            width[i] = this.width - (width[0] + width[1] + width[2] + width[3] + width[4] + width[5]);
          } else {
            width[i] = 0;
          }
          length = 0;
          pos = 0;
          if (this.metaOntology[m][i] != null) {
            pos = tt_table[m].indexOf(this.metaOntology[m][i].charAt(0).toUpperCase() + this.metaOntology[m][i].slice(1));
          }
          if (sumCount[m][this.metaOntology[m][i]] > 0) {
            length = (this.metaOntology[m][i] + "</td><td style='text-align:right'>" + sumCount[m][this.metaOntology[m][i]]).length;
            tt_data = tt_table[m].slice(0, pos - 8) + "<tr class='table-row-bold' style='color:" + this.colours[m][3] + "'><td>" + tt_table[m].slice(pos, length + pos) + "</td></tr>" + tt_table[m].slice(length + pos);
          }
          if (i === 6) {
            if (sumCount[m][this.metaOntology[m][5]] == null) {
              if (tt_table[m].indexOf("[+] Other") != null) {
                pos = tt_table[m].indexOf("[+] Other");
              } else {
                pos = tt_table[m].indexOf(tt_mtype_last);
              }
              tt_data = tt_table[m].slice(0, pos - 8) + "<tr class='table-row-bold' style='color:" + this.colours[m][3] + "'><td>" + tt_table[m].slice(pos);
            } else {
              tt_data = tt_table[m].slice(0, tt_table[m].indexOf("[+] Other") - 8) + "<tr class='table-row-bold' style='color:" + this.colours[m][3] + "'><td>" + tt_table[m].slice(tt_table[m].indexOf("[+] Other"));
            }
          }
          sumBar.append('rect').attr('class', 'summaryMeter').attr('id', i === 6 ? "Other" : this.metaOntology[m][i]).attr('x', !isNaN(x) ? x + this.offset : void 0).attr('y', y).attr('height', 20).attr('width', !isNaN(width[i]) ? Math.abs(width[i]) : void 0).attr('stroke', 'black').attr('stroke-width', 1).attr('fill', this.colours[m][j++]).attr("data-toggle", "popover").attr('data-content', width[i] > 0 ? "<table class='popover-table'><tr><th style='min-width:160px;max-width:160px;text-align:left'>" + this.tt_mtitle[m] + "</th><th style='min-width:110px;max-width:110px;text-align:right'># of Genomes</th></tr>" + tt_data + "</table>" : void 0);
          x += width[i];
          i++;
        }
      }
      svgView.selectAll('.summaryMeter').each(function() {
        return $(this).popover({
          placement: 'bottom',
          html: 'true',
          trigger: 'hover',
          delay: {
            show: 500,
            hide: 500
          },
          animate: 'false',
          container: 'body'
        });
      });
      return true;
    };

    return SummaryView;

  })(ViewTemplate);

}).call(this);
