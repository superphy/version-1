// Generated by CoffeeScript 1.8.0

/*


 File: superphy.coffee
 Desc: Objects & functions for managing views in Superphy
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 7th, 2013
 */

(function() {
  var AlleleTicker, Cartographer, CartographerOverlay, DotCartographer, GenomeController, GeoPhy, GeophyCartographer, GroupView, Histogram, InfoSatelliteCartographer, ListView, LocationController, LocusController, MapView, MatrixTicker, MatrixView, MetaTicker, MsaView, SatelliteCartographer, SelectionMapView, SelectionView, StxController, StxTicker, SuperphyError, TableView, TickerTemplate, TreeView, ViewController, ViewTemplate, cmp, escapeRegExp, mixOf, parseHeader, root, superphyAlert, superphyMetaOntology, trimInput, typeIsArray,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;


  /*
   CLASS SuperphyError
   
   Error object for this library
   */

  SuperphyError = (function(_super) {
    __extends(SuperphyError, _super);

    function SuperphyError(message, name) {
      this.message = message != null ? message : '';
      this.name = name != null ? name : 'Superphy Error';
    }

    return SuperphyError;

  })(Error);


  /*
   CLASS ViewController
    
   Captures events. Updates data and views
   */

  ViewController = (function() {
    function ViewController() {
      if (typeof jQuery === "undefined" || jQuery === null) {
        throw new SuperphyError('jQuery must be loaded before the SuperPhy libary');
      }
      if (typeof URL === "undefined" || URL === null) {
        throw new SuperphyError('SuperPhy library requires the URL library');
      }
      if (typeof Blob === "undefined" || Blob === null) {
        throw new SuperphyError('SuperPhy library requires the Blob library');
      }
    }

    ViewController.prototype.views = [];

    ViewController.prototype.groups = [];

    ViewController.prototype.tickers = [];

    ViewController.prototype.selectedBox = null;

    ViewController.prototype.actionMode = false;

    ViewController.prototype.action = false;

    ViewController.prototype.maxGroups = 10;

    ViewController.prototype.genomeController = void 0;

    ViewController.prototype.init = function(publicGenomes, privateGenomes, actionMode, action, subset) {
      this.actionMode = actionMode;
      this.action = action;
      if (subset == null) {
        subset = null;
      }
      if (!(this.actionMode === 'single_select' || this.actionMode === 'multi_select' || this.actionMode === 'two_groups')) {
        throw new SuperphyError('Unrecognized actionMode in ViewController init() method.');
      }
      this.genomeController = new GenomeController(publicGenomes, privateGenomes, subset);
      this.views = [];
      this.groups = [];
      return this.tickers = [];
    };

    ViewController.prototype.createView = function() {
      var clickStyle, downloadElem, downloadElemDiv, elem, listView, mapView, matView, msaView, tableView, treeView, vNum, viewArgs, viewType;
      viewType = arguments[0], elem = arguments[1], viewArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      clickStyle = 'select';
      vNum = this.views.length + 1;
      if (this.actionMode === 'single_select') {
        clickStyle = 'redirect';
      }
      if (viewType === 'list') {
        listView = new ListView(elem, clickStyle, vNum, viewArgs);
        listView.update(this.genomeController);
        this.views.push(listView);
      } else if (viewType === 'tree') {
        treeView = new TreeView(elem, clickStyle, vNum, viewArgs);
        treeView.update(this.genomeController);
        this.views.push(treeView);
      } else if (viewType === 'msa') {
        msaView = new MsaView(elem, clickStyle, vNum, viewArgs);
        msaView.update(this.genomeController);
        this.views.push(msaView);
      } else if (viewType === 'matrix') {
        matView = new MatrixView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        matView.update(this.genomeController);
        this.views.push(matView);
      } else if (viewType === 'map') {
        mapView = new MapView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        this.views.push(mapView);
      } else if (viewType === 'selmap') {
        mapView = new SelectionMapView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        this.views.push(mapView);
      } else if (viewType === 'table') {
        tableView = new TableView(elem, clickStyle, vNum, viewArgs);
        tableView.update(this.genomeController);
        this.views.push(tableView);
      } else if (viewType === 'jump2table') {
        tableView = new TableView(elem, clickStyle, vNum, viewArgs);
        tableView.update(this.genomeController);
        this.views.push(tableView);
        return;
      } else {
        throw new SuperphyError('Unrecognized viewType <' + viewType + '> in ViewController createView() method.');
        return false;
      }
      downloadElemDiv = jQuery("<div class='download-view'></div>");
      downloadElem = jQuery("<a class='download-view-link' href='#' data-genome-view='" + vNum + "'>Download <i class='fa fa-download'></a>");
      downloadElem.click(function(e) {
        var data, viewNum;
        viewNum = parseInt(this.dataset.genomeView);
        data = viewController.downloadViews(viewNum);
        this.href = data.href;
        this.download = data.file;
        return true;
      });
      downloadElemDiv.append(downloadElem);
      downloadElemDiv.prependTo(elem);
      return true;
    };

    ViewController.prototype.introOptions = function() {
      var intros, v, _i, _len, _ref;
      intros = [];
      intros.push({
        element: document.querySelector('#search-utilities'),
        intro: "Any genome search can be further specified to include various meta-data by checking the corresponding boxes.  This will show more information for each genome on the list, tree, and map, but it will not affect the data.  Searches can also be filtered by keyword or by selection to limit the number of genomes displayed on the list, tree, and map.",
        position: 'right'
      });
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        intros = intros.concat(v.intro());
      }
      return intros;
    };

    ViewController.prototype.createGroup = function(boxEl, buttonEl, clearButtonEl) {
      var gNum, grpView;
      gNum = this.groups.length + 1;
      if (gNum > this.maxGroups) {
        return false;
      }
      grpView = new GroupView(boxEl, gNum);
      grpView.update(this.genomeController);
      this.groups.push(grpView);
      buttonEl.click(function(e) {
        e.preventDefault();
        return viewController.addToGroup(gNum);
      });
      clearButtonEl.click(function(e) {
        e.preventDefault();
        return viewController.clearFromGroup(gNum);
      });
      return true;
    };

    ViewController.prototype.addToGroup = function(grp) {
      var i, selected, v, _i, _len, _ref;
      selected = this.genomeController.selected();
      this.genomeController.assignGroup(selected, grp);
      this.genomeController.unselectAll();
      i = grp - 1;
      this.groups[i].add(selected, this.genomeController);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      if (this.selectedBox != null) {
        return this.selectedBox.update(this.genomeController);
      }
    };

    ViewController.prototype.createTicker = function() {
      var alTicker, elem, matTicker, metaTicker, stxTicker, tNum, tickerArgs, tickerType;
      tickerType = arguments[0], elem = arguments[1], tickerArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      tNum = this.tickers.length + 1;
      if (tickerType === 'meta') {
        metaTicker = new MetaTicker(elem, tNum, tickerArgs);
        metaTicker.update(this.genomeController);
        this.tickers.push(metaTicker);
      } else if (tickerType === 'stx') {
        stxTicker = new StxTicker(elem, tNum, tickerArgs);
        stxTicker.update(this.genomeController);
        this.tickers.push(stxTicker);
      } else if (tickerType === 'matrix') {
        matTicker = new MatrixTicker(elem, tNum, this.genomeController, tickerArgs);
        matTicker.update(this.genomeController);
        this.tickers.push(matTicker);
      } else if (tickerType === 'allele') {
        alTicker = new AlleleTicker(elem, tNum, tickerArgs);
        alTicker.update(this.genomeController);
        this.tickers.push(alTicker);
      } else {
        throw new SuperphyError('Unrecognized tickerType in ViewController createTicker() method.');
        return false;
      }
      return true;
    };

    ViewController.prototype.select = function(g, checked) {
      var v, _i, _len, _ref;
      if (this.actionMode === 'single_select') {
        this.redirect(g);
      } else {
        this.genomeController.select(g, checked);
        _ref = this.views;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          v.select(g, checked);
        }
        if (this.selectedBox != null) {
          this.selectedBox.select(g, this.genomeController, checked);
        }
      }
      return true;
    };

    ViewController.prototype.redirect = function(g) {
      var buttonCloseEl, buttonSubmitEl, displayName, modalView, _ref, _ref1;
      displayName = (_ref = (_ref1 = this.genomeController.private_genomes[g]) != null ? _ref1.displayname : void 0) != null ? _ref : this.genomeController.public_genomes[g].displayname;
      modalView = jQuery('<div class="modal fade" id="view-redirect-modal" tabindex="-1" role="dialog" aria-labelledby="viewRedirectModalLabel" aria-hidden="true"> <div class="modal-dialog modal-sm"> <div class="modal-content"> <div class="modal-header"> <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button> <h4 class="modal-title" id="viewRedirectModalLabel">Retrieve selected genome?</h4> </div> <div class="modal-body"> Would you like to retrieve genome information for the selected genome: <form id="view-redirect-form"> <div class="well well-sm">' + displayName + '</div> <input type="hidden" name="genome" value="' + g + '"/> </form> </div> <div class="modal-footer"> </div> </div> </div> </div>');
      buttonCloseEl = jQuery('<button type="button" class="btn btn-danger" data-dismiss="modal" form="view-redirect-form" value="Cancel">Cancel</button>');
      buttonSubmitEl = jQuery('<button type="submit" id="view-redirect-submit" class="btn btn-success" value="Submit" form="view-redirect-form" formmethod="post" formaction="' + viewController.action + '"> Submit </button>');
      buttonSubmitEl.click(function() {
        return modalView.find('.modal-body').append('<div class="alert alert-success"> <p style="text-align:center">Retrieving genome</p> <div class="loader"> <span></span> </div> </div>');
      });
      modalView.find('.modal-footer').append(buttonCloseEl);
      modalView.find('.modal-footer').append(buttonSubmitEl);
      modalView.modal('show');
      return true;
    };

    ViewController.prototype.removeFromGroup = function(genomeID, grp) {
      var gset, i, v, _i, _len, _ref;
      gset = this.genomeController.genomeSet([genomeID]);
      this.genomeController.deleteGroup(gset);
      i = grp - 1;
      this.groups[i].remove(genomeID);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.clearFromGroup = function(grp) {
      var actionEl;
      actionEl = jQuery("a[data-genome-group='" + grp + "']");
      return actionEl.click();
    };

    ViewController.prototype.groupForm = function(elem, addMoreBool, submitBool, filterBool) {
      var addEl, blockEl, buttEl, buttonEl, clearFormEl, divEl, hiddenFormEl, submitEl;
      blockEl = jQuery("<div id='group-form-block'></div>").appendTo(elem);
      this.addGroupFormRow(blockEl);
      if (addMoreBool) {
        addEl = jQuery("<div class='add-genome-groups row'></div>");
        divEl = jQuery("<div class='col-md-12'></div>").appendTo(addEl);
        buttEl = jQuery("<button class='btn' type='button'>More Genome Groups...</button>").appendTo(divEl);
        buttEl.click(function(e) {
          var reachedMax;
          reachedMax = viewController.addGroupFormRow(jQuery("#group-form-block"));
          if (!reachedMax) {
            jQuery(this).text('Max groups reached').css('color', 'darkgrey');
            return e.preventDefault();
          }
        });
        elem.append(addEl);
      }
      if (submitBool) {
        submitEl = jQuery("<div class='compare-genome-groups row'></div>");
        divEl = jQuery("<div class='col-md-12'></div>").appendTo(submitEl);
        clearFormEl = jQuery("<button class='btn btn-danger' onclick='location.reload()'><span class='fa fa-times'></span> Reset Form</button>").appendTo(divEl);
        if (filterBool) {
          buttonEl = jQuery("<button type='submit' class='btn btn-primary' value='Submit' form='groups-compare-form'><span class='fa fa-check'></span> Filter Groups</button>").appendTo(divEl);
        }
        if (!filterBool) {
          buttonEl = jQuery("<button type='submit' class='btn btn-primary' value='Submit' form='groups-compare-form'><span class='fa fa-check'></span> Analyze Groups</button>").appendTo(divEl);
        }
        hiddenFormEl = jQuery("<form class='form' id='groups-compare-form' method='post' action='" + this.action + "' enctype='application/x-www-form-urlencoded'></form>").appendTo(divEl);
        buttonEl.click((function(_this) {
          return function(e) {
            var alert, genome, groupGenomes, i, _i, _j, _len, _ref;
            e.preventDefault();
            alert = jQuery('<div class="alert alert-danger"> <button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button> You must have at least one genome in either of the groups to compare to. </div>');
            if (!(jQuery('#genome_group1 li').length > 0 || jQuery('#genome_group2 li').length > 0)) {
              blockEl.prepend(alert);
              return false;
            }
            for (i = _i = 1, _ref = _this.groups.length; _i <= _ref; i = _i += 1) {
              groupGenomes = jQuery("#genome_group" + i + " .genome_group_item");
              for (_j = 0, _len = groupGenomes.length; _j < _len; _j++) {
                genome = groupGenomes[_j];
                jQuery("<input type='hidden' name='group" + i + "-genome' value='" + (jQuery(genome).find('a').data('genome')) + "'>").appendTo(hiddenFormEl);
              }
            }
            jQuery("<input type='hidden' name='num-groups' value='" + _this.groups.length + "'>").appendTo(hiddenFormEl);
            return jQuery('#groups-compare-form').submit();
          };
        })(this));
        elem.append(submitEl);
      }
      return true;
    };

    ViewController.prototype.addGroupFormRow = function(elem) {
      var buttEl, clearButtEl, divEl, formEl, gNum, i, listEl, ok, rowEl, _i, _len, _ref;
      if (typeof elem === 'string') {
        elem = jQuery(elem);
      }
      gNum = this.groups.length + 1;
      if (gNum > this.maxGroups) {
        return false;
      }
      rowEl = jQuery("<div class='group-form-row row'></div>").appendTo(elem);
      ok = true;
      _ref = [gNum, gNum + 1];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        formEl = jQuery("<div id='genome-group-form" + i + "' class='genome-group-form col-md-6'></div>");
        listEl = jQuery("<div id='genome-group-list" + i + "' class='genome-group'></div>").appendTo(formEl);
        divEl = jQuery("<div class='genome-group-add-controller'></div>").appendTo(listEl);
        buttEl = jQuery("<button id='genome-group-add" + i + "' class='btn btn-primary' type='button' title='Add genome(s) to Group " + i + "'><span class='fa fa-plus'></span> <span class='input-lg' id='genome-group" + i + "-heading'>Group " + i + "</span></button>").appendTo(divEl);
        clearButtEl = jQuery("<button id='genome-group-clear" + i + "' class='btn btn-primary pull-right' type='button' title='Clear all genome(s) from Group " + i + "'><span class='fa fa-times'></span> <span class='input-lg' id='genome-group" + i + "-heading'></span></button>").appendTo(divEl);
        rowEl.append(formEl);
        ok = this.createGroup(listEl, buttEl, clearButtEl);
      }
      return ok;
    };

    ViewController.prototype.viewAction = function() {
      var vNum, viewArgs;
      vNum = arguments[0], viewArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.views[vNum].viewAction(this.genomeController, viewArgs);
      return true;
    };

    ViewController.prototype.getView = function(vNum) {
      return this.views[vNum];
    };

    ViewController.prototype.updateViews = function(option, checked) {
      var t, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.genomeController.updateMeta(option, checked);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      _ref1 = this.groups;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        v = _ref1[_j];
        v.update(this.genomeController);
      }
      _ref2 = this.tickers;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        t = _ref2[_k];
        t.update(this.genomeController);
      }
      if (this.selectedBox != null) {
        this.selectedBox.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.downloadViews = function(viewNum) {
      var blob, dump, file, href, url;
      url = window.URL || window.webkitURL;
      blob = window.Blob;
      dump = this.views[viewNum - 1].dump(this.genomeController);
      file = new blob([dump.data], {
        type: dump.type
      });
      href = url.createObjectURL(file);
      file = "superphy_download." + dump.ext;
      return {
        href: href,
        file: file
      };
    };

    ViewController.prototype.sideBar = function(elem) {
      var form1, form2, parentTarget, wrapper;
      parentTarget = 'sidebar-group';
      wrapper = jQuery('<div class="panel-group" id="' + parentTarget + '"></div>');
      elem.append(wrapper);
      form1 = jQuery('<div class="panel panel-default"></div>');
      wrapper.append(form1);
      this.metaForm(form1, parentTarget);
      form2 = jQuery('<div class="panel panel-default"></div>');
      wrapper.append(form2);
      this.filterForm(form2, parentTarget);
      return true;
    };

    ViewController.prototype.sideBarGroupManager = function(elem) {
      var form, parentTarget, wrapper;
      parentTarget = 'sidebar-accordion';
      wrapper = jQuery('#sidebar-accordion');
      form = jQuery('<div class="panel panel-default"></div>');
      wrapper.append(form);
      this.groupsSideForm(form, parentTarget);
      return true;
    };

    ViewController.prototype.createGroupsForm = function(elem, addMoreBool, submitBool, filterBool) {
      var form, parentTarget, wrapper;
      parentTarget = 'groups-compare-panel-body';
      wrapper = jQuery('<div class="panel panel-default" id="groups-compare-panel"></div>');
      elem.append(wrapper);
      form = jQuery('<div class="panel-body" id="' + parentTarget + '"></div>');
      wrapper.append(form);
      this.groupForm(form, addMoreBool, submitBool, filterBool);
      return true;
    };

    ViewController.prototype.metaForm = function(elem, parentStr) {
      var form;
      form = '<div class="panel-heading">' + '<div class="panel-title">' + '<a data-toggle="collapse" href="#meta-form"><i class="fa fa-eye"></i> Meta-data ' + '<span class="caret"></span></a>' + '</div></div>' + '<div id="meta-form" class="collapse in">' + '<div class="panel-body">' + '<p>Select meta-data displayed:</p>' + '<form class="form-inline">' + '<fieldset>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="accession"> Accession # </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="strain"> Strain </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="serotype"> Serotype </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_host"> Isolation Host </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_source"> Isolation Source </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="isolation_date"> Isolation Date </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="syndrome"> Symptoms / Diseases </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="stx1_subtype"> Stx1 Subtype </label></div>' + '<div class="checkbox col-md-12"><label><input class="meta-option checkbox" type="checkbox" name="meta-option" value="stx2_subtype"> Stx2 Subtype </label></div>' + '</fieldset>' + '</form>' + '</div></div>';
      elem.append(form);
      jQuery('input[name="meta-option"]').change(function() {
        return viewController.updateViews(this.value, this.checked);
      });
      return true;
    };

    ViewController.prototype.filterViews = function(filterForm) {
      var searchTerms, t, term, v, _i, _j, _len, _len1, _ref, _ref1;
      if (filterForm === 'selection') {
        this.genomeController.filterBySelection();
      } else {
        searchTerms = null;
        if (filterForm === 'fast') {
          term = jQuery("#fast-filter > input").val().toLowerCase();
          if ((term != null) && term.length) {
            searchTerms = [];
            searchTerms.push({
              searchTerm: term,
              dataField: 'viewname',
              negate: false
            });
          }
        } else {
          searchTerms = this._parseFilterForm();
          if (searchTerms == null) {
            return false;
          }
        }
        this.genomeController.filter(searchTerms);
      }
      this._toggleFilterStatus(true);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      _ref1 = this.tickers;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        t.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.resetFilter = function() {
      var t, v, _i, _j, _len, _len1, _ref, _ref1, _results;
      this.genomeController.filter();
      this._toggleFilterStatus();
      this._clearFilterForm();
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      _ref1 = this.tickers;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        _results.push(t.update(this.genomeController));
      }
      return _results;
    };

    ViewController.prototype.filterForm = function(elem, parentStr) {
      var advDiv, advForm, advGroup, advLab, advRadio, container, delButton, fastDiv, fastGroup, fastLab, fastRadio, fbs, filtButton, filtType, filterOff, filterOn, filterStatus, header, numVisible, selDiv, selGroup, selLab, selRadio, sf;
      header = jQuery('<div class="panel-heading">' + '<div class="panel-title">' + '<a data-toggle="collapse" href="#filter-form"><i class="fa fa-filter"></i> Filter ' + '<span class="caret"></span></a>' + '</div></div>').appendTo(elem);
      container = jQuery('<div id="filter-form" class="panel-collapse collapse in"></div>');
      numVisible = this.genomeController.filtered;
      filterStatus = jQuery('<div id="filter-status"></div>');
      filterOn = jQuery("<div id='filter-on'><div id='filter-on-text' class='alert alert-warning'>Filter active. " + numVisible + " genomes visible.</div></div>");
      filterOff = jQuery('<div id="filter-off"></div>');
      delButton = jQuery('<button id="remove-filter" type="button" class="btn btn-sm">Clear</button>');
      delButton.click(function(e) {
        e.preventDefault();
        return viewController.resetFilter();
      });
      delButton.appendTo(filterOn);
      if (numVisible > 0) {
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      filterStatus.append(filterOn);
      filterStatus.append(filterOff);
      container.append(filterStatus);
      container.append('<p>Limit genomes displayed in views by:</p>');
      filtType = jQuery('<form id="select-filter-form" class="form-horizontal"></form>');
      fastGroup = jQuery('<div class="form-group"></div>');
      fastDiv = jQuery('<div class="col-xs-1"></div>').appendTo(fastGroup);
      fastRadio = jQuery('<input id="fast" type="radio" name="filter-form-type" value="fast" checked>').appendTo(fastDiv);
      fastLab = jQuery('<label class="col-xs-10" for="fast">Basic</label>').appendTo(fastGroup);
      fastRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").show();
          jQuery("#adv-filter").hide();
          jQuery("#selection-filter").hide();
        }
        return true;
      });
      filtType.append(fastGroup);
      advGroup = jQuery('<div class="form-group"></div>');
      advDiv = jQuery('<div class="col-xs-1"></div>').appendTo(advGroup);
      advRadio = jQuery('<input type="radio" id="adv" name="filter-form-type" value="advanced">').appendTo(advDiv);
      advLab = jQuery('<label class="col-xs-10" for="adv">Advanced</label>').appendTo(advGroup);
      advRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").show();
          jQuery("#selection-filter").hide();
        }
        return true;
      });
      filtType.append(advGroup);
      selGroup = jQuery('<div class="form-group"></div>');
      selDiv = jQuery('<div class="col-xs-1"></div>').appendTo(selGroup);
      selRadio = jQuery('<input id="sel" type="radio" name="filter-form-type" value="selection">').appendTo(selDiv);
      selLab = jQuery('<label class="col-xs-10" for="sel">By Selection</label>').appendTo(selGroup);
      selRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").hide();
          jQuery("#selection-filter").show();
        }
        return true;
      });
      filtType.append(selGroup);
      container.append(filtType);
      sf = jQuery("<div id='fast-filter'></div>");
      this.addFastFilter(sf);
      container.append(sf);
      advForm = jQuery("<div id='adv-filter'></div>");
      this.addAdvancedFilter(advForm);
      advForm.hide();
      container.append(advForm);
      fbs = jQuery("<div id='selection-filter'>" + "<p>A selection in one of the views (i.e. genomes selected in a clade or map region)</p>" + "</div>");
      filtButton = jQuery('<button id="filter-selection-button" type="button" class="btn btn-sm">Filter by Selection</button>');
      filtButton.click(function(e) {
        e.preventDefault();
        return viewController.filterViews('selection');
      });
      fbs.append(filtButton);
      fbs.hide();
      container.append(fbs);
      container.appendTo(elem);
      return true;
    };

    ViewController.prototype._toggleFilterStatus = function(attempt) {
      var filterOff, filterOn, numVisible;
      if (attempt == null) {
        attempt = false;
      }
      numVisible = this.genomeController.filtered;
      filterOn = jQuery('#filter-on');
      filterOff = jQuery('#filter-off');
      if (numVisible > 0) {
        filterOn.find('#filter-on-text').text("Filter active. " + numVisible + " genomes visible.");
        filterOn.show();
        filterOff.hide();
      } else if (numVisible === 0 && attempt) {
        filterOn.find('#filter-on-text').text("No genomes match search criteria.");
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      return true;
    };

    ViewController.prototype._toggleSelectAll = function(switchOn, hardLimit) {
      var buttonGp, divEl, numVisible, selectAllButt, selectAllRow, unSelectAllButt;
      numVisible = this.genomeController.filtered;
      selectAllRow = jQuery('.select-all-genomes-row');
      selectAllRow.empty();
      divEl = jQuery('<div class="col-md-6"></div>');
      buttonGp = jQuery('<div class="btn-group"></div>').appendTo(divEl);
      selectAllButt = jQuery('<button id="table-select-all" class="btn btn-link">Select All</button>').appendTo(buttonGp);
      unSelectAllButt = jQuery('<button id="table-unselect-all" class="btn btn-link">Unselect All</button>').appendTo(buttonGp);
      selectAllButt.click((function(_this) {
        return function(e) {
          var g, _i, _j, _len, _len1, _ref, _ref1, _results;
          e.preventDefault();
          _ref = _this.genomeController.pubVisible;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            g = _ref[_i];
            _this.select(g, true);
          }
          _ref1 = _this.genomeController.pvtVisible;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            g = _ref1[_j];
            _results.push(_this.select(g, true));
          }
          return _results;
        };
      })(this));
      unSelectAllButt.click((function(_this) {
        return function(e) {
          var g, _i, _j, _len, _len1, _ref, _ref1, _results;
          e.preventDefault();
          _ref = _this.genomeController.pubVisible;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            g = _ref[_i];
            _this.select(g, false);
          }
          _ref1 = _this.genomeController.pvtVisible;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            g = _ref1[_j];
            _results.push(_this.select(g, false));
          }
          return _results;
        };
      })(this));
      if (switchOn && numVisible <= hardLimit) {
        selectAllRow.append(divEl);
      } else {

      }
      return true;
    };

    ViewController.prototype._clearFilterForm = function() {
      var advForm, sf;
      sf = jQuery("#fast-filter");
      sf.empty();
      this.addFastFilter(sf);
      advForm = jQuery("#adv-filter");
      advForm.empty();
      this.addAdvancedFilter(advForm);
      return true;
    };

    ViewController.prototype.addAdvancedFilter = function(elem) {
      var addRow, advButton, advRows;
      elem.append("<p>Boolean keyword search of specified meta-data fields</p>");
      advRows = jQuery("<div id='adv-filter-rows'></div>");
      elem.append(advRows);
      this.addFilterRow(advRows, 1);
      advButton = jQuery('<button id="adv-filter-submit" type="button" class="btn btn-sm">Filter</button>');
      elem.append(advButton);
      advButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('advanced');
      });
      addRow = jQuery('<a href="#" class="adv-filter-addition">Add term</a>');
      addRow.click(function(e) {
        var rowI, rows;
        e.preventDefault();
        rows = jQuery('.adv-filter-row');
        rowI = rows.length + 1;
        return viewController.addFilterRow(jQuery('#adv-filter-rows'), rowI);
      });
      elem.append(addRow);
      return true;
    };


    /*  
     * FUNC addFilterRow
     * Adds additional search term row to advanced filter form.
     * Multiple search terms are joined using boolean operators.
     *
     * PARAMS
     * elem - jQuery element object of rows
     * rowNum - sequential number for new row
     * 
     * RETURNS
     * boolean 
     *       
    addFilterRow: (elem, rowNum) ->
      
       * Row wrapper
      row = jQuery('<div class="adv-filter-row" data-filter-row="' + rowNum + '"></div>').appendTo(elem)
      
       * Term join operation
      if rowNum isnt 1
        jQuery('<select name="adv-filter-op" data-filter-row="' + rowNum + '">' +
          '<option value="and" selected="selected">AND</option>' +
          '<option value="or">OR</option>' +
          '<option value="not">NOT</option>' +
          '</select>').appendTo(row)
      
       * Field type
      dropDown = jQuery('<select name="adv-filter-field" data-filter-row="' + rowNum + '"></select>').appendTo(row)
      for k,v of @genomeController.metaMap
          dropDown.append('<option value="' + k + '">' + v + '</option>')
      
      dropDown.append('<option value="displayname" selected="selected">Genome name</option>')
      
       * Change type of search term box depending on field type
      dropDown.change ->
        thisRow = this.dataset.filterRow
        if @.value is 'isolation_date'
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide()
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show()
        else
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show()
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide()
        true
      
       * Keyword-based search wrapper
      keyw = jQuery('<div class="adv-filter-keyword" data-filter-row="' + rowNum + '"></div>)')
      
       * Search term box
      jQuery('<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>').appendTo(keyw)
      keyw.appendTo(row)
      
       * Predefined search term dropdowns
       * Host
      
      
    
       * Date-based search wrapper
      dt = jQuery('<div class="adv-filter-date" data-filter-row="' + rowNum + '"></div>)')
      dt.append('<select name="adv-filter-before" data-filter-row="' + rowNum + '">' +
        '<option value="before" selected="selected">before</option>' +
        '<option value="after">after</option>' +
        '</select>')
      dt.append('<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>')
      dt.append('<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>')
      dt.append('<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>')
      dt.hide()
      dt.appendTo(row)
      
       * Delete button
      if rowNum isnt 1
        delRow = jQuery('<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>')
        delRow.appendTo(row)
    
         * Delete row wrapper
        delRow.click (e) ->
          e.preventDefault()
          thisRow = this.dataset.filterRow
          jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove()
    
      true
     */

    ViewController.prototype.addFilterRow = function(elem, rowNum) {
      var db, delRow, dropDown, dt, fd, fdt, ff, fh, fht, fs, fst, hosts, k, keyw, row, rowObj, sources, syndromes, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      row = '<div class="adv-filter-row" data-filter-row="' + rowNum + '">';
      row += '<div class="adv-filter-header">';
      if (rowNum !== 1) {
        row += '<select name="adv-filter-op" data-filter-row="' + rowNum + '">' + '<option value="and" selected="selected">AND</option>' + '<option value="or">OR</option>' + '<option value="not">NOT</option>' + '</select>';
      }
      dropDown = '<select name="adv-filter-field" data-filter-row="' + rowNum + '">';
      _ref = this.genomeController.metaMap;
      for (k in _ref) {
        v = _ref[k];
        dropDown += '<option value="' + k + '">' + v + '</option>';
      }
      dropDown += '<option value="displayname" selected="selected">Genome name</option></select>';
      row += dropDown;
      row += '</div><div class="adv-filter-body">';
      keyw = '<div class="adv-filter-keyword" data-filter-row="' + rowNum + '">';
      keyw += '<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>';
      keyw += '</div>';
      row += keyw;
      hosts = '<div class="adv-filter-host-terms" data-filter-row="' + rowNum + '">';
      hosts += '<select name="adv-filter-hosts" data-filter-row="' + rowNum + '">';
      hosts += '<option value="">--Select Host--</option>';
      _ref1 = superphyMetaOntology["hosts"];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        hosts += '<option value="' + v + '">' + v + '</option>';
      }
      hosts += '<option value="other">Other (fill in field below)</option></select>';
      hosts += '<input type="text" name="adv-filter-host-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
      hosts += '</div>';
      row += hosts;
      sources = '<div class="adv-filter-source-terms" data-filter-row="' + rowNum + '">';
      sources += '<select name="adv-filter-sources" data-filter-row="' + rowNum + '">';
      sources += '<option value="">--Select Source--</option>';
      _ref2 = superphyMetaOntology["sources"];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        v = _ref2[_j];
        sources += '<option value="' + v + '">' + v + '</option>';
      }
      sources += '<option value="other">Other (fill in field below)</option></select>';
      sources += '<input type="text" name="adv-filter-source-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
      sources += '</div>';
      row += sources;
      syndromes = '<div class="adv-filter-syndrome-terms" data-filter-row="' + rowNum + '">';
      syndromes += '<select name="adv-filter-syndromes" data-filter-row="' + rowNum + '">';
      syndromes += '<option value="">--Select Syndrome--</option>';
      _ref3 = superphyMetaOntology["syndromes"];
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        v = _ref3[_k];
        syndromes += '<option value="' + v + '">' + v + '</option>';
      }
      syndromes += '<option value="other">Other (fill in field below)</option></select>';
      syndromes += '<input type="text" name="adv-filter-syndrome-other" data-filter-row="' + rowNum + '" placeholder="Other" disabled></input>';
      syndromes += '</div>';
      row += syndromes;
      dt = '<div class="adv-filter-date" data-filter-row="' + rowNum + '">';
      dt += '<select name="adv-filter-before" data-filter-row="' + rowNum + '">' + '<option value="before" selected="selected">before</option>' + '<option value="after">after</option>' + '</select>';
      dt += '<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>';
      dt += '<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>';
      dt += '<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>';
      dt += '</div>';
      row += dt;
      if (rowNum !== 1) {
        delRow = '<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>';
        row += delRow;
      }
      row += '</div>';
      rowObj = jQuery(row);
      ff = rowObj.find('[name="adv-filter-field"][data-filter-row="' + rowNum + '"]');
      ff.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'isolation_date') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
        } else if (this.value === 'isolation_host') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').show();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
        } else if (this.value === 'isolation_source') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').show();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
        } else if (this.value === 'syndrome') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').show();
        } else {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]').hide();
          jQuery('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]').hide();
        }
        return true;
      });
      fht = rowObj.find('.adv-filter-host-terms[data-filter-row="' + rowNum + '"]');
      fh = fht.find('[name="adv-filter-hosts"]');
      fh.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'other') {
          return jQuery('[name="adv-filter-host-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
        } else {
          return jQuery('[name="adv-filter-host-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
        }
      });
      fht.hide();
      fst = rowObj.find('.adv-filter-source-terms[data-filter-row="' + rowNum + '"]');
      fs = fst.find('[name="adv-filter-sources"]');
      fs.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'other') {
          return jQuery('[name="adv-filter-source-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
        } else {
          return jQuery('[name="adv-filter-source-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
        }
      });
      fst.hide();
      fdt = rowObj.find('.adv-filter-syndrome-terms[data-filter-row="' + rowNum + '"]');
      fd = fdt.find('[name="adv-filter-syndromes"]');
      fd.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'other') {
          return jQuery('[name="adv-filter-syndrome-other"][data-filter-row="' + rowNum + '"]').prop("disabled", false);
        } else {
          return jQuery('[name="adv-filter-syndrome-other"][data-filter-row="' + rowNum + '"]').prop("disabled", true);
        }
      });
      fdt.hide();
      fd = rowObj.find('.adv-filter-date[data-filter-row="' + rowNum + '"]');
      fd.hide();
      if (rowNum !== 1) {
        db = rowObj.find('.adv-filter-subtraction[data-filter-row="' + rowNum + '"]');
        db.click(function(e) {
          var thisRow;
          e.preventDefault();
          thisRow = this.dataset.filterRow;
          console.log('del' + thisRow);
          return jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove();
        });
      }
      elem.append(rowObj);
      return true;
    };

    ViewController.prototype.addFastFilter = function(elem) {
      var fastButton, tBox;
      elem.append("<p>Basic genome name filter</p>");
      tBox = jQuery('<input type="text" name="fast-filter-term" placeholder="Filter by..."></input>');
      fastButton = jQuery('<button id="fast-filter-submit" type="button" class="btn btn-sm">Filter</button>');
      fastButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('fast');
      });
      tBox.appendTo(elem);
      fastButton.appendTo(elem);
      return true;
    };

    ViewController.prototype._parseFilterForm = function() {
      var bef, date, df, dy, isBefore, isDate, mn, negate, op, row, rowNum, rows, searchTerms, t, term, yr, _i, _len;
      rows = jQuery('.adv-filter-row');
      searchTerms = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        t = {};
        rowNum = parseInt(row.dataset.filterRow);
        df = jQuery("[name='adv-filter-field'][data-filter-row='" + rowNum + "']").val();
        t.dataField = df;
        isDate = false;
        if (df === 'isolation_date') {
          isDate = true;
        }
        if (!isDate) {
          if (df === 'isolation_host') {
            term = jQuery("[name='adv-filter-hosts'][data-filter-row='" + rowNum + "']").val();
            if (term === 'other') {
              term = jQuery("[name='adv-filter-host-other'][data-filter-row='" + rowNum + "']").val();
              term = trimInput(term, 'keyword');
            }
            if (!((term != null) && term !== "")) {
              alert('Error: empty field.');
              return null;
            }
            t.searchTerm = term;
          } else if (df === 'isolation_source') {
            term = jQuery("[name='adv-filter-sources'][data-filter-row='" + rowNum + "']").val();
            if (term === 'other') {
              term = jQuery("[name='adv-filter-source-other'][data-filter-row='" + rowNum + "']").val();
              term = trimInput(term, 'keyword');
            }
            if (!((term != null) && term !== "")) {
              alert('Error: empty field.');
              return null;
            }
            t.searchTerm = term;
          } else if (df === 'syndrome') {
            term = jQuery("[name='adv-filter-syndromes'][data-filter-row='" + rowNum + "']").val();
            if (term === 'other') {
              term = jQuery("[name='adv-filter-syndrome-other'][data-filter-row='" + rowNum + "']").val();
              term = trimInput(term, 'keyword');
            }
            if (!((term != null) && term !== "")) {
              alert('Error: empty field.');
              return null;
            }
            t.searchTerm = term;
          } else {
            term = jQuery("[name='adv-filter-term'][data-filter-row='" + rowNum + "']").val();
            term = trimInput(term, 'keyword');
            if (!((term != null) && term !== "")) {
              alert('Error: empty field.');
              return null;
            }
            t.searchTerm = term;
          }
        } else {
          bef = jQuery("[name='adv-filter-before'][data-filter-row='" + rowNum + "']").val();
          if (!(bef === 'before' || bef === 'after')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-before" must contain strings "before","after".');
          }
          isBefore = true;
          if (bef === 'after') {
            isBefore = false;
          }
          yr = jQuery("[name='adv-filter-year'][data-filter-row='" + rowNum + "']").val();
          yr = trimInput(yr, 'Year');
          if (yr == null) {
            return null;
          }
          if (!/^[1-9][0-9]{3}$/.test(yr)) {
            alert('Error: invalid Year.');
            return null;
          }
          mn = jQuery("[name='adv-filter-mon'][data-filter-row='" + rowNum + "']").val();
          if (mn != null) {
            mn = jQuery.trim(mn);
          }
          if ((mn != null) && mn.length) {
            if (!/^[0-9]{1,2}$/.test(mn)) {
              alert('Error: invalid Month.');
              return null;
            }
          } else {
            mn = '01';
          }
          dy = jQuery("[name='adv-filter-day'][data-filter-row='" + rowNum + "']").val();
          if (dy != null) {
            dy = jQuery.trim(dy);
          }
          if ((dy != null) && dy.length) {
            if (!/^[0-9]{1,2}$/.test(dy)) {
              alert('Error: invalid Day.');
              return null;
            }
          } else {
            dy = '01';
          }
          date = Date.parse("" + yr + "-" + mn + "-" + dy);
          if (isNaN(date)) {
            alert('Error: invalid date.');
            return null;
          }
          t.date = date;
          t.before = isBefore;
        }
        if (rowNum !== 1) {
          op = jQuery("[name='adv-filter-op'][data-filter-row='" + rowNum + "']").val();
          negate = false;
          if (!(op === 'or' || op === 'and' || op === 'not')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-op" must contain strings "and","or","not".');
          }
          if (op === 'not') {
            op = 'and';
            negate = true;
          }
          t.op = op;
          t.negate = negate;
          searchTerms.push(t);
        } else {
          t.negate = false;
          searchTerms.unshift(t);
        }
      }
      return searchTerms;
    };

    ViewController.prototype.createSelectionView = function(boxEl, countEl) {
      var selView;
      if (countEl == null) {
        countEl = null;
      }
      if (this.selectedBox != null) {
        throw new SuperphyError('Existing SelectionView. Cannot create multiple views of this type.');
      }
      selView = new SelectionView(boxEl, countEl);
      selView.update(this.genomeController);
      this.selectedBox = selView;
      return true;
    };

    ViewController.prototype.submitGenomes = function(formEl, paramType) {
      var g, genomes, gset, input, k, v, _i, _len, _ref, _ref1, _results, _results1;
      if (paramType == null) {
        paramType = 'selected';
      }
      if (paramType === 'selected') {
        gset = this.genomeController.selected();
        genomes = gset["public"].concat(gset["private"]);
        _results = [];
        for (_i = 0, _len = genomes.length; _i < _len; _i++) {
          g = genomes[_i];
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', 'genome');
          input.val(g);
          _results.push(formEl.append(input));
        }
        return _results;
      } else if (paramType === 'grouped') {
        _ref = this.genomeController.public_genomes;
        for (k in _ref) {
          v = _ref[k];
          if (!(v.assignedGroup != null)) {
            continue;
          }
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', "group" + v.assignedGroup);
          input.val(g);
          formEl.append(input);
        }
        _ref1 = this.genomeController.private_genomes;
        _results1 = [];
        for (k in _ref1) {
          v = _ref1[k];
          if (!(v.assignedGroup != null)) {
            continue;
          }
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', "group" + v.assignedGroup);
          input.val(g);
          _results1.push(formEl.append(input));
        }
        return _results1;
      } else {
        throw new SuperphyError("Unknown paramType parameter: " + paramType);
      }
    };

    ViewController.prototype.highlightInView = function(searchStr, vNum) {
      var targetList;
      if (!(searchStr && searchStr.length)) {
        return false;
      }
      targetList = this.genomeController.find(searchStr);
      if (targetList && targetList.length) {
        this.views[vNum].highlightGenomes(this.genomeController, targetList);
      } else {
        superphyAlert("Search string " + searchStr + " matches no currently visible genomes.", "None Found");
      }
      return true;
    };

    return ViewController;

  })();

  if (!root.ViewController) {
    root.viewController = new ViewController;
  }


  /*
   CLASS ViewTemplate
   
   Template object for views. Defines required and
   common properties/methods. All view objects
   are descendants of the ViewTemplate.
   */

  ViewTemplate = (function() {
    function ViewTemplate(parentElem, style, elNum) {
      this.parentElem = parentElem;
      this.style = style != null ? style : 'select';
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    ViewTemplate.prototype.type = void 0;

    ViewTemplate.prototype.elNum = 1;

    ViewTemplate.prototype.elName = 'view';

    ViewTemplate.prototype.elID = void 0;

    ViewTemplate.prototype.parentElem = void 0;

    ViewTemplate.prototype.style = 'select';

    ViewTemplate.prototype.update = function(genomes) {
      throw new SuperphyError("ViewTemplate method update() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.updateCSS = function(gset, genomes) {
      throw new SuperphyError("ViewTemplate method updateCSS() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.select = function(genome, isSelected) {
      throw new SuperphyError("ViewTemplate method select() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.dump = function(genomes) {
      throw new SuperphyError("ViewTemplate method dump() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.viewAction = function() {
      var args, genomes;
      genomes = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      throw new SuperphyError("viewAction method has not been defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.highlightGenomes = function() {
      var args, genomes, targetList;
      genomes = arguments[0], targetList = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      throw new SuperphyError("highlightGenomes method has not been defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    return ViewTemplate;

  })();


  /*
   CLASS ListView
   
   Genome list
   
   Always genome-based
   Returns genome ID to redirect/select when genome list item is clicked
   */

  ListView = (function(_super) {
    __extends(ListView, _super);

    function ListView(parentElem, style, elNum, listArgs) {
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if ((listArgs != null) && (listArgs[0] != null)) {
        this.locusData = listArgs[0];
      }
      ListView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
    }

    ListView.prototype.type = 'list';

    ListView.prototype.elName = 'genome_list';

    ListView.prototype.locusData = null;

    ListView.prototype.update = function(genomes) {
      var ft, listElem, t1, t2;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      t1 = new Date();
      this._appendGenomes(listElem, genomes.pubVisible, genomes.public_genomes, this.style, false);
      this._appendGenomes(listElem, genomes.pvtVisible, genomes.private_genomes, this.style, true);
      t2 = new Date();
      ft = t2 - t1;
      console.log('ListView update elapsed time: ' + ft);
      return true;
    };

    ListView.prototype._appendGenomes = function(el, visibleG, genomes, style, priv) {
      var actionEl, checked, cls, g, labEl, listEl, name, thiscls, _i, _len;
      cls = this.cssClass();
      if (priv && visibleG.length) {
        el.append("<li class='genome_list_spacer'>---- USER-SUBMITTED GENOMES ----</li>");
      }
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        name = genomes[g].viewname;
        if (this.locusData != null) {
          name += this.locusData.genomeString(g);
        }
        if (style === 'redirect') {
          listEl = jQuery("<li class='" + thiscls + "'>" + name + "</li>");
          actionEl = jQuery("<a href='#' data-genome='" + g + "'> <span class='fa fa-search'></span>info</a>");
          actionEl.click(function(e) {
            var gid;
            e.preventDefault();
            gid = this.dataset.genome;
            return viewController.select(gid, true);
          });
          listEl.append(actionEl);
          el.append(listEl);
        } else if (style === 'select') {
          checked = '';
          if (genomes[g].isSelected) {
            checked = 'checked';
          }
          listEl = jQuery("<li class='" + thiscls + "'></li>");
          labEl = jQuery("<label class='checkbox'>" + name + "</label>");
          actionEl = jQuery("<input class='checkbox' type='checkbox' value='" + g + "' " + checked + "/>");
          actionEl.change(function(e) {
            e.preventDefault();
            return viewController.select(this.value, this.checked);
          });
          labEl.append(actionEl);
          listEl.append(labEl);
          el.append(listEl);
        } else {
          return false;
        }
      }
      return true;
    };

    ListView.prototype.updateCSS = function(gset, genomes) {
      var listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call ListView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    ListView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = changedG.length; _i < _len; _i++) {
        g = changedG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        liEl = null;
      }
      if (this.style === 'redirect') {
        descriptor = "td > a[data-genome='" + g + "']";
        itemEl = el.find(descriptor);
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
          return false;
        }
        liEl = itemEl.parent();
      } else if (this.style === 'select') {
        descriptor = "td input[value='" + g + "']";
        itemEl = el.find(descriptor);
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
          return false;
        }
        liEl = itemEl.parents().eq(1);
      } else {
        return false;
      }
      liEl.attr('class', thiscls);
      return true;
    };

    ListView.prototype.select = function(genome, isSelected) {
      var descriptor, itemEl;
      itemEl = null;
      if (this.style === 'select') {
        descriptor = "li input[value='" + genome + "']";
        itemEl = jQuery(descriptor);
      } else {
        return false;
      }
      if (!((itemEl != null) && itemEl.length)) {
        throw new SuperphyError("List element for genome " + genome + " not found in ListView " + this.elID);
        return false;
      }
      itemEl.prop('checked', isSelected);
      return true;
    };

    ListView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, _ref, _ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var _i, _len, _ref, _results;
        _ref = genomes.mtypes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          _results.push(genomes.metaMap[k]);
        }
        return _results;
      })();
      header.unshift("Genome name");
      output += "#" + header.join("\t") + "\n";
      _ref = genomes.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      _ref1 = genomes.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    return ListView;

  })(ViewTemplate);


  /*
   CLASS GroupView
   
   A special type of genome list that is used to temporarily store the user's
   selected genomes.
   
   Only one 'style' which provides a remove button to remove group from group.
   Will be updated by changes to the meta-display options but not by filtering.
   */

  GroupView = (function() {
    function GroupView(parentElem, elNum) {
      this.parentElem = parentElem;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    GroupView.prototype.type = 'group';

    GroupView.prototype.elNum = 1;

    GroupView.prototype.elName = 'genome_group';

    GroupView.prototype.elID = void 0;

    GroupView.prototype.update = function(genomes) {
      var ingrp, listElem;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      ingrp = genomes.grouped(this.elNum);
      this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
      this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
      return true;
    };

    GroupView.prototype.add = function(genomeSet, genomes) {
      var listElem;
      listElem = jQuery("#" + this.elID);
      if (!listElem.length) {
        listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      if (genomeSet["public"] != null) {
        this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
      }
      if (genomeSet["private"] != null) {
        return this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
      }
    };

    GroupView.prototype._appendGenomes = function(el, visibleG, genomes) {
      var actionEl, cls, g, listEl, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
        actionEl = jQuery("<a href='#' data-genome='" + g + "' data-genome-group='" + this.elNum + "'> <i class='fa fa-times'></a>");
        actionEl.click(function(e) {
          var gid, grp;
          e.preventDefault();
          gid = this.dataset.genome;
          grp = this.dataset.genomeGroup;
          console.log('clicked remove on ' + gid);
          return viewController.removeFromGroup(gid, grp);
        });
        listEl.append(actionEl);
        el.append(listEl);
      }
      return true;
    };

    GroupView.prototype.remove = function(gid) {
      var descriptor, linkEl, listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call GroupView method remove().");
      }
      descriptor = "li > a[data-genome='" + gid + "']";
      linkEl = listEl.find(descriptor);
      if (!((linkEl != null) && linkEl.length)) {
        throw new SuperphyError("List item element for genome " + gid + " not found in GroupView " + this.elID);
        return false;
      }
      linkEl.parent('li').remove();
      return true;
    };

    GroupView.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    return GroupView;

  })();


  /*
   CLASS GenomeController
   
   Manages private/public genome list
   */

  GenomeController = (function() {
    function GenomeController(public_genomes, private_genomes, subset) {
      var i, newPri, newPub, _i, _len;
      this.public_genomes = public_genomes;
      this.private_genomes = private_genomes;
      if (subset == null) {
        subset = null;
      }
      if (subset != null) {
        newPub = {};
        newPri = {};
        for (_i = 0, _len = subset.length; _i < _len; _i++) {
          i = subset[_i];
          if (this.public_genomes[i] != null) {
            newPub[i] = this.public_genomes[i];
          } else if (this.private_genomes[i] != null) {
            newPri[i] = this.private_genomes[i];
          }
        }
        this.public_genomes = newPub;
        this.private_genomes = newPri;
      }
      this.update();
      this.filter();
      this.genomeSetId = 0;
    }

    GenomeController.prototype.pubVisible = [];

    GenomeController.prototype.pvtVisible = [];

    GenomeController.prototype.visibleMeta = {
      strain: false,
      serotype: false,
      isolation_host: false,
      isolation_source: false,
      isolation_date: false,
      accession: false,
      syndrome: false,
      stx1_subtype: false,
      stx2_subtype: false
    };

    GenomeController.prototype.metaMap = {
      'strain': 'Strain',
      'serotype': 'Serotype',
      'isolation_host': 'Host',
      'isolation_source': 'Source',
      'isolation_date': 'Date of isolation',
      'accession': 'Accession ID',
      'syndrome': 'Symptom / Disease',
      'stx1_subtype': 'Stx1 Subtype',
      'stx2_subtype': 'Stx2 Subtype'
    };

    GenomeController.prototype.mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype', 'accession'];

    GenomeController.prototype.publicRegexp = new RegExp('^public_');

    GenomeController.prototype.privateRegexp = new RegExp('^private_');

    GenomeController.prototype.filtered = 0;

    GenomeController.prototype.update = function() {
      var g, id, ma, _ref, _ref1;
      _ref = this.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        ma = this.label(g, this.visibleMeta, null);
        g.viewname = ma.join('|');
        g.meta_array = ma;
      }
      _ref1 = this.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        ma = this.label(g, this.visibleMeta, null);
        g.viewname = ma.join('|');
        g.meta_array = ma;
      }
      return true;
    };

    GenomeController.prototype.filter = function(searchTerms) {
      var g, i, pubGenomeIds, pvtGenomeIds, results, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (searchTerms == null) {
        searchTerms = null;
      }
      pubGenomeIds = [];
      pvtGenomeIds = [];
      if (searchTerms != null) {
        results = this._runFilter(searchTerms);
        pubGenomeIds = results["public"];
        pvtGenomeIds = results["private"];
        this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
        if (this.filtered !== 0) {
          _ref = this.public_genomes;
          for (i in _ref) {
            g = _ref[i];
            g.visible = false;
          }
          _ref1 = this.private_genomes;
          for (i in _ref1) {
            g = _ref1[i];
            g.visible = false;
          }
          for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
            g = pubGenomeIds[_i];
            this.public_genomes[g].visible = true;
          }
          for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
            g = pvtGenomeIds[_j];
            this.private_genomes[g].visible = true;
          }
          this.pubVisible = pubGenomeIds.sort((function(_this) {
            return function(a, b) {
              return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
            };
          })(this));
          this.pvtVisible = pvtGenomeIds.sort((function(_this) {
            return function(a, b) {
              return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
            };
          })(this));
        }
      } else {
        pubGenomeIds = Object.keys(this.public_genomes);
        pvtGenomeIds = Object.keys(this.private_genomes);
        this.filtered = 0;
        _ref2 = this.public_genomes;
        for (i in _ref2) {
          g = _ref2[i];
          g.visible = true;
        }
        _ref3 = this.private_genomes;
        for (i in _ref3) {
          g = _ref3[i];
          g.visible = true;
        }
        this.pubVisible = pubGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
          };
        })(this));
        this.pvtVisible = pvtGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
          };
        })(this));
      }
      this.genomeSetId++;
      return true;
    };

    GenomeController.prototype.filterBySelection = function() {
      var g, gset, i, pubGenomeIds, pvtGenomeIds, _i, _j, _len, _len1, _ref, _ref1;
      gset = this.selected();
      pubGenomeIds = gset["public"];
      pvtGenomeIds = gset["private"];
      this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
      if (this.filtered === 0) {
        this.filter();
      } else {
        _ref = this.public_genomes;
        for (i in _ref) {
          g = _ref[i];
          g.visible = false;
        }
        _ref1 = this.private_genomes;
        for (i in _ref1) {
          g = _ref1[i];
          g.visible = false;
        }
        for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
          g = pubGenomeIds[_i];
          this.public_genomes[g].visible = true;
          this.public_genomes[g].isSelected = false;
        }
        for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
          g = pvtGenomeIds[_j];
          this.private_genomes[g].visible = true;
          this.private_genomes[g].isSelected = false;
        }
        this.pubVisible = pubGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
          };
        })(this));
        this.pvtVisible = pvtGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
          };
        })(this));
      }
      return true;
    };

    GenomeController.prototype._runFilter = function(searchTerms) {
      var firstTerm, id, pubGenomeIds, pubSet, pvtGenomeIds, pvtSet, regex, t, _i, _len;
      if (!typeIsArray(searchTerms)) {
        throw new SuperphyError('Invalid argument. GenomeController method _runFilter() requires array of search term objects as input.');
      }
      pubGenomeIds = Object.keys(this.public_genomes);
      pvtGenomeIds = Object.keys(this.private_genomes);
      firstTerm = true;
      for (_i = 0, _len = searchTerms.length; _i < _len; _i++) {
        t = searchTerms[_i];
        if (firstTerm) {
          if (t.op != null) {
            throw new SuperphyError("Invalid filter input. First search term object cannot contain an operator property 'op'.");
          }
          if (t.dataField !== 'isolation_date') {
            if (t.searchTerm == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'searchTerm' property.");
            }
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'dataField' property.");
            }
            if (t.negate == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'negate' property.");
            }
          } else {
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'searchTerm' property.");
            }
            if (t.date == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'date' property.");
            }
            if (t.before == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'before' property.");
            }
          }
          firstTerm = false;
        } else {
          if (t.op == null) {
            throw new SuperphyError("Invalid filter input. Subsequent search term objects must contain an operator property 'op'.");
          }
        }
        if ((t.op != null) && t.op === 'or') {
          pubSet = [];
          pubSet = [];
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.public_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.private_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.public_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.private_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
          }
          pubGenomeIds = this.union(pubGenomeIds, pubSet);
          pvtGenomeIds = this.union(pvtGenomeIds, pvtSet);
        } else {
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
                id = pubGenomeIds[_j];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
                id = pvtGenomeIds[_j];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
                id = pubGenomeIds[_j];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
                id = pvtGenomeIds[_j];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          }
        }
      }
      return {
        "public": pubGenomeIds,
        "private": pvtGenomeIds
      };
    };

    GenomeController.prototype.match = function(genome, key, regex, negate) {
      var val;
      if (genome[key] == null) {
        return false;
      }
      val = genome[key];
      if (typeIsArray(genome[key])) {
        val = genome[key].toString();
      }
      if (regex.test(val)) {
        if (!negate) {
          return true;
        } else {
          return false;
        }
      } else {
        if (negate) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.passDate = function(genome, before, date) {
      var d2, val;
      if (genome['isolation_date'] == null) {
        return false;
      }
      val = genome['isolation_date'][0];
      d2 = Date.parse(val);
      if (before) {
        if (d2 < date) {
          return true;
        } else {
          return false;
        }
      } else {
        if (d2 > date) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.union = function(arr1, arr2) {
      var arr, i, _i, _len, _ref;
      arr = [];
      _ref = arr1.concat(arr2);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (__indexOf.call(arr, i) < 0) {
          arr.push(i);
        }
      }
      return arr;
    };

    GenomeController.prototype.label = function(genome, visibleMeta, joinStr) {
      var lab, na, t, _i, _len, _ref, _ref1, _ref2;
      na = 'NA';
      lab = [genome.displayname];
      _ref = this.mtypes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t !== 'accession') {
          if (visibleMeta[t]) {
            lab.push(((_ref1 = genome[t]) != null ? _ref1 : [na]).join(' '));
          }
        }
      }
      if (visibleMeta.accession) {
        lab.push((_ref2 = genome.primary_dbxref) != null ? _ref2 : na);
      }
      if (joinStr != null) {
        return lab.join(joinStr);
      } else {
        return lab;
      }
    };

    GenomeController.prototype.updateMeta = function(option, checked) {
      console.log(option);
      if (this.visibleMeta[option] == null) {
        throw new SuperphyError('unrecognized option in GenomeController method updateMeta()');
        return false;
      }
      if (!(checked === true || checked === false)) {
        throw new SuperphyError('invalid checked argument in GenomeController method updateMeta()');
        return false;
      }
      this.visibleMeta[option] = checked;
      this.update();
      return true;
    };

    GenomeController.prototype.select = function(g, checked) {
      if (this.publicRegexp.test(g)) {
        this.public_genomes[g].isSelected = checked;
      } else {
        this.private_genomes[g].isSelected = checked;
      }
      return true;
    };

    GenomeController.prototype.selected = function() {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var _ref, _results;
        _ref = this.public_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _ref, _results;
        _ref = this.private_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.unselectAll = function() {
      var k, v, _ref, _ref1, _results;
      _ref = this.public_genomes;
      for (k in _ref) {
        v = _ref[k];
        if (v.isSelected != null) {
          v.isSelected = false;
        }
      }
      _ref1 = this.private_genomes;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        if (v.isSelected != null) {
          _results.push(v.isSelected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    GenomeController.prototype.assignGroup = function(gset, grpNum) {
      var cls, g, _i, _j, _len, _len1, _ref, _ref1;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          this.public_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.public_genomes[g].cssClass = cls;
        }
      }
      if ((gset["private"] != null) && typeof gset["private"] !== 'undefined') {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          this.private_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.private_genomes[g].cssClass = cls;
        }
      }
      return true;
    };

    GenomeController.prototype.deleteGroup = function(gset) {
      var g, _i, _j, _len, _len1, _ref, _ref1;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          this.public_genomes[g].assignedGroup = null;
          this.public_genomes[g].cssClass = null;
        }
      }
      if ((gset["private"] != null) && typeof gset["public"] !== 'undefined') {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          this.private_genomes[g].assignedGroup = null;
          this.private_genomes[g].cssClass = null;
        }
      }
      return true;
    };

    GenomeController.prototype.grouped = function(grpNum) {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var _ref, _results;
        _ref = this.public_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _ref, _results;
        _ref = this.private_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genomeSet = function(gids) {
      var g, pub, pvt;
      pub = [];
      pvt = [];
      pub = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = gids.length; _i < _len; _i++) {
          g = gids[_i];
          if (this.publicRegexp.test(g)) {
            _results.push(g);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = gids.length; _i < _len; _i++) {
          g = gids[_i];
          if (this.privateRegexp.test(g)) {
            _results.push(g);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genome = function(gid) {
      if (this.publicRegexp.test(gid)) {
        return this.public_genomes[gid];
      } else {
        return this.private_genomes[gid];
      }
    };

    GenomeController.prototype.sort = function(gids, metaField, asc) {
      var that;
      if (!gids.length) {
        return gids;
      }
      that = this;
      gids.sort(function(a, b) {
        var aField, aName, aObj, bField, bName, bObj;
        aObj = that.genome(a);
        bObj = that.genome(b);
        aField = aObj[metaField];
        aName = aObj.displayname.toLowerCase();
        bField = bObj[metaField];
        bName = bObj.displayname.toLowerCase();
        if ((aField != null) && (bField != null)) {
          if (typeIsArray(aField)) {
            aField = aField.join('').toLowerCase();
            bField = bField.join('').toLowerCase();
          } else {
            aField = aField.toLowerCase();
            bField = bField.toLowerCase();
          }
          if (aField < bField) {
            return -1;
          } else if (aField > bField) {
            return 1;
          } else {
            if (aName < bName) {
              return -1;
            } else if (aName > bName) {
              return 1;
            } else {
              return 0;
            }
          }
        } else {
          if ((aField != null) && (bField == null)) {
            return -1;
          } else if ((bField != null) && (aField == null)) {
            return 1;
          } else {
            if (aName < bName) {
              return -1;
            } else if (aName > bName) {
              return 1;
            } else {
              return 0;
            }
          }
        }
      });
      if (!asc) {
        gids.reverse();
      }
      return gids;
    };

    GenomeController.prototype.find = function(searchStr) {
      var genomes, id, pubSet, pvtSet, regex;
      regex = new RegExp(escapeRegExp(searchStr), "i");
      pubSet = (function() {
        var _i, _len, _ref, _results;
        _ref = this.pubVisible;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          id = _ref[_i];
          if (this.match(this.public_genomes[id], 'displayname', regex, false)) {
            _results.push(id);
          }
        }
        return _results;
      }).call(this);
      pvtSet = (function() {
        var _i, _len, _ref, _results;
        _ref = this.pvtVisible;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          id = _ref[_i];
          if (this.match(this.private_genomes[id], 'displayname', regex, false)) {
            _results.push(id);
          }
        }
        return _results;
      }).call(this);
      genomes = pubSet.concat(pvtSet);
      console.log(genomes);
      return genomes;
    };

    return GenomeController;

  })();


  /*
   CLASS LocusController
   
   Manages Locus/Gene allele data
   */

  LocusController = (function() {
    function LocusController(locusData) {
      this.locusData = locusData;
    }

    LocusController.prototype.emptyString = "<span class='locus_group0'>No alleles detected</span>";

    LocusController.prototype.locusString = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str = '';
      if (l.copy > 1) {
        str = " (" + l.copy + " copy)";
      }
      return str;
    };

    LocusController.prototype.locusNode = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str;
      if (l.copy > 1) {
        str = " (" + l.copy + " copy)";
      } else {
        str = '';
      }
      return [str, null];
    };

    LocusController.prototype.genomeString = function(genomeID) {
      var g, str;
      str = ' - ';
      g = this.locusData[genomeID];
      if ((g != null) && g.num_copies > 0) {
        str += "<span class='locus_group1'>" + g.num_copies + " allele(s)</span>";
      } else {
        str += this.emptyString;
      }
      return str;
    };

    LocusController.prototype.count = function(genomes) {
      var counts_list;
      counts_list = [];
      this._count(genomes.pubVisible, counts_list);
      this._count(genomes.pvtVisible, counts_list);
      return counts_list;
    };

    LocusController.prototype._count = function(genomeList, counts_list) {
      var g, gID, _i, _len;
      for (_i = 0, _len = genomeList.length; _i < _len; _i++) {
        gID = genomeList[_i];
        g = this.locusData[gID];
        if (g != null) {
          counts_list.push(g.num_copies);
        } else {
          counts_list.push(0);
        }
      }
      return true;
    };

    return LocusController;

  })();

  if (!root.LocusController) {
    root.LocusController = LocusController;
  }


  /*
   CLASS StxController
   
   Manages Stx data
   */

  StxController = (function() {
    function StxController(locusData) {
      this.locusData = locusData;
      this.dataValues = {};
      this.format();
    }

    StxController.prototype.emptyString = "<span class='locus_group0'>NA</span>";

    StxController.prototype.format = function() {
      var dataGroup, g, grpNum, k, o, val, _ref;
      for (g in this.locusData) {
        _ref = this.locusData[g];
        for (k in _ref) {
          o = _ref[k];
          val = o.data;
          dataGroup = 0;
          if (this.dataValues[val] != null) {
            dataGroup = this.dataValues[val];
          } else {
            grpNum = Object.keys(this.dataValues).length;
            grpNum++;
            this.dataValues[val] = grpNum;
            dataGroup = grpNum;
          }
          o.cls = "locus_group" + dataGroup;
          o.group = dataGroup;
          o.dataString = "<span class='" + o.cls + "'>" + val + "</span>";
        }
      }
      return true;
    };

    StxController.prototype.locusString = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str;
      if (l.copy > 1) {
        str = " (" + l.copy + " copy) -  " + l.dataString;
      } else {
        str = ' - ' + l.dataString;
      }
      return str;
    };

    StxController.prototype.locusNode = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str;
      if (l.copy > 1) {
        str = " (" + l.copy + " copy) -  " + l.data;
      } else {
        str = ' - ' + l.data;
      }
      return [str, l.group];
    };

    StxController.prototype.genomeString = function(genomeID) {
      var ds, g, k, str, v;
      str = ' - ';
      g = this.locusData[genomeID];
      if (g != null) {
        ds = (function() {
          var _results;
          _results = [];
          for (k in g) {
            v = g[k];
            _results.push(v.dataString);
          }
          return _results;
        })();
        str += ds.join(',');
      } else {
        str += this.emptyString;
      }
      return str;
    };

    StxController.prototype.count = function(genomes) {
      var uniqueValues;
      uniqueValues = {
        'NA': 0
      };
      this._count(genomes.pubVisible, uniqueValues);
      this._count(genomes.pvtVisible, uniqueValues);
      return uniqueValues;
    };

    StxController.prototype._count = function(genomeList, uniqueValues) {
      var g, gID, k, v, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = genomeList.length; _i < _len; _i++) {
        gID = genomeList[_i];
        g = this.locusData[gID];
        if (g != null) {
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (k in g) {
              v = g[k];
              if (uniqueValues[v.data] != null) {
                _results1.push(uniqueValues[v.data]++);
              } else {
                _results1.push(uniqueValues[v.data] = 1);
              }
            }
            return _results1;
          })());
        } else {
          _results.push(uniqueValues['NA']++);
        }
      }
      return _results;
    };

    return StxController;

  })();

  if (!root.StxController) {
    root.StxController = StxController;
  }


  /*
   CLASS SelectionView
   
   A special type of genome list that is used to temporarily store the user's
   selected genomes.
   
   Only one 'style' which provides a remove button to remove group from group.
   Will be updated by changes to the meta-display options but not by filtering.
   */

  SelectionView = (function() {
    function SelectionView(parentElem, countElem, elNum) {
      this.parentElem = parentElem;
      this.countElem = countElem != null ? countElem : null;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
      this.count = 0;
    }

    SelectionView.prototype.type = 'selected';

    SelectionView.prototype.elNum = 1;

    SelectionView.prototype.elName = 'selected_genomes';

    SelectionView.prototype.elID = void 0;

    SelectionView.prototype.update = function(genomes) {
      var ingrp, listElem;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "' class='selected-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      ingrp = genomes.selected();
      this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
      this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
      this.count = ingrp["public"].length;
      this.count += ingrp["private"].length;
      this._updateCount();
      return true;
    };

    SelectionView.prototype._appendGenomes = function(el, visibleG, genomes) {
      var actionEl, cls, g, listEl, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
        actionEl = jQuery("<a href='#' data-genome='" + g + "'> <i class='fa fa-times'></a>");
        actionEl.click(function(e) {
          var gid;
          e.preventDefault();
          gid = this.dataset.genome;
          console.log('clicked unselect on ' + gid);
          return viewController.select(gid, false);
        });
        listEl.append(actionEl);
        el.append(listEl);
      }
      return true;
    };

    SelectionView.prototype.select = function(genomeID, genomes, checked) {
      var gset;
      if (checked) {
        gset = genomes.genomeSet([genomeID]);
        this.add(gset, genomes);
      } else {
        this.remove(genomeID);
      }
      return true;
    };

    SelectionView.prototype.add = function(genomeSet, genomes) {
      var listElem;
      listElem = jQuery("#" + this.elID);
      if (!listElem.length) {
        listElem = jQuery("<ul id='" + this.elID + "' class='selected-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      if (genomeSet["public"] != null) {
        this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
      }
      if (genomeSet["private"] != null) {
        this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
      }
      this.count += genomeSet["public"].length;
      this.count += genomeSet["private"].length;
      return this._updateCount();
    };

    SelectionView.prototype.remove = function(gid) {
      var descriptor, linkEl, listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call SelectionView method remove().");
      }
      descriptor = "li > a[data-genome='" + gid + "']";
      linkEl = listEl.find(descriptor);
      if (!((linkEl != null) && linkEl.length)) {
        throw new SuperphyError("List item element for genome " + gid + " not found in SelectionView");
        return false;
      }
      linkEl.parent('li').remove();
      this.count--;
      this._updateCount();
      return true;
    };

    SelectionView.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    SelectionView.prototype._updateCount = function() {
      var innerElem;
      if (this.countElem != null) {
        innerElem = this.countElem.find('span.selected_genome_count_text');
        if (!innerElem.length) {
          innerElem = jQuery("<span class='selected_genome_count_text'></span>").appendTo(this.countElem);
        }
        innerElem.text("" + this.count + " genomes selected");
      }
      return true;
    };

    return SelectionView;

  })();


  /*
  
    HELPER FUNCTIONS
   */

  parseHeader = function(str) {
    var match;
    match = /^((?:public|private)_\d+)\|(\d+)/.exec(str);
    return match;
  };

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  cmp = function(a, b) {
    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    } else {
      return 0;
    }
  };

  trimInput = function(str, field) {
    var term;
    if (str != null) {
      term = jQuery.trim(str);
      if (term.length) {
        return term;
      } else {
        alert("Error: " + field + " is empty.");
        return null;
      }
    } else {
      alert("Error: " + field + " is empty.");
      return null;
    }
  };

  superphyAlert = function(output_msg, title_msg) {
    if (output_msg == null) {
      output_msg = 'No Message to Display.';
    }
    if (title_msg == null) {
      title_msg = 'Alert';
    }
    return jQuery("<div></div>").html(output_msg).dialog({
      title: title_msg,
      resizable: false,
      modal: true,
      buttons: {
        "Ok": function() {
          return jQuery(this).dialog("close");
        }
      }
    });
  };

  superphyMetaOntology = {
    "syndromes": ["Bacteriuria", "Bloody diarrhea", "Crohn's Disease", "Diarrhea", "Gastroenteritis", "Hemolytic-uremic syndrome", "Hemorrhagic colitis", "Mastitis", "Meningitis", "Peritonitis", "Pneumonia", "Pyelonephritis", "Septicaemia", "Ulcerateive colitis", "Urinary tract infection (cystitis)"],
    "hosts": ["Bos taurus (cow)", "Canis lupus familiaris (dog)", "Environmental source", "Felis catus (cat)", "Gallus gallus (chicken)", "Homo sapiens (human)", "Mus musculus (mouse)", "Oryctolagus cuniculus (rabbit)", "Ovis aries (sheep)", "Sus scrofa (pig)"],
    "sources": ["Blood", "Cecum", "Colon", "Feces", "Ileum", "Intestine", "Liver", "Meat", "Meat-based food", "Stool", "Urine", "Vegetable-based food", "Water", "Yolk", "cerebrospinal_fluid"]
  };


  /*
  
  
   File: superphy_tree.coffee
   Desc: Phylogenetic Tree View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: March 20th, 2013
   */

  d3.selection.prototype.moveToFront = function() {
    return this.each(function() {
      return this.parentNode.appendChild(this);
    });
  };


  /*
   CLASS TreeView
    
   Phylogenetic tree view
   
   Can be genome- or locus-based
   Returns genome ID to redirect/select if leaf node is clicked
   */

  TreeView = (function(_super) {
    __extends(TreeView, _super);

    function TreeView(parentElem, style, elNum, treeArgs) {
      var dialog, legendID, num;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (!(treeArgs.length > 0)) {
        throw new SuperphyError('Missing argument. TreeView constructor requires JSON tree object.');
      }
      this.root = this.trueRoot = treeArgs[0];
      this.currentGenomeSet = -1;
      this.dim = {
        w: 700,
        h: 800
      };
      this.margin = {
        top: 20,
        right: 180,
        bottom: 20,
        left: 20
      };
      if (treeArgs[1] != null) {
        this.locusData = treeArgs[1];
      }
      if (treeArgs[2] != null) {
        this.dim = treeArgs[2];
      }
      if (treeArgs[3] != null) {
        this.margin = treeArgs[3];
      }
      TreeView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.width = this.dim.w - this.margin.right - this.margin.left;
      this.height = this.dim.h - this.margin.top - this.margin.bottom;
      this.xzoom = d3.scale.linear().domain([0, this.width]).range([0, this.width]);
      this.yzoom = d3.scale.linear().domain([0, this.height]).range([0, this.height]);
      this.cluster = d3.layout.cluster().size([this.width, this.height]).sort(null).value(function(d) {
        return Number(d.length);
      }).separation(function(a, b) {
        return 1;
      });
      legendID = "tree_legend" + this.elNum;
      this._treeOps(this.parentElem, legendID);
      jQuery("<div id='" + this.elID + "' class='" + (this.cssClass()) + "'></div>").appendTo(this.parentElem);
      this.wrap = d3.select("#" + this.elID).append("svg").attr("width", this.dim.w).attr("height", this.dim.h).style("-webkit-backface-visibility", "hidden");
      this.scalePos = {
        x: 10,
        y: 10
      };
      this.scaleBar = this.wrap.append("g").attr("transform", "translate(" + this.scalePos.x + "," + this.scalePos.y + ")").attr("class", "scalebar");
      this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      num = this.elNum - 1;
      this.zoom = d3.behavior.zoom().x(this.xzoom).y(this.yzoom).scaleExtent([1, 8]).on("zoom", function() {
        return viewController.getView(num).zoomed();
      });
      this.wrap.call(this.zoom);
      this.scaleBar.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 1).attr('y2', 0);
      this.scaleBar.append('text').attr("dx", "0").attr("dy", "1em").attr("text-anchor", "start");
      jQuery("<div id='" + legendID + "' class='genome_tree_legend'></div>").appendTo(this.parentElem);
      this.wrap2 = d3.select("#" + legendID).append("svg").attr("width", this.dim.w).attr("height", 100).style("-webkit-backface-visibility", "hidden");
      this.legend = this.wrap2.append("g").attr("transform", "translate(" + 5 + "," + 5 + ")");
      this._legend(this.legend);
      if (this.style === 'select') {
        dialog = jQuery('#dialog-clade-select');
        if (!dialog.length) {
          dialog = jQuery('<div id="dialog-clade-select"></div>').appendTo('body');
          dialog.text("Select/unselect genomes in clade:").dialog({
            dialogClass: 'noTitleStuff',
            autoOpen: false,
            resizable: false,
            height: 120,
            modal: true,
            buttons: {
              Select: function() {
                var node;
                node = jQuery(this).data("clade-node");
                viewController.getView(num).selectClade(node, true);
                return jQuery(this).dialog("close");
              },
              Unselect: function() {
                var node;
                node = jQuery(this).data("clade-node");
                viewController.getView(num).selectClade(node, false);
                return jQuery(this).dialog("close");
              },
              Cancel: function() {
                return jQuery(this).dialog("close");
              }
            }
          });
        }
      }
      this._prepTree();
      true;
    }

    TreeView.prototype.type = 'tree';

    TreeView.prototype.elName = 'genome_tree';

    TreeView.prototype.nodeId = 0;

    TreeView.prototype.duration = 1000;

    TreeView.prototype.expandDepth = 10;

    TreeView.prototype.x_factor = 1.5;

    TreeView.prototype.y_factor = 5000;

    TreeView.prototype.update = function(genomes, sourceNode) {
      var cladeSelect, cmdBox, currLeaves, dt, elID, iNodes, id, leaves, linksEnter, n, nodesEnter, nodesExit, nodesUpdate, num, oldRoot, svgLinks, svgNode, svgNodes, t1, t2, targetLen, unit, yedge, ypos, yshift, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if (sourceNode == null) {
        sourceNode = null;
      }
      t1 = new Date();
      oldRoot = this.root;
      this._sync(genomes);
      this.nodes = this.cluster.nodes(this.root);
      if (sourceNode == null) {
        sourceNode = this.root;
      }
      this.launchPt = {
        x: sourceNode.x,
        y: sourceNode.y,
        x0: sourceNode.x0,
        y0: sourceNode.y0
      };
      if (this.reformat) {
        this._scale();
        targetLen = 30;
        unit = targetLen / this.branch_scale_factor_y;
        unit = Math.round(unit * 10000) / 10000;
        this.scaleLength = unit * this.branch_scale_factor_y;
        this.scaleBar.select('line').attr('x1', 0).attr('x2', this.scaleLength).attr('y1', 0).attr('y2', 0);
        this.scaleBar.select('text').text("" + unit + " branch length units");
        this.zoom.translate([0, 0]).scale(1);
        this.scaleBar.select("line").attr('transform', 'scale(1,1)');
        this.reformat = false;
      }
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.y = n.sum_length * this.branch_scale_factor_y;
        n.x = n.x * this.branch_scale_factor_x;
      }
      if (this.expansionContraction) {
        yedge = this.width - 30;
        ypos = this.edgeNode.y;
        if (ypos > yedge) {
          yshift = ypos - yedge;
          _ref1 = this.nodes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            n = _ref1[_j];
            n.y = n.y - yshift;
          }
        }
        this.expansionContraction = false;
      }
      svgNodes = this.canvas.selectAll("g.treenode").data(this.nodes, function(d) {
        return d.id;
      });
      svgLinks = this.canvas.selectAll("path.treelink").data(this.cluster.links(this.nodes), function(d) {
        return d.target.id;
      });
      linksEnter = svgLinks.enter().insert("path").attr("class", "treelink").attr("d", (function(_this) {
        return function(d) {
          var p;
          p = {
            x: _this.launchPt.x0,
            y: _this.launchPt.y0
          };
          return _this._step({
            source: p,
            target: p
          });
        };
      })(this));
      svgLinks.transition().duration(this.duration).attr("d", this._step);
      svgLinks.exit().transition().duration(this.duration).attr("d", (function(_this) {
        return function(d) {
          var o;
          o = {
            x: _this.launchPt.x,
            y: _this.launchPt.y
          };
          return _this._step({
            source: o,
            target: o
          });
        };
      })(this)).remove();
      currLeaves = svgNodes.filter(function(d) {
        return d.leaf;
      }).attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).on("click", function(d) {
        if (d.assignedGroup == null) {
          return viewController.select(d.genome, !d.selected);
        } else {
          return null;
        }
      });
      currLeaves.select("circle").style("fill", function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      svgNodes.select("text").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      });
      svgNodes.filter(function(d) {
        return d.children && !d.leaf;
      }).select("text").transition().duration(this.duration).style("fill-opacity", 1e-6);
      nodesEnter = svgNodes.enter().append("g").attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).attr("id", function(d) {
        return "treenode" + d.id;
      }).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.launchPt.y0 + "," + _this.launchPt.x0 + ")";
        };
      })(this));
      leaves = nodesEnter.filter(function(d) {
        return d.leaf;
      });
      leaves.append("circle").attr("r", 1e-6).style("fill", function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      if (this.style === 'select') {
        leaves.on("click", function(d) {
          if (d.assignedGroup == null) {
            return viewController.select(d.genome, !d.selected);
          } else {
            return null;
          }
        });
      } else {
        leaves.on("click", function(d) {
          return viewController.redirect(d.genome);
        });
      }
      nodesEnter.append("text").attr("class", "treelabel").attr("dx", ".6em").attr("dy", ".4em").attr("text-anchor", "start").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      }).style("fill-opacity", 1e-6);
      iNodes = nodesEnter.filter(function(n) {
        return !n.leaf && !n.root;
      });
      num = this.elNum - 1;
      cmdBox = iNodes.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 4).attr("x", -8).text(function(d) {
        return "\uf0fe";
      });
      cmdBox.on("click", function(d) {
        return viewController.viewAction(num, 'expand_collapse', d, this.parentNode);
      });
      if (this.style === 'select') {
        cladeSelect = iNodes.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -25);
        cladeSelect.on("click", function(d) {
          return jQuery('#dialog-clade-select').data('clade-node', d).dialog('open');
        });
      }
      nodesUpdate = svgNodes.transition().duration(this.duration).attr("transform", function(d) {
        return "translate(" + d.y + "," + d.x + ")";
      });
      nodesUpdate.select("circle").attr("r", 4);
      nodesUpdate.filter(function(d) {
        return !d.children;
      }).select("text").style("fill-opacity", 1);
      nodesUpdate.select(".expandcollapse").text(function(d) {
        if (d._children != null) {
          return "\uf0fe";
        } else {
          return "\uf146";
        }
      });
      nodesExit = svgNodes.exit().transition().duration(this.duration).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.launchPt.y + "," + _this.launchPt.x + ")";
        };
      })(this)).remove();
      nodesExit.select("circle").attr("r", 1e-6);
      nodesExit.select("text").style("fill-opacity", 1e-6);
      nodesExit.select("rect").attr("width", 1e-6).attr("height", 1e-6);
      if (!oldRoot.root && this.root !== oldRoot) {
        id = oldRoot.id;
        elID = "treenode" + id;
        svgNode = this.canvas.select("#" + elID);
        svgNode.moveToFront();
      }
      _ref2 = this.nodes;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        n = _ref2[_k];
        n.x0 = n.x;
        n.y0 = n.y;
      }
      t2 = new Date();
      dt = new Date(t2 - t1);
      console.log('TreeView update elapsed time (sec): ' + dt.getSeconds());
      return true;
    };

    TreeView.prototype.intro = function() {
      var treeIntro;
      treeIntro = [];
      treeIntro.push({
        element: document.querySelector('#tree_find_input2'),
        intro: "Use this search bar to search for a specific genome.  The genome will be indicated by a yellow circle on the tree, which shows its phylogenetic relationships with other genomes.  Click 'Functions List' to view a list of functions.",
        position: 'right'
      });
      treeIntro.push({
        element: document.querySelector('#tree-controls'),
        intro: "Use these buttons to have the tree fit within the window, to reset the tree, and to expand all the clades.",
        position: 'bottom'
      });
      treeIntro.push({
        element: document.querySelector('#genome_tree2'),
        intro: "You can also click the blue circles to select genomes.  Clades can be selected by clicking the red boxes.  Pan by clicking and dragging.  Clicking on the '+' and '-' symbols will expand or collapse each clade.  Use the clickwheel on your mouse to zoom.",
        position: 'left'
      });
      treeIntro.push({
        element: document.querySelector('#tree_legend2'),
        intro: "Use this legend to help you.",
        position: 'left'
      });
      return treeIntro;
    };

    TreeView.prototype.updateCSS = function(gset, genomes) {
      var g, genomeList, svgNodes, updateNodes, _i, _j, _len, _len1, _ref, _ref1;
      genomeList = {};
      if (gset["public"] != null) {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          genomeList[g] = genomes.public_genomes[g];
        }
      }
      if (gset["private"] != null) {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          genomeList[g] = genomes.private_genomes[g];
        }
      }
      svgNodes = this.canvas.selectAll("g.treenode");
      updateNodes = svgNodes.filter(function(d) {
        return genomeList[d.genome] != null;
      }).attr("class", (function(_this) {
        return function(d) {
          g = genomeList[d.genome];
          d.selected = (g.isSelected != null) && g.isSelected;
          d.assignedGroup = g.assignedGroup;
          return _this._classList(d);
        };
      })(this));
      updateNodes.on("click", function(d) {
        if (d.assignedGroup == null) {
          return viewController.select(d.genome, !d.selected);
        } else {
          return null;
        }
      });
      return true;
    };

    TreeView.prototype.viewAction = function(genomes, argArray) {
      var event;
      event = argArray.shift();
      if (event === 'expand_collapse') {
        this._expandCollapse(genomes, argArray[0], argArray[1]);
      } else if (event === 'fit_window') {
        this.reformat = true;
        this.update(genomes);
      } else if (event === 'reset_window') {
        this.resetWindow = true;
        this.highlightGenomes(genomes, null);
        this.update(genomes);
      } else if (event === 'expand_tree') {
        this.expandTree(genomes);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in TreeView viewAction method.");
      }
      return true;
    };

    TreeView.prototype.selectClade = function(node, checked) {
      var c, _i, _j, _len, _len1, _ref, _ref1;
      if (node.leaf) {
        if (checked) {
          if (!node.selected) {
            viewController.select(node.genome, checked);
          }
        } else {
          if (node.selected) {
            viewController.select(node.genome, checked);
          }
        }
      } else {
        if (node.children) {
          _ref = node.children;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            this.selectClade(c, checked);
          }
        } else if (node._children) {
          _ref1 = node._children;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            c = _ref1[_j];
            this.selectClade(c, checked);
          }
        }
      }
      return true;
    };

    TreeView.prototype.select = function(genome, isSelected) {
      var d, svgNodes, updateNode;
      d = this._findLeaf(genome);
      svgNodes = this.canvas.selectAll("g.treenode");
      updateNode = svgNodes.filter(function(d) {
        return d.genome === genome;
      });
      if (updateNode) {
        updateNode.attr("class", (function(_this) {
          return function(d) {
            d.selected = isSelected;
            return _this._classList(d);
          };
        })(this));
        updateNode.select("circle").style("fill", function(d) {
          if (d.selected) {
            return "lightsteelblue";
          } else {
            return "#fff";
          }
        });
        this._percolateSelected(d.parent, isSelected);
        svgNodes.filter(function(d) {
          return !d.leaf;
        }).attr("class", (function(_this) {
          return function(d) {
            return _this._classList(d);
          };
        })(this));
      }
      return true;
    };

    TreeView.prototype._percolateSelected = function(node, checked) {
      if (node == null) {
        return true;
      }
      if (checked) {
        node.num_selected++;
      } else {
        node.num_selected--;
      }
      if (node.num_selected === node.num_leaves) {
        node.internal_node_selected = 2;
      } else if (node.num_selected > 0) {
        node.internal_node_selected = 1;
      } else {
        node.internal_node_selected = 0;
      }
      this._percolateSelected(node.parent, checked);
      return true;
    };

    TreeView.prototype.dump = function(genomes) {
      var output, tokens;
      tokens = [];
      this._printNode(genomes, this.root, tokens);
      output = tokens.join('');
      return {
        ext: 'newick',
        type: 'text/plain',
        data: output
      };
    };

    TreeView.prototype._printNode = function(genomes, node, tokens) {
      var c, children, g, lab, _i, _len;
      if (node.leaf) {
        g = genomes.genome(node.genome);
        lab = genomes.label(g, genomes.visibleMeta);
        tokens.push("\"" + lab + "\"", ':', node.length);
      } else {
        children = node.children;
        if (node._children != null) {
          children = node._children;
        }
        tokens.push('(');
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          c = children[_i];
          this._printNode(genomes, c, tokens);
          tokens.push(',');
        }
        tokens[tokens.length - 1] = ')';
        tokens.push("\"" + node.name + "\"", ':', node.length);
      }
      return true;
    };

    TreeView.prototype._step = function(d) {
      return "M" + d.source.y + "," + d.source.x + "L" + d.source.y + "," + d.target.x + "L" + d.target.y + "," + d.target.x;
    };

    TreeView.prototype._prepTree = function() {
      var gPattern;
      this.trueRoot.root = true;
      this.trueRoot.x0 = this.height / 2;
      this.trueRoot.y0 = 0;
      gPattern = /^((?:public_|private_)\d+)\|/;
      this.leaves = [];
      return this._assignKeys(this.trueRoot, 0, gPattern);
    };

    TreeView.prototype._assignKeys = function(n, i, gPattern) {
      var m, res, _i, _j, _len, _len1, _ref, _ref1;
      n.id = i;
      n.storage = n.length * 1;
      i++;
      if (n.children != null) {
        n.num_selected = 0;
        n.daycare = n.children.slice();
        _ref = n.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          i = this._assignKeys(m, i, gPattern);
        }
      } else if (n._children != null) {
        n.num_selected = 0;
        n.daycare = n._children.slice();
        _ref1 = n._children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          m = _ref1[_j];
          i = this._assignKeys(m, i, gPattern);
        }
      }
      if ((n.leaf != null) && n.leaf === "true") {
        if (this.locusData != null) {
          res = gPattern.exec(n.name);
          if (res == null) {
            throw new SuperphyError("Invalid tree node key. Expecting: genome|locus. Recieved: " + n.name);
          }
          n.genome = res[1];
        } else {
          n.genome = n.name;
        }
        this.leaves.push(n);
      }
      return i;
    };

    TreeView.prototype._sync = function(genomes) {
      this.root = this._syncNode(this.trueRoot, genomes, 0);
      if ((genomes.genomeSetId !== this.currentGenomeSet) || this.resetWindow) {
        this._expansionLayout();
        this.currentGenomeSet = genomes.genomeSetId;
        this.resetWindow = false;
        this.reformat = true;
      }
      return true;
    };

    TreeView.prototype._syncNode = function(node, genomes, sumLengths) {
      var c, child, children, g, isExpanded, ld, u, _i, _len, _ref;
      node.length = node.storage * 1;
      node.sum_length = sumLengths + node.length;
      if ((node.leaf != null) && node.leaf === "true") {
        g = genomes.genome(node.genome);
        if ((g != null) && g.visible) {
          node.viewname = g.viewname;
          node.selected = (g.isSelected != null) && g.isSelected;
          node.assignedGroup = g.assignedGroup;
          node.hidden = false;
          if (this.locusData != null) {
            ld = this.locusData.locusNode(node.name);
            node.viewname += ld[0];
            if (ld[1] != null) {
              node.assignedGroup = ld[1];
            }
          }
        } else {
          node.hidden = true;
        }
      } else {
        isExpanded = true;
        if (node._children != null) {
          isExpanded = false;
        }
        children = [];
        _ref = node.daycare;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          u = this._syncNode(c, genomes, node.sum_length);
          if (!u.hidden) {
            children.push(u);
          }
        }
        if (children.length === 0) {
          node.hidden = true;
        } else if (children.length === 1) {
          node.hidden = true;
          child = children[0];
          child.length += node.length;
          return child;
        } else {
          node.hidden = false;
          if (isExpanded) {
            node.children = children;
          } else {
            node._children = children;
          }
        }
      }
      return node;
    };

    TreeView.prototype._cloneNode = function(node) {
      var copy, k, v;
      copy = {};
      for (k in node) {
        v = node[k];
        if (!(k === 'children' || k === '_children')) {
          copy[k] = v;
        }
      }
      return copy;
    };

    TreeView.prototype._expansionLayout = function() {
      this._formatNode(this.root, 0);
      this.root.x0 = this.height / 2;
      this.root.y0 = 0;
      this.root.root = true;
      return true;
    };

    TreeView.prototype._formatNode = function(node, depth, parentNode) {
      var c, children, current_depth, isExpanded, r, record, _i, _len, _ref;
      if (parentNode == null) {
        parentNode = null;
      }
      if (node.hidden) {
        return null;
      }
      current_depth = depth + 1;
      record = {};
      node.parent = parentNode;
      node.root = false;
      if ((node.leaf != null) && node.leaf === "true") {
        record['num_leaves'] = 1;
        record['outgroup'] = node.label;
        record['depth'] = current_depth;
        record['length'] = node.length;
        record['num_selected'] = (_ref = node.selected) != null ? _ref : {
          1: 0
        };
        return record;
      } else {
        isExpanded = true;
        children = node.children;
        if (node._children != null) {
          isExpanded = false;
          children = node._children;
        }
        if (current_depth < this.expandDepth) {
          node.children = children;
          node._children = null;
        } else if (isExpanded) {
          node._children = children;
          node.children = null;
        } else {
          node._children = children;
          node.children = null;
        }
        record = {
          num_leaves: 0,
          num_selected: 0,
          outgroup: '',
          depth: 1e6,
          length: 0
        };
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          c = children[_i];
          r = this._formatNode(c, current_depth, node);
          record['num_leaves'] += r['num_leaves'];
          record['num_leaves'] += r['num_selected'];
          if ((record['depth'] > r['depth']) || (record['depth'] === r['depth'] && record['length'] < r['length'])) {
            record['depth'] = r['depth'];
            record['length'] = r['length'];
            record['outgroup'] = r['outgroup'];
          }
        }
        node.label = "" + record['num_leaves'] + " genomes (outgroup: " + record['outgroup'] + ")";
        node.num_leaves = record['num_leaves'];
        node.num_selected = record['num_selected'];
        if (node.num_selected === node.num_leaves) {
          node.internal_node_selected = 2;
        } else if (node.num_selected > 0) {
          node.internal_node_selected = 1;
        } else {
          node.internal_node_selected = 0;
        }
      }
      return record;
    };

    TreeView.prototype._scale = function() {
      var farthest, lowest, padding, percCovered, xedge, yedge;
      farthest = d3.max(this.nodes, function(d) {
        return d.sum_length * 1;
      });
      lowest = d3.max(this.nodes, function(d) {
        return d.x;
      });
      percCovered = 0.10 * this.root.num_leaves;
      if (percCovered > 0.90) {
        percCovered = 0.90;
      }
      padding = 20;
      yedge = (this.width - padding) * percCovered;
      xedge = (this.height - padding) * percCovered;
      this.branch_scale_factor_y = yedge / farthest;
      this.branch_scale_factor_x = xedge / lowest;
      return true;
    };

    TreeView.prototype._expandCollapse = function(genomes, d, el) {
      var c, c2, c3, maxy, svgNode, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      svgNode = d3.select(el);
      this.edgeNode = null;
      maxy = 0;
      if (d.children != null) {
        d._children = d.children;
        d.children = null;
        this.edgeNode = d;
      } else {
        d.children = d._children;
        d._children = null;
        _ref = d.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (c._children != null) {
            c.children = c._children;
            c._children = null;
          }
          if (c.children != null) {
            _ref1 = c.children;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              c2 = _ref1[_j];
              if (c2._children != null) {
                c2.children = c2._children;
                c2._children = null;
              }
              if (c2.children != null) {
                _ref2 = c2.children;
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  c3 = _ref2[_k];
                  if (c3.sum_length > maxy) {
                    maxy = c3.sum_length;
                    this.edgeNode = c3;
                  }
                }
              }
              if (c2.sum_length > maxy) {
                maxy = c2.sum_length;
                this.edgeNode = c2;
              }
            }
          }
          if (c.sum_length > maxy) {
            maxy = c.sum_length;
            this.edgeNode = c;
          }
        }
      }
      this.expansionContraction = true;
      this.update(genomes, d);
      return true;
    };

    TreeView.prototype.zoomed = function() {
      this.canvas.selectAll("g.treenode").attr("transform", (function(_this) {
        return function(d) {
          return _this._zTransform(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      this.canvas.selectAll("path.treelink").attr("d", (function(_this) {
        return function(d) {
          return _this._zTranslate(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      this.scaleBar.select("line").attr('transform', 'scale(' + d3.event.scale + ',1)');
      return true;
    };

    TreeView.prototype._zTranslate = function(d, xzoom, yzoom) {
      var sourceX, sourceY, targetX, targetY;
      sourceX = xzoom(d.source.y);
      sourceY = yzoom(d.source.x);
      targetX = xzoom(d.target.y);
      targetY = yzoom(d.target.x);
      return "M" + sourceX + "," + sourceY + "L" + sourceX + "," + targetY + "L" + targetX + "," + targetY;
    };

    TreeView.prototype._zTransform = function(d, xzoom, yzoom) {
      return "translate(" + xzoom(d.y) + "," + yzoom(d.x) + ")";
    };

    TreeView.prototype._classList = function(d) {
      var clsList;
      clsList = ['treenode'];
      if (d.selected) {
        clsList.push("selectedNode");
      }
      if (d.focus) {
        clsList.push("focusNode");
      }
      if (d.assignedGroup != null) {
        clsList.push("groupedNode" + d.assignedGroup);
      }
      if (d.internal_node_selected != null) {
        if (d.internal_node_selected === 2) {
          clsList.push("internalSNodeFull");
        } else if (d.internal_node_selected === 1) {
          clsList.push("internalSNodePart");
        }
      }
      return clsList.join(' ');
    };

    TreeView.prototype._findLeaf = function(genome) {
      var found, n;
      n = null;
      found = this.leaves.some(function(el, i) {
        if (el.genome === genome) {
          n = el;
          return true;
        } else {
          return false;
        }
      });
      if (!found) {
        throw new SuperphyError("No leaf node matching " + genome + " found.");
        return null;
      }
      return n;
    };

    TreeView.prototype._legend = function(el) {
      var cladeExpand, cladeSelect, colw, colw2, csColumn, ecColumn, expandCollapse, focusNode, genomeSelect, gsColumn, indent, lineh, lineh2, lineh3, lineh4, panZoom, pzRow, pzdx, pzdx2, pzdy, textdx, textdx2, textdy;
      lineh = 25;
      lineh2 = 40;
      lineh3 = 55;
      lineh4 = 80;
      textdx = ".6em";
      textdx2 = "2.5em";
      textdy = ".4em";
      pzdx = "3.2em";
      pzdx2 = "3.7em";
      pzdy = ".5em";
      indent = 8;
      colw = 245;
      colw2 = 480;
      if (this.style === 'select') {
        gsColumn = el.append("g").attr("transform", "translate(5," + lineh + ")");
        genomeSelect = gsColumn.append("g").attr("class", 'treenode');
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to select / unselect genome');
        genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "lightsteelblue");
        genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Selected genome');
        genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Unselected genome');
        csColumn = el.append("g").attr("transform", "translate(" + colw + "," + lineh + ")");
        cladeSelect = csColumn.append("g").attr("class", 'treenode');
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to select / unselect clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('No genomes selected in clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode internalSNodePart').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Some genomes selected in clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode internalSNodeFull').attr("transform", "translate(" + indent + "," + lineh3 + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('All genomes selected in clade');
        ecColumn = el.append("g").attr("transform", "translate(" + colw2 + "," + lineh + ")");
        expandCollapse = ecColumn.append("g").attr("class", 'treenode');
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf0fe";
        });
        expandCollapse.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to collapse / expand clade');
        expandCollapse = ecColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf146";
        });
        expandCollapse.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Expanded clade');
        expandCollapse = ecColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf0fe";
        });
        expandCollapse.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Collapsed clade');
        pzRow = el.append("g").attr("transform", "translate(0,0)");
        panZoom = pzRow.append("g").attr("class", 'treenode');
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Pan');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx).attr("dy", pzdy).attr("text-anchor", "start").text('Click & Drag');
        panZoom = pzRow.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + ",0)");
        panZoom.append("text").attr("class", "slash").attr("dx", "-.4em").attr("dy", ".5em").attr("text-anchor", "start").text('Zoom');
        return panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx).attr("dy", pzdy).attr("text-anchor", "start").text('Scroll');
      } else {
        genomeSelect = el.append("g").attr("class", 'treenode').attr("transform", "translate(5,0)");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 8).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Select genome');
        cladeExpand = el.append("g").attr("class", 'treenode').attr("transform", "translate(5, " + lineh + ")");
        cladeExpand.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 4).attr("x", -1).text(function(d) {
          return "\uf0fe";
        });
        cladeExpand.append("text").attr("class", "slash").attr("dx", ".5em").attr("dy", ".5em").attr("text-anchor", "start").text('/');
        cladeExpand.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 8).attr("x", 17).text(function(d) {
          return "\uf146";
        });
        cladeExpand.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Expand / Collapse clade');
        panZoom = el.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + ",0)");
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Pan ');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx2).attr("dy", pzdy).attr("text-anchor", "start").text('Click & Drag');
        panZoom = el.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + "," + lineh + ")");
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Zoom');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx2).attr("dy", pzdy).attr("text-anchor", "start").text('Scroll');
        focusNode = el.append("g").attr("class", 'treenode focusNode').attr("transform", "translate(" + colw2 + ",0)");
        focusNode.append("circle").attr("r", 4).attr("cx", 8).attr("cy", 2);
        return focusNode.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Target genome');
      }
    };

    TreeView.prototype._treeOps = function(el, legendID) {
      var controls, expButtonID, findButtonID, findInputID, fitButtonID, num, opsHtml, resetButtonID;
      opsHtml = '';
      controls = '<div class="row">';
      controls += "<div class='col-sm-6 span6'><div class='btn-group' id='tree-controls'>";
      fitButtonID = "tree_fit_button" + this.elNum;
      controls += "<button id='" + fitButtonID + "' type='button' class='btn btn-default btn-sm'>Fit to window</button>";
      resetButtonID = "tree_reset_button" + this.elNum;
      controls += "<button id='" + resetButtonID + "' type='button' class='btn btn-default btn-sm'>Reset window</button>";
      expButtonID = "tree_expand_button" + this.elNum;
      controls += "<button id='" + expButtonID + "' type='button' class='btn btn-default btn-sm'>Expand all</button>";
      controls += "</div></div>";
      findButtonID = "tree_find_button" + this.elNum;
      findInputID = "tree_find_input" + this.elNum;
      controls += "<div class='col-sm-3 span3'><div class='input-group input-prepend input-group-sm'>";
      controls += "<span class='input-group-btn'> <button id='" + findButtonID + "' class='btn btn-default btn-sm' type='button'>Search</button></span>";
      controls += "<input id='" + findInputID + "' type='text' class='form-control input-small'></div></div>";
      controls += "<div class='col-sm-1 span1'></div>";
      controls += "<div class='col-sm-2 span2'><a href='#" + legendID + "'>Functions List</a></div>";
      controls += "</div>";
      opsHtml += "" + controls;
      jQuery("<div class='tree_operations'>" + opsHtml + "</div>").appendTo(el);
      num = this.elNum - 1;
      jQuery("#" + findButtonID).click(function(e) {
        var searchString;
        e.preventDefault();
        searchString = jQuery("#" + findInputID).val();
        return viewController.highlightInView(searchString, num);
      });
      jQuery("#" + fitButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'fit_window');
      });
      jQuery("#" + resetButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'reset_window');
      });
      jQuery("#" + expButtonID).click(function(e) {
        e.preventDefault();
        return viewController.viewAction(num, 'expand_tree');
      });
      return true;
    };

    TreeView.prototype.highlightGenomes = function(genomes, targetList) {
      var gs, l, maxy, n, targetNodes, _i, _j, _len, _len1, _ref;
      _ref = this.leaves;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        l.focus = false;
      }
      if ((targetList != null) && targetList.length) {
        targetNodes = this._blowUpPath(targetList);
        if (targetNodes.length) {
          maxy = 0;
          this.edgeNode = null;
          for (_j = 0, _len1 = targetNodes.length; _j < _len1; _j++) {
            n = targetNodes[_j];
            if (n.sum_length > maxy) {
              maxy = n.sum_length;
              this.edgeNode = n;
            }
          }
          this.expansionContraction = true;
          return this.update(genomes);
        } else {
          gs = targetList.join(', ');
          throw new SuperphyError("TreeView method highlightGenome error. Genome(s) " + gs + " not found.");
        }
      }
    };

    TreeView.prototype._blowUpPath = function(targetList) {
      var curr, g, n, targetNodes, _i, _len;
      targetNodes = [];
      for (_i = 0, _len = targetList.length; _i < _len; _i++) {
        g = targetList[_i];
        n = this._findLeaf(g);
        n.focus = true;
        targetNodes.push(n);
        curr = n.parent;
        while (curr) {
          if (curr._children != null) {
            curr.children = curr._children;
            curr._children = null;
          }
          curr = curr.parent;
        }
      }
      return targetNodes;
    };

    TreeView.prototype.expandTree = function(genomes) {
      this._blowUpAll(this.root);
      this.reformat = true;
      this.update(genomes);
      return true;
    };

    TreeView.prototype._blowUpAll = function(n) {
      var c, _i, _len, _ref;
      if (n._children != null) {
        n.children = n._children;
        n._children = null;
      }
      if (n.children != null) {
        _ref = n.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          this._blowUpAll(c);
        }
      }
      return true;
    };

    return TreeView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_msa.coffee
   Desc: Multiple Sequence Alignment View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 9th, 2013
   */


  /*
   CLASS MsaView
    
   Multiple Sequence Alignment view
   
   Always locus-based
   Returns nothing to redirect/select (no click behavior defined)
   */

  MsaView = (function(_super) {
    __extends(MsaView, _super);

    function MsaView(parentElem, style, elNum, msaArgs) {
      var alignmentJSON;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (!(msaArgs.length > 0)) {
        throw new SuperphyError('Missing argument. MsaView constructor requires JSON alignment object.');
      }
      alignmentJSON = msaArgs[0];
      this.locusData = null;
      if (msaArgs[1] != null) {
        this.locusData = msaArgs[1];
      }
      MsaView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this._formatAlignment(alignmentJSON);
    }

    MsaView.prototype.type = 'msa';

    MsaView.prototype.elName = 'genome_msa';

    MsaView.prototype.blockLen = 70;

    MsaView.prototype.nameLen = 25;

    MsaView.prototype.consLine = 'conservation_line';

    MsaView.prototype.posLine = 'position_line';

    MsaView.prototype.nuclClasses = {
      'A': 'nuclA',
      'G': 'nuclG',
      'C': 'nuclC',
      'T': 'nuclT',
      '*': 'consM',
      ' ': 'consMM',
      '-': 'nuclGAP'
    };

    MsaView.prototype.cssClass = 'msa_row_name';

    MsaView.prototype.maxRows = 26;

    MsaView.prototype.minRows = 1;

    MsaView.prototype._formatAlignment = function(alignmentJSON) {
      var g, j, n, pos, posElem, seq, seqLen, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      this.rowIDs = (function() {
        var _results;
        _results = [];
        for (g in alignmentJSON) {
          _results.push(g);
        }
        return _results;
      })();
      seqLen = alignmentJSON[this.rowIDs[0]]['seq'].length;
      this.alignment = {};
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        this.alignment[n] = {
          'alignment': [],
          'seq': alignmentJSON[n]['seq'],
          'genome': alignmentJSON[n]['genome'],
          'locus': alignmentJSON[n]['locus']
        };
      }
      this.alignment[this.consLine] = {
        'alignment': []
      };
      this.alignment[this.posLine] = {
        'alignment': []
      };
      this.numBlock = 0;
      for (j = _j = 0, _ref1 = this.blockLen; _ref1 > 0 ? _j <= seqLen : _j >= seqLen; j = _j += _ref1) {
        this.numBlock++;
        _ref2 = this.rowIDs;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          n = _ref2[_k];
          seq = alignmentJSON[n]['seq'];
          this.alignment[n]['alignment'].push(this._formatBlock(seq.substr(j, this.blockLen)));
        }
        pos = j + 1;
        posElem = "<td class='msaPosition'>" + pos + "</td>";
        this.alignment[this.posLine]['alignment'].push(posElem);
      }
      return true;
    };

    MsaView.prototype._formatBlock = function(seq) {
      var c, chr, cls, html, _i, _ref;
      html = '';
      seq.toUpperCase();
      for (c = _i = 0, _ref = seq.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; c = 0 <= _ref ? ++_i : --_i) {
        chr = seq.charAt(c);
        cls = this.nuclClasses[chr];
        html += "<td class='" + cls + "'>" + chr + "</td>";
      }
      return html;
    };

    MsaView.prototype.update = function(genomes) {
      var ft, msaElem, t1, t2;
      msaElem = jQuery("#" + this.elID);
      if (msaElem.length) {
        msaElem.empty();
        msaElem.append('<tbody></tbody>');
      } else {
        msaElem = jQuery("<table id='" + this.elID + "'><tbody></tbody></table>");
        jQuery(this.parentElem).append(msaElem);
      }
      t1 = new Date();
      this._appendRows(msaElem, genomes);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MsaView update elapsed time: ' + ft);
      return true;
    };

    MsaView.prototype._appendRows = function(el, genomes) {
      var a, consArray, g, genomeElem, genomeID, i, j, matches, n, name, nameCell, row, rows, thiscls, tmp, visibleRows, _i, _j, _k, _len, _len1, _ref, _ref1;
      genomeElem = {};
      visibleRows = [];
      tmp = {};
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        a = this.alignment[i];
        genomeID = a['genome'];
        g = genomes.genome(genomeID);
        if (g.visible) {
          visibleRows.push(i);
          name = g.viewname;
          if (this.locusData != null) {
            name += this.locusData.locusString(i);
          }
          tmp[i] = name;
          thiscls = this.cssClass;
          if (g.cssClass != null) {
            thiscls = this.cssClass + ' ' + g.cssClass;
          }
          nameCell = "<td class='" + thiscls + "' data-genome='" + genomeID + "'>" + name + "</td>";
          genomeElem[i] = nameCell;
        }
      }
      n = visibleRows.length;
      if (n >= this.maxRows) {
        el.html(("<tr class='msa-info'><td>Multiple sequence alignment is displayed when number of visible rows is below " + this.maxRows + ".</td></tr>") + ("<tr class='msa-info'><td>Current number of rows: " + n + "</td></tr>") + "<tr class='msa-info'><td>To view, either download alignment or use the filter to reduce visible genomes.</td></tr>");
      } else if (n <= this.minRows) {
        el.html(("<tr class='msa-info'><td>Multiple sequence alignment is displayed when number of visible rows is above " + this.minRows + ".</td></tr>") + ("<tr class='msa-info'><td>Current number of rows: " + n + "</td></tr>"));
      } else {
        visibleRows.sort(function(a, b) {
          var aname, bname;
          aname = tmp[a];
          bname = tmp[b];
          if (aname > bname) {
            return 1;
          } else if (aname < bname) {
            return -1;
          } else {
            return 0;
          }
        });
        matches = this.cigarLine(visibleRows);
        rows = '';
        for (j = _j = 0, _ref1 = this.numBlock; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          consArray = this.alignment[visibleRows[0]]['alignment'][j].split('');
          console.log(consArray.length);
          for (_k = 0, _len1 = visibleRows.length; _k < _len1; _k++) {
            i = visibleRows[_k];
            row = '<tr>';
            row += genomeElem[i] + this.alignment[i]['alignment'][j];
            row += '</tr>';
            rows += row;
          }
          row = '<tr>';
          row += '<td></td>' + matches[j];
          row += '</tr>';
          rows += row;
          row = '<tr>';
          row += this.alignment[this.posLine]['alignment'][j];
          row += '</tr>';
          rows += row;
        }
        el.append(rows);
      }
      return true;
    };

    MsaView.prototype.updateCSS = function(gset, genomes) {
      var msaEl;
      msaEl = jQuery("#" + this.elID);
      if (!((msaEl != null) && msaEl.length)) {
        throw new SuperphyError("DOM element for Msa view " + this.elID + " not found. Cannot call MsaView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    MsaView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = changedG.length; _i < _len; _i++) {
        g = changedG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        descriptor = "td[data-genome='" + g + "']";
        itemEl = el.find(descriptor);
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("Msa element for genome " + g + " not found in MsaView " + this.elID);
          return false;
        }
        console.log("Updating class to " + thiscls);
        liEl = itemEl.parents().eq(1);
        liEl.attr('class', thiscls);
      }
      return true;
    };

    MsaView.prototype.select = function(genome, isSelected) {
      return true;
    };

    MsaView.prototype.dump = function(genomes) {
      var a, g, genomeID, i, name, output, seq, _i, _len, _ref;
      output = '';
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        a = this.alignment[i];
        genomeID = a['genome'];
        g = genomes.genome(genomeID);
        if (g.visible) {
          name = g.viewname;
          if ((this.locusData != null) && (this.locusData[i] != null)) {
            name += this.locusData[i];
          }
          seq = a['seq'];
          output += ">" + name + "\n" + seq + "\n";
        }
      }
      return {
        ext: 'fasta',
        type: 'text/plain',
        data: output
      };
    };

    MsaView.prototype.cigarLine = function(visibleRows) {
      var c, consArray, consL, final, i, j, l, r, seq, _i, _j, _k, _l, _len, _len1, _ref, _ref1;
      consL = this.alignment[visibleRows[0]]["seq"].split('');
      l = consL.length - 1;
      _ref = visibleRows.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        seq = this.alignment[r]["seq"];
        for (i = _j = 0; 0 <= l ? _j <= l : _j >= l; i = 0 <= l ? ++_j : --_j) {
          c = consL[i];
          if (c !== '$') {
            if (c !== seq[i]) {
              consL[i] = '$';
            }
          }
        }
      }
      final = '';
      for (_k = 0, _len1 = consL.length; _k < _len1; _k++) {
        c = consL[_k];
        if (c === '$') {
          final += ' ';
        } else {
          final += '*';
        }
      }
      consArray = [];
      for (j = _l = 0, _ref1 = this.blockLen; _ref1 > 0 ? _l <= l : _l >= l; j = _l += _ref1) {
        consArray.push(this._formatBlock(final.substr(j, this.blockLen)));
      }
      return consArray;
    };

    return MsaView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_tickers.coffee
   Desc: Multiple Superphy Ticker Classes. Tickers are single line summaries of current genome data
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 16th, 2013
   */


  /*
   MIXIN support
   
   The function adds instance properties to a class.
   */

  mixOf = function() {
    var Mixed, base, method, mixin, mixins, name, _i, _ref;
    base = arguments[0], mixins = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    Mixed = (function(_super) {
      __extends(Mixed, _super);

      function Mixed() {
        return Mixed.__super__.constructor.apply(this, arguments);
      }

      return Mixed;

    })(base);
    for (_i = mixins.length - 1; _i >= 0; _i += -1) {
      mixin = mixins[_i];
      _ref = mixin.prototype;
      for (name in _ref) {
        method = _ref[name];
        Mixed.prototype[name] = method;
      }
    }
    return Mixed;
  };


  /*
   CLASS TickerTemplate
   
   Template object for tickers. Defines required and
   common properties/methods. All ticker objects
   are descendants of the TickerTemplate.
   */

  TickerTemplate = (function() {
    function TickerTemplate(parentElem, elNum) {
      this.parentElem = parentElem;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    TickerTemplate.prototype.elNum = 1;

    TickerTemplate.prototype.elName = 'ticker';

    TickerTemplate.prototype.elID = void 0;

    TickerTemplate.prototype.parentElem = void 0;

    TickerTemplate.prototype.cssClass = void 0;

    TickerTemplate.prototype.flavor = void 0;

    TickerTemplate.prototype.update = function(genomes) {
      throw new SuperphyError("TickerTemplate method update() must be defined in child class (" + this.flavor + ").");
      return false;
    };

    return TickerTemplate;

  })();


  /*
   CLASS MetaTicker
    
   Counts number of a specified meta-data item
   */

  MetaTicker = (function(_super) {
    __extends(MetaTicker, _super);

    function MetaTicker(parentElem, elNum, tickerArgs) {
      this.parentElem = parentElem;
      this.elNum = elNum;
      MetaTicker.__super__.constructor.call(this, this.parentElem, this.elNum);
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. MetaTicker constructor requires a string indicating meta-data type.');
      }
      this.metaType = tickerArgs[0];
    }

    MetaTicker.prototype.elName = 'meta_ticker';

    MetaTicker.prototype.cssClass = 'superphy_ticker_table';

    MetaTicker.prototype.flavor = 'meta';

    MetaTicker.prototype.noDataLabel = 'Not available';

    MetaTicker.prototype.update = function(genomes) {
      var bodyElem, bodyRow, countObj, ft, headElem, headRow, k, ks, t1, t2, tickerElem, v, _i, _len;
      tickerElem = jQuery("#" + this.elID);
      if (tickerElem.length) {
        tickerElem.empty();
      } else {
        tickerElem = jQuery("<table id='" + this.elID + "' class='" + this.cssClass + "'></table>");
        jQuery(this.parentElem).append(tickerElem);
      }
      t1 = new Date();
      countObj = {};
      this._updateCounts(countObj, genomes.pubVisible, genomes.public_genomes);
      this._updateCounts(countObj, genomes.pvtVisible, genomes.private_genomes);
      headElem = jQuery('<thead><tr></tr></thead>').appendTo(tickerElem);
      bodyElem = jQuery('<tbody><tr></tr></tbody>').appendTo(tickerElem);
      headRow = jQuery('<tr></tr>').appendTo(headElem);
      bodyRow = jQuery('<tr></tr>').appendTo(bodyElem);
      ks = ((function() {
        var _results;
        _results = [];
        for (k in countObj) {
          _results.push(k);
        }
        return _results;
      })()).sort(a, b)(function() {
        if (a === this.noDataLabel) {
          return 1;
        }
        if (b === this.noDataLabel) {
          return -1;
        }
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      for (_i = 0, _len = ks.length; _i < _len; _i++) {
        k = ks[_i];
        v = countObj[k];
        headRow.append("<th>" + k + "</th>");
        bodyRow.append("<td>" + v + "</td>");
      }
      t2 = new Date();
      ft = t2 - t1;
      console.log('MetaTicker update elapsed time: ' + ft);
      return true;
    };

    MetaTicker.prototype._updateCounts = function(counts, visibleG, genomes) {
      var g, meta, _i, _len;
      meta = this.metaType;
      console.log('META' + meta);
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        if (genomes[g][meta] != null) {
          if (counts[genomes[g][meta]] != null) {
            counts[genomes[g][meta]]++;
          } else {
            counts[genomes[g][meta]] = 1;
          }
        } else {
          if (counts[this.noDataLabel] != null) {
            counts[this.noDataLabel]++;
          } else {
            counts[this.noDataLabel] = 1;
          }
        }
      }
      return true;
    };

    return MetaTicker;

  })(TickerTemplate);


  /*
   CLASS LocusTicker
    
   Counts number of a specified meta-data item
   */

  StxTicker = (function(_super) {
    __extends(StxTicker, _super);

    function StxTicker(parentElem, elNum, tickerArgs) {
      this.parentElem = parentElem;
      this.elNum = elNum;
      StxTicker.__super__.constructor.call(this, this.parentElem, this.elNum, this.elNum);
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. StxTicker constructor requires a LocusController object.');
      }
      this.locusData = tickerArgs[0];
    }

    StxTicker.prototype.elName = 'stx_ticker';

    StxTicker.prototype.cssClass = 'superphy_ticker_table';

    StxTicker.prototype.flavor = 'stx';

    StxTicker.prototype.noDataLabel = 'NA';

    StxTicker.prototype.update = function(genomes) {
      var bodyElem, bodyRow, countObj, ft, headElem, headRow, k, ks, t1, t2, tickerElem, v, _i, _len;
      tickerElem = jQuery("#" + this.elID);
      if (tickerElem.length) {
        tickerElem.empty();
      } else {
        tickerElem = jQuery("<table id='" + this.elID + "' class='" + this.cssClass + "'></table>");
        jQuery(this.parentElem).append(tickerElem);
      }
      t1 = new Date();
      countObj = this.locusData.count(genomes);
      headElem = jQuery('<thead></thead>').appendTo(tickerElem);
      bodyElem = jQuery('<tbody></tbody>').appendTo(tickerElem);
      headRow = jQuery('<tr></tr>').appendTo(headElem);
      bodyRow = jQuery('<tr></tr>').appendTo(bodyElem);
      ks = (function() {
        var _results;
        _results = [];
        for (k in countObj) {
          _results.push(k);
        }
        return _results;
      })();
      ks.sort(function(a, b) {
        if (a === this.noDataLabel) {
          return 1;
        }
        if (b === this.noDataLabel) {
          return -1;
        }
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      for (_i = 0, _len = ks.length; _i < _len; _i++) {
        k = ks[_i];
        v = countObj[k];
        headRow.append("<th>" + k + "</th>");
        bodyRow.append("<td>" + v + "</td>");
      }
      t2 = new Date();
      ft = t2 - t1;
      console.log('StxTicker update elapsed time: ' + ft);
      return true;
    };

    return StxTicker;

  })(TickerTemplate);


  /*
   CLASS Histogram
    
   Histogram mixin
   */

  Histogram = (function() {
    function Histogram() {}

    Histogram.prototype.init = function() {
      var bins, margin;
      margin = {
        top: 40,
        right: 30,
        bottom: 40,
        left: 30
      };
      this.width = 300 - margin.left - margin.right;
      this.height = 250 - margin.top - margin.bottom;
      bins = [
        {
          'val': 0,
          'key': '0'
        }, {
          'val': 1,
          'key': '1'
        }, {
          'val': 2,
          'key': '2'
        }, {
          'val': 3,
          'key': '3'
        }, {
          'val': 4,
          'key': '4'
        }, {
          'val': 5,
          'key': '>=5'
        }
      ];
      this.x = d3.scale.ordinal().domain(bins.map(function(d) {
        return d.val;
      })).rangeRoundBands([0, this.width], .05);
      this.x2 = d3.scale.ordinal().domain(bins.map(function(d) {
        return d.key;
      })).rangeRoundBands([0, this.width], .05);
      this.xAxis = d3.svg.axis().scale(this.x2).orient("bottom");
      this.histogram = d3.layout.histogram().bins([0, 1, 2, 3, 4, 5, 6]);
      this.parentElem.append("<div id='" + this.elID + "' class='" + this.cssClass + "'></div>");
      this.canvas = d3.select("#" + this.elID).append("svg").attr("width", this.width + margin.left + margin.right).attr("height", this.height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      this.formatCount = d3.format(",.0f");
      return this.canvas.append("g").attr("class", "x axis").attr("transform", "translate(0," + this.height + ")").call(this.xAxis).append("text").attr("dy", ".75em").attr("y", 23).attr("x", this.width / 2).attr("text-anchor", "middle").text('Number of Alleles');
    };

    Histogram.prototype.updateHistogram = function(values) {
      var histData, i, maxSteps, maxY, newBars, steps, svgBars, yTop, _i;
      histData = this.histogram(values);
      steps = [10, 50, 100, 200, 500, 800, 1000, 1200, 1500, 2000, 5000, 8000, 10000, 20000, 50000, 80000, 100000];
      maxSteps = steps.length;
      maxY = d3.max(histData, function(d) {
        return d.y;
      });
      yTop = NaN;
      for (i = _i = 0; _i <= maxSteps; i = _i += 1) {
        if (maxY < steps[i]) {
          yTop = steps[i];
          break;
        }
      }
      this.y = d3.scale.linear().domain([0, yTop]).range([this.height, 0]);
      svgBars = this.canvas.selectAll("g.histobar").data(histData);
      svgBars.attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.x(d.x) + "," + _this.y(d.y) + ")";
        };
      })(this));
      svgBars.select("rect").attr("x", 0).attr("width", this.x.rangeBand()).attr("height", (function(_this) {
        return function(d) {
          return _this.height - _this.y(d.y);
        };
      })(this));
      svgBars.select("text").attr("dy", ".75em").attr("y", -14).attr("x", this.x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.y > 0) {
            return _this.formatCount(d.y);
          } else {
            return '';
          }
        };
      })(this));
      svgBars.exit().remove();
      newBars = svgBars.enter().append("g").attr("class", "histobar").attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.x(d.x) + "," + _this.y(d.y) + ")";
        };
      })(this));
      newBars.append("rect").attr("x", 0).attr("width", this.x.rangeBand()).attr("height", (function(_this) {
        return function(d) {
          return _this.height - _this.y(d.y);
        };
      })(this));
      newBars.append("text").attr("dy", ".75em").attr("y", -14).attr("x", this.x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.y > 0) {
            return _this.formatCount(d.y);
          } else {
            return '';
          }
        };
      })(this));
      return true;
    };

    return Histogram;

  })();


  /*
   CLASS MatrixTicker
    
   Histogram of allele frequency for multiple genes
   */

  MatrixTicker = (function(_super) {
    __extends(MatrixTicker, _super);

    function MatrixTicker(parentElem, elNum, genomes, tickerArgs) {
      var alleles, genes, tmp;
      this.parentElem = parentElem;
      this.elNum = elNum;
      MatrixTicker.__super__.constructor.call(this, this.parentElem, this.elNum, this.elNum);
      if (genomes == null) {
        throw new SuperphyError('Missing argument. MatrixTicker constructor requires GenomeController object.');
      }
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. MatrixTicker constructor requires a JSON object containing: nodes, links object.');
      }
      tmp = tickerArgs[0];
      genes = tmp['nodes'];
      alleles = tmp['links'];
      this._doCounts(genomes, genes, alleles);
      this.init();
    }

    MatrixTicker.prototype.elName = 'matrix_ticker';

    MatrixTicker.prototype.cssClass = 'matrix_histogram';

    MatrixTicker.prototype.flavor = 'matrix';

    MatrixTicker.prototype.noDataLabel = 'NA';

    MatrixTicker.prototype.update = function(genomes) {
      var ft, g, n, t1, t2, values, _i, _j, _len, _len1, _ref, _ref1;
      t1 = new Date();
      values = [];
      _ref = genomes.pubVisible.concat(genomes.pvtVisible);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        _ref1 = this.geneList;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          n = _ref1[_j];
          if (!((this.counts[g] != null) && (this.counts[g][n] != null))) {
            throw new SuperphyError("Count not defined for genome " + g + " and gene " + n + ".");
          }
          values.push(this.counts[g][n]);
        }
      }
      this.updateHistogram(values);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MatrixTicker update elapsed time: ' + ft);
      return true;
    };

    MatrixTicker.prototype._doCounts = function(genomes, genes, alleles) {
      var g, gList, n, numAlleles, _i, _j, _len, _len1, _ref;
      gList = Object.keys(genomes.public_genomes).concat(Object.keys(genomes.private_genomes));
      this.geneList = Object.keys(genes);
      this.counts = {};
      for (_i = 0, _len = gList.length; _i < _len; _i++) {
        g = gList[_i];
        this.counts[g] = {};
        _ref = this.geneList;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          n = _ref[_j];
          numAlleles = 0;
          if ((alleles[g] != null) && (alleles[g][n] != null)) {
            numAlleles = alleles[g][n].length;
          }
          this.counts[g][n] = numAlleles;
        }
      }
      return true;
    };

    return MatrixTicker;

  })(mixOf(TickerTemplate, Histogram));


  /*
   CLASS AlleleTicker
    
   Histogram of allele frequency for one gene
   */

  AlleleTicker = (function(_super) {
    __extends(AlleleTicker, _super);

    function AlleleTicker(parentElem, elNum, tickerArgs) {
      this.parentElem = parentElem;
      this.elNum = elNum;
      AlleleTicker.__super__.constructor.call(this, this.parentElem, this.elNum, this.elNum);
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. AlleleTicker constructor requires a LocusController object.');
      }
      this.locusData = tickerArgs[0];
      this.init();
    }

    AlleleTicker.prototype.elName = 'allele_ticker';

    AlleleTicker.prototype.cssClass = 'allele_histogram';

    AlleleTicker.prototype.flavor = 'allele';

    AlleleTicker.prototype.noDataLabel = 'NA';

    AlleleTicker.prototype.update = function(genomes) {
      var ft, t1, t2, values;
      t1 = new Date();
      values = this.locusData.count(genomes);
      this.updateHistogram(values);
      t2 = new Date();
      ft = t2 - t1;
      console.log('AlleleTicker update elapsed time: ' + ft);
      return true;
    };

    return AlleleTicker;

  })(mixOf(TickerTemplate, Histogram));


  /*
  
  
   File: superphy_matrix.coffee
   Desc: Genome x Gene table showing # of alleles
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 24th, 2013
   */


  /*
   CLASS MatrixView
    
   Gene Allele Matrix view
   
   Always genome based
   Links to individual genes
   */

  MatrixView = (function(_super) {
    __extends(MatrixView, _super);

    function MatrixView(parentElem, style, elNum, genomes, matrixArgs) {
      var alleles, dd, ddDiv, dialog, dialog2, gList, genes, nList, num, tmp;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (genomes == null) {
        throw new SuperphyError('Missing argument. MatrixView constructor requires GenomeController object.');
      }
      if (!(matrixArgs.length > 0)) {
        throw new SuperphyError('Missing argument. MatrixView constructor requires JSON object containing: nodes, links.');
      }
      tmp = matrixArgs[0];
      genes = tmp['nodes'];
      alleles = tmp['links'];
      gList = Object.keys(genomes.public_genomes).concat(Object.keys(genomes.private_genomes));
      nList = Object.keys(genes);
      this.cellWidth = 20;
      this.margin = {
        top: 150,
        right: 0,
        bottom: 0,
        left: 250
      };
      this.height = gList.length * this.cellWidth;
      this.width = nList.length * this.cellWidth;
      this.dim = {
        w: this.width + this.margin.right + this.margin.left,
        h: this.height + this.margin.top + this.margin.bottom
      };
      MatrixView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this._computeMatrix(gList, genes, alleles);
      this.geneOrders = {
        name: d3.range(this.nGenes).sort((function(_this) {
          return function(a, b) {
            return d3.ascending(_this.geneNodes[a].name, _this.geneNodes[b].name);
          };
        })(this)),
        count: d3.range(this.nGenes).sort((function(_this) {
          return function(a, b) {
            return _this.geneNodes[b].count - _this.geneNodes[a].count;
          };
        })(this))
      };
      this.geneOrders['group'] = this.geneOrders['count'];
      this.orderType = 'name';
      this.z = d3.scale.linear().domain([0, 4]).clamp(true);
      this.x = d3.scale.ordinal().rangeBands([0, this.width]);
      this.cssClass = 'superphy-matrix';
      this.parentElem.append("<div id='" + this.elID + "' class='" + this.cssClass + "'></div>");
      ddDiv = jQuery('<div class="matrixSort"><span>Order:</span> </div>').appendTo("#" + this.elID);
      dd = jQuery('<select name="matrix-sort">' + '<option value="name" selected="selected"> by Name</option>' + '<option value="count"> by Frequency</option>' + '<option value="group"> by Group</option>' + '</select>').appendTo(ddDiv);
      num = this.elNum - 1;
      dd.change(function() {
        var sortType;
        sortType = this.value;
        return viewController.viewAction(num, 'matrix_sort', sortType);
      });
      this.wrap = d3.select("#" + this.elID).append("div").attr("class", "matrix-container").append("svg").attr("width", this.dim.w).attr("height", this.dim.h);
      this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      this.canvas.append("rect").attr("class", "matrixBackground").attr("width", this.width).attr("height", this.height);
      this.formatCount = d3.format(",.0f");
      dialog = jQuery('#dialog-matrix-row-select');
      if (!dialog.length) {
        dialog = jQuery('<div id="dialog-matrix-row-select"></div>').appendTo('body');
        dialog.text("Jump to genome information page?").dialog({
          title: 'Genome Information',
          autoOpen: false,
          resizable: false,
          height: 160,
          modal: true,
          buttons: {
            Yes: function() {
              var id;
              id = jQuery(this).data("row-id");
              window.location.href = "/strains/info?genome=" + id;
              return jQuery(this).dialog("close");
            },
            Cancel: function() {
              return jQuery(this).dialog("close");
            }
          }
        });
      }
      dialog2 = jQuery('#dialog-matrix-col-select');
      if (!dialog2.length) {
        dialog2 = jQuery('<div id="dialog-matrix-col-select"></div>').appendTo('body');
        dialog2.text("Jump to gene page?").dialog({
          title: 'Detailed Gene Information',
          autoOpen: false,
          resizable: false,
          height: 160,
          modal: true,
          buttons: {
            Yes: function() {
              var id;
              id = jQuery(this).data("col-id");
              window.location.href = "/genes/info?gene=" + id;
              return jQuery(this).dialog("close");
            },
            Cancel: function() {
              return jQuery(this).dialog("close");
            }
          }
        });
      }
      true;
    }

    MatrixView.prototype.type = 'matrix';

    MatrixView.prototype.elName = 'genome_matrix';

    MatrixView.prototype.duration = 500;

    MatrixView.prototype._computeMatrix = function(gList, genes, alleles) {
      var g, gObj, i, n, nList, numAlleles, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
      nList = Object.keys(genes);
      this.nGenomes = gList.length;
      this.nGenes = nList.length;
      this.genomeNodes = [];
      this.matrix = [];
      i = 0;
      for (_i = 0, _len = gList.length; _i < _len; _i++) {
        g = gList[_i];
        gObj = {
          id: i,
          genome: g,
          count: 0
        };
        this.genomeNodes.push(gObj);
        this.matrix[i] = d3.range(this.nGenes).map(function(j) {
          return {
            x: j,
            y: i,
            z: 0,
            i: null
          };
        });
        i++;
      }
      this.geneNodes = [];
      i = 0;
      for (_j = 0, _len1 = nList.length; _j < _len1; _j++) {
        g = nList[_j];
        gObj = {
          id: i,
          gene: g,
          name: genes[g],
          count: 0
        };
        this.geneNodes.push(gObj);
        i++;
      }
      i = 0;
      _ref = this.genomeNodes;
      for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
        g = _ref[_k];
        _ref1 = this.geneNodes;
        for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
          n = _ref1[_l];
          numAlleles = 0;
          if ((alleles[g.genome] != null) && (alleles[g.genome][n.gene] != null)) {
            numAlleles = alleles[g.genome][n.gene].length;
          }
          g.count += numAlleles;
          n.count += numAlleles;
          this.matrix[g.id][n.id].z = numAlleles;
          this.matrix[g.id][n.id].i = i;
          i++;
        }
      }
      return true;
    };

    MatrixView.prototype.update = function(genomes) {
      var dt, genomesExit, newCols, newRows, svgGenes, svgGenomes, t1, t2, that;
      t1 = new Date();
      this._sync(genomes);
      this.height = this.cellWidth * this.currN;
      this.y = d3.scale.ordinal().rangeBands([0, this.height]);
      this.y.domain(this.genomeOrders[this.orderType]);
      this.x.domain(this.geneOrders[this.orderType]);
      this.canvas.selectAll(".matrixBackground").attr("height", this.height);
      svgGenomes = this.canvas.selectAll("g.matrixrow").data(this.currNodes, function(d) {
        return d.id;
      });
      svgGenomes.attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).select("text.matrixlabel").text(function(d) {
        return d.viewname;
      });
      svgGenomes.selectAll("g.matrixcell title").text(function(d) {
        return d.title;
      });
      that = this;
      newRows = svgGenomes.enter().append("g").attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).attr("transform", function(d, i) {
        return "translate(0,0)";
      }).each(function(d) {
        return that._row(this, that.matrix[d.id], that.x, that.y, that.z);
      });
      newRows.append("line").attr("x2", this.width);
      newRows.append("text").attr("class", "matrixlabel").attr("x", -6).attr("y", this.y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "end").text(function(d) {
        return d.viewname;
      }).on("click", function(d) {
        return jQuery('#dialog-matrix-row-select').data('row-id', d.genome).dialog('open');
      });
      svgGenes = this.canvas.selectAll("g.matrixcolumn").data(this.geneNodes, function(d) {
        return d.id;
      });
      svgGenes.selectAll("line").attr("x1", -this.height);
      newCols = svgGenes.enter().append("g").attr("class", "matrixcolumn").attr("transform", function(d, i) {
        return "translate(" + 0 + ")rotate(-90)";
      });
      newCols.append("line").attr("x1", -this.height);
      newCols.append("text").attr("class", "matrixlabel").attr("x", 6).attr("y", this.y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "start").text(function(d) {
        return d.name;
      }).on("click", function(d) {
        return jQuery('#dialog-matrix-col-select').data('col-id', d.gene).dialog('open');
      });
      this._assumePositions();
      genomesExit = svgGenomes.exit().transition().duration(this.duration).attr("transform", function(d) {
        return "translate(0,0)";
      }).remove();
      t2 = new Date();
      dt = new Date(t2 - t1);
      console.log('MatrixView update elapsed time (s): ' + dt.getMilliseconds());
      return true;
    };

    MatrixView.prototype._sync = function(genomes) {
      var c, g, i, n, _i, _j, _len, _len1, _ref, _ref1;
      this.currNodes = [];
      this.currN = 0;
      _ref = this.genomeNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        g = genomes.genome(n.genome);
        if (g.visible) {
          n.viewname = g.viewname;
          n.selected = (g.isSelected != null) && g.isSelected;
          if (g.assignedGroup != null) {
            n.assignedGroup = g.assignedGroup;
          } else {
            n.assignedGroup = 0;
          }
          n.index = this.currN;
          this.currNodes.push(n);
          this.currN++;
          i = 0;
          _ref1 = this.matrix[n.id];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            c = _ref1[_j];
            c.title = "genome: " + n.viewname + ", gene: " + this.geneNodes[i].name;
            i++;
          }
        }
      }
      this.genomeOrders = {
        name: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            return d3.ascending(_this.currNodes[a].viewname, _this.currNodes[b].viewname);
          };
        })(this)),
        count: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            return _this.currNodes[b].count - _this.currNodes[a].count;
          };
        })(this)),
        group: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            var gdiff;
            gdiff = _this.currNodes[b].assignedGroup - _this.currNodes[a].assignedGroup;
            if (gdiff === 0) {
              return _this.currNodes[b].count - _this.currNodes[a].count;
            } else {
              return gdiff;
            }
          };
        })(this))
      };
      return true;
    };

    MatrixView.prototype._row = function(svgRow, rowData, x, y, z) {
      var newCells, num, svgCells;
      svgCells = d3.select(svgRow).selectAll(".matrixcell").data(rowData, function(d) {
        return d.i;
      });
      num = this.elNum - 1;
      newCells = svgCells.enter().append("g").attr("class", "matrixcell").attr("transform", (function(_this) {
        return function(d, i) {
          return "translate(" + _this.x(d.x) + ",0)";
        };
      })(this)).on("mouseover", (function(_this) {
        return function(p) {
          return _this._mouseover(p);
        };
      })(this)).on("mouseout", this._mouseout);
      newCells.append("rect").attr("x", 0).attr("width", x.rangeBand()).attr("height", y.rangeBand()).style("fill-opacity", function(d) {
        return z(d.z);
      });
      newCells.append("text").attr("dy", ".32em").attr("y", x.rangeBand() / 2).attr("x", x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.z > 0) {
            return _this.formatCount(d.z);
          } else {
            return '';
          }
        };
      })(this));
      newCells.append("title").text(function(d) {
        return d.title;
      });
      return true;
    };

    MatrixView.prototype._assumePositions = function() {
      var that, transit;
      that = this;
      transit = this.canvas.transition().duration(this.duration);
      transit.selectAll(".matrixrow").attr("transform", function(d, i) {
        return "translate(0," + that.y(d.index) + ")";
      }).selectAll(".matrixcell").attr("x", function(d) {
        return that.x(d.x);
      }).attr("transform", (function(_this) {
        return function(d, i) {
          return "translate(" + that.x(d.x) + ",0)";
        };
      })(this));
      transit.selectAll(".matrixcolumn").attr("transform", function(d, i) {
        return "translate(" + that.x(i) + ")rotate(-90)";
      });
      return true;
    };

    MatrixView.prototype._mouseover = function(p) {
      d3.selectAll(".matrixrow text").classed("matrixActive", function(d, i) {
        return d.index === p.y;
      });
      return d3.selectAll(".matrixcolumn text").classed("matrixActive", function(d, i) {
        return i === p.x;
      });
    };

    MatrixView.prototype._mouseout = function() {
      return d3.selectAll("text").classed("matrixActive", false);
    };

    MatrixView.prototype._classList = function(d) {
      var clsList;
      clsList = ['matrixrow'];
      if (d.selected) {
        clsList.push("selectedRow");
      }
      if (d.assignedGroup != null) {
        clsList.push("groupedRow" + d.assignedGroup);
      }
      return clsList.join(' ');
    };

    MatrixView.prototype.viewAction = function(genomes, argArray) {
      var event, _ref;
      event = argArray.shift();
      if (event === 'matrix_sort') {
        this.orderType = argArray[0];
        if (_ref = this.orderType, __indexOf.call(Object.keys(this.geneOrders), _ref) < 0) {
          throw new SuperphyError("Unrecognized order type: " + this.orderType + " in MatrixView viewAction method.");
        }
        this.update(genomes);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in MatrixView viewAction method.");
      }
      return true;
    };

    MatrixView.prototype.dump = function(genomes) {
      var g, n, numAlleles, row, rows, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      rows = [];
      row = [];
      row.push("#");
      _ref = this.geneNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        row.push(n.name);
      }
      rows.push(row.join("\t"));
      _ref1 = this.currNodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        g = _ref1[_j];
        row = [];
        row.push(g.viewname);
        _ref2 = this.geneNodes;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          n = _ref2[_k];
          numAlleles = this.matrix[g.id][n.id].z;
          row.push(numAlleles);
        }
        rows.push(row.join("\t"));
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: rows.join("\n")
      };
    };

    MatrixView.prototype.updateCSS = function(gset, genomes) {
      var g, genomeList, svgNodes, _i, _j, _len, _len1, _ref, _ref1;
      genomeList = {};
      if (gset["public"] != null) {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          genomeList[g] = genomes.public_genomes[g];
        }
      }
      if (gset["private"] != null) {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          genomeList[g] = genomes.private_genomes[g];
        }
      }
      svgNodes = this.canvas.selectAll("g.matrixrow");
      svgNodes.filter(function(d) {
        return genomeList[d.genome] != null;
      }).attr("class", (function(_this) {
        return function(d) {
          g = genomeList[d.genome];
          d.viewname = g.viewname;
          d.selected = (g.isSelected != null) && g.isSelected;
          if (g.assignedGroup != null) {
            d.assignedGroup = g.assignedGroup;
          } else {
            d.assignedGroup = 0;
          }
          return _this._classList(d);
        };
      })(this));
      return true;
    };

    MatrixView.prototype.select = function(genome, isSelected) {
      return true;
    };

    return MatrixView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_table.coffee
   Desc: Attribute Table View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: May 27th, 2013
   */


  /*
   CLASS TableView
    
   Attribute Table view
   
   Always genome-based
   Returns genome ID to redirect/select when genome list item is clicked
   */

  TableView = (function(_super) {
    __extends(TableView, _super);

    function TableView(parentElem, style, elNum, tableArgs) {
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if ((tableArgs != null) && (tableArgs[0] != null)) {
        this.locusData = tableArgs[0];
      }
      TableView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.sortField = 'displayname';
      this.sortAsc = true;
    }

    TableView.prototype.type = 'table';

    TableView.prototype.elName = 'genome_table';

    TableView.prototype.locusData = null;

    TableView.prototype.update = function(genomes) {
      var divElem, ft, t1, t2, table, tableElem;
      tableElem = jQuery("#" + this.elID + " table");
      if (tableElem.length) {
        tableElem.empty();
      } else {
        divElem = jQuery("<div id='" + this.elID + "' class='superphy-table'/>");
        tableElem = jQuery("<table />").appendTo(divElem);
        jQuery(this.parentElem).append(divElem);
      }
      t1 = new Date();
      table = '';
      table += this._appendHeader(genomes);
      table += '<tbody>';
      table += this._appendGenomes(genomes.sort(genomes.pubVisible, this.sortField, this.sortAsc), genomes.public_genomes, this.style, false);
      table += this._appendGenomes(genomes.sort(genomes.pvtVisible, this.sortField, this.sortAsc), genomes.private_genomes, this.style, true);
      table += '</tbody>';
      tableElem.append(table);
      this._actions(tableElem, this.style);
      t2 = new Date();
      ft = t2 - t1;
      console.log('TableView update elapsed time: ' + ft);
      return true;
    };

    TableView.prototype.intro = function() {
      var tableIntro;
      tableIntro = [];
      tableIntro.push({
        element: document.querySelector('#genome_table1'),
        intro: "These are the names of the genomes in the database.  Check the boxes to select each genome.",
        position: 'right'
      });
      return tableIntro;
    };

    TableView.prototype._template = function(tmpl, values) {
      var html;
      html = null;
      if (tmpl === 'tr') {
        html = "<tr>" + values.row + "</tr>";
      } else if (tmpl === 'th') {
        html = "<th><a class='genome-table-sort' href='#' data-genomesort='" + values.type + "'>" + values.name + " <i class='fa " + values.sortIcon + "'></i></a></th>";
      } else if (tmpl === 'td') {
        html = "<td>" + values.data + "</td>";
      } else if (tmpl === 'td1_redirect') {
        html = "<td class='" + values.klass + "'>" + values.name + " <a class='genome-table-link' href='#' data-genome='" + values.g + "' title='Genome " + values.shortName + " info'><i class='fa fa-search'></i></a></td>";
      } else if (tmpl === 'td1_select') {
        html = "<td class='" + values.klass + "'><div class='checkbox'><label><input class='checkbox genome-table-checkbox' type='checkbox' value='" + values.g + "' " + values.checked + "/> " + values.name + "</label></div></td>";
      } else if (tmpl === 'spacer') {
        html = "<tr class='genome-table-spacer'><td>---- USER-SUBMITTED GENOMES ----</td></tr>";
      } else {
        throw new SuperphyError("Unknown template type " + tmpl + " in TableView method _template");
      }
      return html;
    };

    TableView.prototype._appendHeader = function(genomes) {
      var i, sortIcon, t, tName, table, v, values, _i, _j, _len, _len1, _ref;
      table = '<thead><tr>';
      values = [];
      i = -1;
      if (this.sortField === 'displayname') {
        sortIcon = 'fa-sort-asc';
        if (!this.sortAsc) {
          sortIcon = 'fa-sort-desc';
        }
        values[++i] = {
          type: 'displayname',
          name: 'Genome',
          sortIcon: sortIcon
        };
      } else {
        values[++i] = {
          type: 'displayname',
          name: 'Genome',
          sortIcon: 'fa-sort'
        };
      }
      _ref = genomes.mtypes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (!genomes.visibleMeta[t]) {
          continue;
        }
        tName = genomes.metaMap[t];
        sortIcon = null;
        if (t === this.sortField) {
          sortIcon = 'fa-sort-asc';
          if (!this.sortAsc) {
            sortIcon = 'fa-sort-desc';
          }
        } else {
          sortIcon = 'fa-sort';
        }
        values[++i] = {
          type: t,
          name: tName,
          sortIcon: sortIcon
        };
      }
      for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
        v = values[_j];
        table += this._template('th', v);
      }
      table += '</tr></thead>';
      return table;
    };

    TableView.prototype._appendGenomes = function(visibleG, genomes, style, priv) {
      var checked, cls, d, g, gObj, name, row, table, thiscls, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      cls = this.cssClass();
      table = '';
      if (priv && visibleG.length) {
        table += this._template('spacer', null);
      }
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        row = '';
        gObj = genomes[g];
        thiscls = cls;
        if (gObj.cssClass != null) {
          thiscls = cls + ' ' + gObj.cssClass;
        }
        name = gObj.meta_array[0];
        if (this.locusData != null) {
          name += this.locusData.genomeString(g);
        }
        if (style === 'redirect') {
          row += this._template('td1_redirect', {
            g: g,
            name: name,
            shortName: gObj.meta_array[0],
            klass: thiscls
          });
          _ref = gObj.meta_array.slice(1);
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            d = _ref[_j];
            row += this._template('td', {
              data: d
            });
          }
          table += this._template('tr', {
            row: row
          });
        } else if (style === 'select') {
          checked = '';
          if (gObj.isSelected) {
            checked = 'checked';
          }
          row += this._template('td1_select', {
            g: g,
            name: name,
            klass: thiscls,
            checked: checked
          });
          _ref1 = gObj.meta_array.slice(1);
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            d = _ref1[_k];
            row += this._template('td', {
              data: d
            });
          }
          table += this._template('tr', {
            row: row
          });
        } else {
          return false;
        }
      }
      return table;
    };

    TableView.prototype._actions = function(tableEl, style) {
      var num;
      num = this.elNum - 1;
      tableEl.find('.genome-table-sort').click(function(e) {
        var sortField;
        e.preventDefault();
        sortField = this.dataset.genomesort;
        return viewController.viewAction(num, 'sort', sortField);
      });
      if (style === 'select') {
        tableEl.find('.genome-table-checkbox').click(function(e) {
          return viewController.select(this.value, this.checked);
        });
      }
      if (style === 'redirect') {
        return tableEl.find('.genome-table-link').click(function(e) {
          var gid;
          e.preventDefault();
          gid = this.dataset.genome;
          return viewController.select(gid, true);
        });
      }
    };

    TableView.prototype.updateCSS = function(gset, genomes) {
      var tableEl;
      tableEl = jQuery("#" + this.elID);
      if (!((tableEl != null) && tableEl.length)) {
        throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call TableView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(tableEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(tableEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    TableView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, dataEl, descriptor, g, itemEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = changedG.length; _i < _len; _i++) {
        g = changedG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        dataEl = null;
        if (this.style === 'redirect') {
          descriptor = "td > a[data-genome='" + g + "']";
          itemEl = el.find(descriptor);
          if (!((itemEl != null) && itemEl.length && genomes[g].visible === true)) {
            continue;
          }
          dataEl = itemEl.parent();
        } else if (this.style === 'select') {
          descriptor = "td input[value='" + g + "']";
          itemEl = el.find(descriptor);
          if (!((itemEl != null) && itemEl.length && genomes[g].visible === true)) {
            continue;
          }
          dataEl = itemEl.parents().eq(1);
        } else {
          return false;
        }
        dataEl.attr('class', thiscls);
      }
      return true;
    };

    TableView.prototype.select = function(genome, isSelected) {
      var descriptor, itemEl;
      itemEl = null;
      if (this.style === 'select') {
        descriptor = "td input[value='" + genome + "']";
        itemEl = jQuery(descriptor);
      } else {
        return false;
      }
      itemEl.prop('checked', isSelected);
      return true;
    };

    TableView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, _ref, _ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var _i, _len, _ref, _results;
        _ref = genomes.mtypes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          _results.push(genomes.metaMap[k]);
        }
        return _results;
      })();
      header.unshift("Superphy ID", "Genome name");
      output += "#" + header.join("\t") + "\n";
      _ref = genomes.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        output += id + "\t" + genomes.label(g, fullMeta, "\t") + "\n";
      }
      _ref1 = genomes.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        output += id + "\t" + genomes.label(g, fullMeta, "\t") + "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    TableView.prototype.viewAction = function(genomes, argArray) {
      var event;
      event = argArray.shift();
      if (event === 'sort') {
        this._sort(genomes, argArray[0]);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in TableView viewAction method.");
      }
      return true;
    };

    TableView.prototype._sort = function(genomes, field) {
      if (field === this.sortField) {
        if (this.sortAsc) {
          this.sortAsc = false;
        } else {
          this.sortAsc = true;
        }
      } else {
        this.sortField = field;
        this.sortAsc = true;
      }
      console.log([field, this.sortField, this.sortAsc].join(', '));
      return this.update(genomes);
    };

    return TableView;

  })(ViewTemplate);


  /*
  
   File: superphy_map.coffee
   Desc: Objects & functions for managing geospatial views in Superphy
   Author: Akiff Manji akiff.manji@gmail.com
   Date: May 6, 2014
   */

  MapView = (function(_super) {
    __extends(MapView, _super);

    function MapView(parentElem, style, elNum, genomeController, mapArgs) {
      var buttonEl, input, inputGpEl, manifestRow, map, mapCanvasEl, mapManifest, mapManifestEl, mapRow, mapSearchEl, mapSearchRow, mapSplitLayout, menu, menuRow, resetEl, resetMapView, searchEl;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      this.genomeController = genomeController;
      this.mapArgs = mapArgs;
      MapView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.sortField = 'isolation_country';
      this.sortAsc = 'true';
      this.locationMetaFields = {
        'isolation_country': 'Country',
        'isolation_province_state': 'Province/State',
        'isolation_city': 'City'
      };
      mapSplitLayout = jQuery('<div class="map-split-layout row"></div>').appendTo(jQuery(this.parentElem));
      mapSearchEl = jQuery('<div class="map-search-wrapper col-md-6 span6"></div>').appendTo(mapSplitLayout);
      mapSearchRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapSearchEl);
      searchEl = jQuery('<div class="col-md-9 span9"></div>').appendTo(mapSearchRow);
      resetEl = jQuery('<div class="col-md-3 span3"></div>').appendTo(mapSearchRow);
      mapRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapSearchEl);
      map = jQuery('<div class="col-md-12 span12"></div>').appendTo(mapRow);
      mapCanvasEl = jQuery('<div class="map-canvas"></div>').appendTo(map);
      inputGpEl = jQuery('<div class="input-group input-append"></div></div>').appendTo(searchEl);
      input = jQuery('<input type="text" class="form-control map-search-location input-xlarge" placeholder="Enter a search location">').appendTo(inputGpEl);
      buttonEl = jQuery('<span class="input-group-btn"><button class="btn btn-default map-search-button" type="button"><span class="fa fa-search"></span></button></span>').appendTo(inputGpEl);
      resetMapView = jQuery('<button id="reset-map-view" type="button" class="btn btn-link">Reset Map View</button>').appendTo(resetEl);
      mapManifestEl = jQuery('<div class="map-manifest-wrapper col-md-6 span6"></div>').appendTo(mapSplitLayout);
      menuRow = jQuery('<div class="row"></div>').appendTo(mapManifestEl);
      menu = jQuery('<div class="map-menu col-md-12 span12"></div>').appendTo(menuRow);
      manifestRow = jQuery('<div class="geospatial-row row"></div>').appendTo(mapManifestEl);
      mapManifest = jQuery('<div class="col-md-12 span12"></div>').appendTo(manifestRow);
      mapManifestEl = jQuery('<div class="map-manifest"></div>').appendTo(mapManifest);
      this.locationController = this.getLocationController(this.mapArgs[0], this.elNum);
      this.mapController = this.getCartographer(this.mapArgs[0], this.locationController);
      jQuery(this.parentElem).data('views-index', this.elNum);
      resetEl.click((function(_this) {
        return function(e) {
          e.preventDefault();
          return _this.mapController.resetMapView();
        };
      })(this));
    }

    MapView.prototype.type = 'map';

    MapView.prototype.elName = 'genome_map';

    MapView.prototype.mapView = true;

    MapView.prototype.update = function(genomes) {
      var divElem, ft, i, mapManifest, pubVis, pvtVis, t1, t2, table, tableElem, that, toggleUnknownLocations, unknownsOff, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      tableElem = jQuery("#" + this.elID + " table");
      if (tableElem.length) {
        tableElem.empty();
      } else {
        divElem = jQuery("<div id='" + this.elID + "' class='superphy-table'/>");
        tableElem = jQuery("<table />").appendTo(divElem);
        mapManifest = jQuery('.map-manifest').append(divElem);
        toggleUnknownLocations = jQuery('<div class="checkbox toggle-unknown-location" id="unknown-location"><label><input type="checkbox">Unknown Locations Off</label></div>').appendTo(jQuery('.map-menu'));
        that = this;
        toggleUnknownLocations.change(function() {
          return that.update(that.genomeController);
        });
      }
      unknownsOff = jQuery('.toggle-unknown-location').find('input')[0].checked;
      pubVis = [];
      pvtVis = [];
      if (this.locationController == null) {
        pubVis = genomes.pubVisible;
        pvtVis = genomes.pvtVisible;
      } else {
        this.mapController.resetMarkers();
        _ref = this.mapController.visibleLocations;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          if (__indexOf.call(genomes.pubVisible, i) >= 0) {
            pubVis.push(i);
          }
        }
        _ref1 = this.mapController.visibleLocations;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          i = _ref1[_j];
          if (__indexOf.call(genomes.pvtVisible, i) >= 0) {
            pvtVis.push(i);
          }
        }
        if (!unknownsOff) {
          _ref2 = this.locationController.pubNoLocations;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            i = _ref2[_k];
            if (__indexOf.call(genomes.pubVisible, i) >= 0) {
              pubVis.push(i);
            }
          }
        }
        if (!unknownsOff) {
          _ref3 = this.locationController.pvtNoLocations;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            i = _ref3[_l];
            if (__indexOf.call(genomes.pvtVisible, i) >= 0) {
              pvtVis.push(i);
            }
          }
        }
      }
      t1 = new Date();
      table = '';
      table += this._appendHeader(genomes);
      table += '<tbody>';
      table += this._appendGenomes(genomes.sort(pubVis, this.sortField, this.sortAsc), genomes.public_genomes, this.style, false, true);
      table += this._appendGenomes(genomes.sort(pvtVis, this.sortField, this.sortAsc), genomes.private_genomes, this.style, true, true);
      table += '</body>';
      tableElem.append(table);
      this._actions(tableElem, this.style);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MapView update elapsed time: ' + ft);
      return true;
    };

    MapView.prototype.intro = function() {
      var mapIntro;
      mapIntro = [];
      mapIntro.push({
        element: document.querySelector('.map-canvas'),
        intro: "This map displays the location of genomes around the world.",
        position: 'right'
      });
      mapIntro.push({
        element: document.querySelector('.map-search-location'),
        intro: "Input a location here to see genomes found in that region.",
        position: 'right'
      });
      mapIntro.push({
        element: document.querySelector('#genome_map3'),
        intro: "The genomes corresponding to locations on the map are shown here.  Check the boxes to select each genome.",
        position: 'left'
      });
      mapIntro.push({
        element: document.querySelector('#unknown-location'),
        intro: "Check 'Unknown Locations Off' if you want to remove unknown locations from the list (these don't appear on the map).",
        position: 'left'
      });
      mapIntro.push({
        element: document.querySelector('#reset-map-view'),
        intro: "Clicking this will reset the map view.",
        position: 'bottom'
      });
      return mapIntro;
    };

    MapView.prototype._appendHeader = function(genomes) {
      var i, sortIcon, t, tName, table, tk, tv, v, values, _i, _j, _len, _len1, _ref, _ref1;
      table = '<thead><tr>';
      values = [];
      i = -1;
      if (this.sortField === 'displayname') {
        sortIcon = 'fa-sort-asc';
        if (!this.sortAsc) {
          sortIcon = 'fa-sort-desc';
        }
        values[++i] = {
          type: 'displayname',
          name: 'Genome',
          sortIcon: sortIcon
        };
      } else {
        values[++i] = {
          type: 'displayname',
          name: 'Genome',
          sortIcon: 'fa-sort'
        };
      }
      _ref = this.locationMetaFields;
      for (tk in _ref) {
        tv = _ref[tk];
        sortIcon = null;
        if (tk === this.sortField) {
          sortIcon = 'fa-sort-asc';
          if (!this.sortAsc) {
            sortIcon = 'fa-sort-desc';
          }
        } else {
          sortIcon = 'fa-sort';
        }
        values[++i] = {
          type: tk,
          name: tv,
          sortIcon: sortIcon
        };
      }
      _ref1 = genomes.mtypes;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        t = _ref1[_i];
        if (!genomes.visibleMeta[t]) {
          continue;
        }
        tName = genomes.metaMap[t];
        sortIcon = null;
        if (t === this.sortField) {
          sortIcon = 'fa-sort-asc';
          if (!this.sortAsc) {
            sortIcon = 'fa-sort-desc';
          }
        } else {
          sortIcon = 'fa-sort';
        }
        values[++i] = {
          type: t,
          name: tName,
          sortIcon: sortIcon
        };
      }
      for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
        v = values[_j];
        table += this._template('th', v);
      }
      table += '</tr></thead>';
      return table;
    };

    MapView.prototype._appendGenomes = function(visibleG, genomes, style, priv) {
      var checked, cls, d, g, gObj, k, location, name, row, table, thiscls, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      cls = this.cssClass();
      table = '';
      if (priv && visibleG.length) {
        table += this._template('spacer', null);
      }
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        row = '';
        gObj = genomes[g];
        thiscls = cls;
        if (gObj.cssClass != null) {
          thiscls = cls + ' ' + gObj.cssClass;
        }
        name = gObj.meta_array[0];
        if (this.locusData != null) {
          name += this.locusData.genomeString(g);
        }
        if (gObj.isolation_location != null) {
          location = true;
        }
        if (gObj.isolation_location == null) {
          location = false;
        }
        if (style === 'redirect') {
          row += this._template('td1_redirect', {
            g: g,
            name: name,
            shortName: gObj.meta_array[0],
            klass: thiscls
          });
          _ref = this.locationMetaFields;
          for (k in _ref) {
            v = _ref[k];
            if (location) {
              row += this._template('td1_location', {
                location: (_ref1 = this.mapController.allMarkers[g][k]) != null ? _ref1 : 'NA'
              });
            }
          }
          _ref2 = this.locationMetaFields;
          for (k in _ref2) {
            v = _ref2[k];
            if (!location) {
              row += this._template('td1_nolocation', {
                location: 'Unknown'
              });
            }
          }
          _ref3 = gObj.meta_array.slice(1);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            d = _ref3[_j];
            row += this._template('td', {
              data: d
            });
          }
          table += this._template('tr', {
            row: row
          });
        } else if (style === 'select') {
          checked = '';
          if (gObj.isSelected) {
            checked = 'checked';
          }
          row += this._template('td1_select', {
            g: g,
            name: name,
            klass: thiscls,
            checked: checked
          });
          _ref4 = this.locationMetaFields;
          for (k in _ref4) {
            v = _ref4[k];
            if (location) {
              row += this._template('td1_location', {
                location: (_ref5 = this.mapController.allMarkers[g][k]) != null ? _ref5 : 'NA'
              });
            }
          }
          _ref6 = this.locationMetaFields;
          for (k in _ref6) {
            v = _ref6[k];
            if (!location) {
              row += this._template('td1_nolocation', {
                location: 'Unknown'
              });
            }
          }
          _ref7 = gObj.meta_array.slice(1);
          for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
            d = _ref7[_k];
            row += this._template('td', {
              data: d
            });
          }
          table += this._template('tr', {
            row: row
          });
        } else {
          return false;
        }
      }
      return table;
    };

    MapView.prototype._template = function(tmpl, values) {
      var html;
      html = null;
      if (tmpl === 'tr') {
        html = "<tr>" + values.row + "</tr>";
      } else if (tmpl === 'th') {
        html = "<th><a class='genome-table-sort' href='#' data-genomesort='" + values.type + "'>" + values.name + " <i class='fa " + values.sortIcon + "'></i></a></th>";
      } else if (tmpl === 'td') {
        html = "<td>" + values.data + "</td>";
      } else if (tmpl === 'td1_redirect') {
        html = "<td class='" + values.klass + "'>" + values.name + " <a class='genome-table-link' href='#' data-genome='" + values.g + "' title='Genome " + values.shortName + " info'><i class='fa fa-search'></i></a></td>";
      } else if (tmpl === 'td1_select') {
        html = "<td class='" + values.klass + "'><div class='checkbox'> <label><input class='checkbox genome-table-checkbox' type='checkbox' value='" + values.g + "' " + values.checked + "/> " + values.name + "</label></div></td>";
      } else if (tmpl === 'td1_location') {
        html = "<td>" + values.location + "</td>";
      } else if (tmpl === 'td1_nolocation') {
        html = "<td class='no-loc'>" + values.location + "</td>";
      } else if (tmpl === 'spacer') {
        html = "<tr class='genome-table-spacer'><td>---- USER-SUBMITTED GENOMES ----</td></tr>";
      } else {
        throw new SuperphyError("Unknown template type " + tmpl + " in TableView method _template");
      }
      return html;
    };

    MapView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, _ref, _ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var _results;
        _results = [];
        for (k in fullMeta) {
          _results.push(genomes.metaMap[k]);
        }
        return _results;
      })();
      header.unshift("Genome name");
      header.push("Location");
      output += "#" + header.join("\t") + "\n";
      _ref = genomes.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        output += genomes.label(g, fullMeta, "\t") + "\t";
        output += g.isolation_location ? JSON.parse(g.isolation_location[0]).formatted_address : "N/A";
        output += "\n";
      }
      _ref1 = genomes.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        output += genomes.label(g, fullMeta, "\t") + "\t";
        output += g.isolation_location ? JSON.parse(g.isolation_location[0]).formatted_address : "N/A";
        output += "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    MapView.prototype.getCartographer = function(mapType, locationController) {
      var cartographTypes, cartographer, elem;
      elem = this.parentElem;
      mapType = mapType != null ? mapType : 'base';
      cartographTypes = {
        'base': (function(_this) {
          return function() {
            return new Cartographer(jQuery(elem), [locationController]);
          };
        })(this),
        'dot': (function(_this) {
          return function() {
            return new DotCartographer(jQuery(elem), [locationController]);
          };
        })(this),
        'satellite': (function(_this) {
          return function() {
            return new SatelliteCartographer(jQuery(elem), [locationController]);
          };
        })(this),
        'infoSatellite': (function(_this) {
          return function() {
            return new InfoSatelliteCartographer(jQuery(elem), [locationController, _this.mapArgs[1]]);
          };
        })(this),
        'geophy': (function(_this) {
          return function() {
            return new GeophyCartographer(jQuery(elem), [locationController, _this.mapArgs[1]]);
          };
        })(this)
      };
      cartographer = cartographTypes[mapType]();
      cartographer.cartograPhy();
      return cartographer;
    };

    MapView.prototype.getLocationController = function(mapType, viewNum) {
      var cartographTypes, controller;
      cartographTypes = {
        'base': (function(_this) {
          return function() {
            return null;
          };
        })(this),
        'dot': (function(_this) {
          return function() {
            return null;
          };
        })(this),
        'satellite': (function(_this) {
          return function() {
            return new LocationController(_this.genomeController, _this.parentElem, viewNum);
          };
        })(this),
        'infoSatellite': (function(_this) {
          return function() {
            return new LocationController(_this.genomeController, _this.parentElem, viewNum);
          };
        })(this),
        'geophy': (function(_this) {
          return function() {
            return new LocationController(_this.genomeController, _this.parentElem, viewNum);
          };
        })(this)
      };
      controller = cartographTypes[mapType]();
      return controller;
    };

    return MapView;

  })(TableView);


  /*
    CLASS SelectionMapView
   */

  SelectionMapView = (function(_super) {
    __extends(SelectionMapView, _super);

    function SelectionMapView(selParentElem, selStyle, selElNum, selGenomeController, selMapArgs) {
      this.selParentElem = selParentElem;
      this.selStyle = selStyle;
      this.selElNum = selElNum;
      this.selGenomeController = selGenomeController;
      this.selMapArgs = selMapArgs;
      SelectionMapView.__super__.constructor.call(this, this.selParentElem, this.selStyle, this.selElNum, this.selGenomeController, this.selMapArgs);
    }

    SelectionMapView.prototype.update = function(genomes) {
      var selectedEl, selectedElParent;
      SelectionMapView.__super__.update.apply(this, arguments);
      selectedEl = jQuery('.genome_map_item a[data-genome="' + this.mapController.selectedGenomeId + '"]');
      selectedElParent = selectedEl.parent();
      selectedElParent.prepend('<p style="padding:0px;margin:0px">Target genome: </p>');
      selectedElParent.css({
        "font-weight": "bold",
        "margin-bottom": "5px"
      });
      jQuery('.superphy-table table tbody').prepend('<tr>' + selectedElParent + '</tr>');
      selectedEl.remove();
      return true;
    };

    return SelectionMapView;

  })(MapView);


  /*
    CLASS Cartographer
  
    Handles map drawing and location searching
   */

  Cartographer = (function() {
    function Cartographer(cartographDiv, cartograhOpt) {
      this.cartographDiv = cartographDiv;
      this.cartograhOpt = cartograhOpt;
      this.pinPoint = __bind(this.pinPoint, this);
      this.defaultCenter = new google.maps.LatLng(-0.000, 0.000);
      this.mapOptions = {
        center: this.defaultCenter,
        zoom: 1,
        streetViewControl: false,
        mapTypeId: google.maps.MapTypeId.ROADMAP
      };
      this.mapBounds;
      this.map = new google.maps.Map(jQuery(this.cartographDiv).find('.map-canvas')[0], this.mapOptions);
      jQuery('.map-search-button').bind('click', {
        context: this
      }, this.pinPoint);
    }

    Cartographer.prototype.cartograPhy = function() {
      return true;
    };

    Cartographer.prototype.pinPoint = function(e) {
      var queryLocation;
      e.preventDefault();
      queryLocation = jQuery('.map-search-location').val();
      jQuery.ajax({
        type: "POST",
        url: '/strains/geocode',
        data: {
          'address': queryLocation
        }
      }).done((function(_this) {
        return function(data) {
          var bounds, northEast, results, southWest;
          results = JSON.parse(data);
          _this.map.setCenter(results.geometry.location);
          northEast = new google.maps.LatLng(results.geometry.bounds.northeast.lat, results.geometry.bounds.northeast.lng);
          southWest = new google.maps.LatLng(results.geometry.bounds.southwest.lat, results.geometry.bounds.southwest.lng);
          bounds = new google.maps.LatLngBounds(southWest, northEast);
          return _this.map.fitBounds(bounds);
        };
      })(this)).fail((function() {
        return alert("Could not get coordinates for: " + queryLocation + ". Please enter in another search query");
      }));
      return true;
    };

    Cartographer.prototype.resetMapView = function() {
      this.map.setZoom(1);
      this.map.setCenter(this.defaultCenter);
      return true;
    };

    return Cartographer;

  })();


  /*
    CLASS DotCartographer
  
    Handles map drawing and location searching
    Allows for pinpointing locations
   */

  DotCartographer = (function(_super) {
    __extends(DotCartographer, _super);

    function DotCartographer(dotCartographDiv, dotCartograhOpt) {
      this.dotCartographDiv = dotCartographDiv;
      this.dotCartograhOpt = dotCartograhOpt;
      this.resetMap = __bind(this.resetMap, this);
      this.pinPoint = __bind(this.pinPoint, this);
      DotCartographer.__super__.constructor.call(this, this.dotCartographDiv, this.dotCartograhOpt);
    }

    DotCartographer.prototype.latLng = null;

    DotCartographer.prototype.marker = null;

    DotCartographer.prototype.cartograPhy = function() {
      DotCartographer.__super__.cartograPhy.apply(this, arguments);
      google.maps.event.addListener(this.map, 'click', (function(_this) {
        return function(event) {
          return _this.plantFlag(event.latLng);
        };
      })(this));
      return true;
    };

    DotCartographer.prototype.pinPoint = function(e) {
      var queryLocation;
      e.preventDefault();
      queryLocation = jQuery('.map-search-location').val();
      jQuery.ajax({
        type: "POST",
        url: '/strains/geocode',
        data: {
          'address': queryLocation
        }
      }).done((function(_this) {
        return function(data) {
          var bounds, northEast, results, southWest;
          results = JSON.parse(data);
          _this.map.setCenter(results.geometry.location);
          northEast = new google.maps.LatLng(results.geometry.bounds.northeast.lat, results.geometry.bounds.northeast.lng);
          southWest = new google.maps.LatLng(results.geometry.bounds.southwest.lat, results.geometry.bounds.southwest.lng);
          bounds = new google.maps.LatLngBounds(southWest, northEast);
          _this.map.fitBounds(bounds);
          _this.latLng = results.geometry.location;
          return _this.plantFlag(_this.latLng, _this.map);
        };
      })(this)).fail((function() {
        return alert("Could not get coordinates for: " + queryLocation + ". Please enter in another search query");
      }));
      return true;
    };

    DotCartographer.prototype.plantFlag = function(location) {
      if (this.marker != null) {
        this.marker.setMap(null);
      }
      this.marker = new google.maps.Marker({
        position: location,
        map: this.map
      });
      this.marker.setTitle(this.marker.getPosition().toString());
      this.map.panTo(this.marker.getPosition());
      return true;
    };

    DotCartographer.prototype.resetMap = function() {
      var c, x;
      x = this.map.getZoom();
      c = this.map.getCenter();
      google.maps.event.trigger(this.map, 'resize');
      this.map.setZoom(x);
      this.map.setCenter(c);
      return true;
    };

    return DotCartographer;

  })(Cartographer);


  /*
    CLASS SatelliteCartographer
  
    Handles map drawing and location searching
    Displays multiple markers on map
    Handles marker clustering
    Displays list of genomes 
    Alters genome list when map viewport changes
   */

  SatelliteCartographer = (function(_super) {
    __extends(SatelliteCartographer, _super);

    function SatelliteCartographer(satelliteCartographDiv, satelliteCartograhOpt) {
      this.satelliteCartographDiv = satelliteCartographDiv;
      this.satelliteCartograhOpt = satelliteCartograhOpt;
      this.resetMarkers = __bind(this.resetMarkers, this);
      this.resetMap = __bind(this.resetMap, this);
      SatelliteCartographer.__super__.constructor.call(this, this.satelliteCartographDiv, this.satelliteCartograhOpt);
      this.locationController = this.satelliteCartograhOpt[0];
      this.allMarkers = jQuery.extend(this.locationController.pubMarkers, this.locationController.pvtMarkers);
      this.setMarkers(this.allMarkers);
    }

    SatelliteCartographer.prototype.cartograPhy = function() {
      SatelliteCartographer.__super__.cartograPhy.apply(this, arguments);
      google.maps.event.addListener(this.map, 'zoom_changed', (function(_this) {
        return function() {
          return _this.markerClusterer.clearMarkers();
        };
      })(this));
      google.maps.event.addListener(this.map, 'bounds_changed', (function(_this) {
        return function() {
          return _this.markerClusterer.clearMarkers();
        };
      })(this));
      google.maps.event.addListener(this.map, 'resize', (function(_this) {
        return function() {
          return _this.markerClusterer.clearMarkers();
        };
      })(this));
      google.maps.event.addListener(this.map, 'idle', (function(_this) {
        return function() {
          return viewController.views[_this.locationController.viewNum - 1].update(viewController.genomeController);
        };
      })(this));
      return true;
    };

    SatelliteCartographer.prototype.updateVisible = function() {
      var genomes, marker, marker_id, _ref, _ref1, _ref2;
      genomes = this.locationController.genomeController;
      this.visibleLocations = [];
      this.clusteredMarkers = [];
      _ref = this.allMarkers;
      for (marker_id in _ref) {
        marker = _ref[marker_id];
        if (this.map.getBounds() !== void 0 && this.map.getBounds().contains(marker.getPosition()) && ((_ref1 = marker.feature_id, __indexOf.call(genomes.pubVisible, _ref1) >= 0) || (_ref2 = marker.feature_id, __indexOf.call(genomes.pvtVisible, _ref2) >= 0))) {
          this.clusteredMarkers.push(marker);
          this.visibleLocations.push(marker.feature_id);
        }
      }
      return true;
    };

    SatelliteCartographer.prototype.setMarkers = function(markerList) {
      var circleIcon, marker, marker_id, mcOptions;
      circleIcon = {
        path: google.maps.SymbolPath.CIRCLE,
        fillColor: '#FF0000',
        fillOpacity: 0.8,
        scale: 5,
        strokeColor: '#FF0000',
        strokeWeight: 1
      };
      this.clusteredMarkers = [];
      for (marker_id in markerList) {
        marker = markerList[marker_id];
        marker.setMap(this.map);
        marker.setIcon(circleIcon);
        this.clusteredMarkers.push(marker);
      }
      mcOptions = {
        gridSize: 50,
        maxZoom: 15,
        batchSize: 100
      };
      this.markerClusterer = new MarkerClusterer(this.map, this.clusteredMarkers, mcOptions);
      return true;
    };

    SatelliteCartographer.prototype.resetMap = function() {
      var c, x;
      x = this.map.getZoom();
      c = this.map.getCenter();
      google.maps.event.trigger(this.map, 'resize');
      this.map.setZoom(x);
      this.map.setCenter(c);
      this.resetMarkers();
      return true;
    };

    SatelliteCartographer.prototype.resetMarkers = function() {
      this.updateVisible();
      this.markerClusterer.clearMarkers();
      this.markerClusterer.addMarkers(this.clusteredMarkers);
      return true;
    };

    return SatelliteCartographer;

  })(Cartographer);

  GeophyCartographer = (function(_super) {
    __extends(GeophyCartographer, _super);

    function GeophyCartographer(geophyCartographDiv, geophyCartograhOpt) {
      this.geophyCartographDiv = geophyCartographDiv;
      this.geophyCartograhOpt = geophyCartograhOpt;
      this.genomeGroupColor = this.geophyCartograhOpt[1];
      GeophyCartographer.__super__.constructor.call(this, this.geophyCartographDiv, this.geophyCartograhOpt);
    }

    GeophyCartographer.prototype.setMarkers = function(markerList) {
      var aqua, blue, brown, circleIcon, colors, green, grey, lime, marker, mcOptions, orange, pink, purple, red, _i, _len;
      blue = '#1f77b4';
      orange = '#ff7f0e';
      green = '#2ca02c';
      red = '#d62728';
      purple = '#9467bd';
      brown = '#8c564b';
      pink = '#e377c2';
      grey = '#7f7f7f';
      lime = '#bcbd22';
      aqua = '#17becf';
      colors = {
        'group1Color': blue,
        'group2Color': orange,
        'group3Color': green,
        'group4Color': red,
        'group5Color': purple,
        'group6Color': pink,
        'group7Color': brown,
        'group8Color': grey,
        'group9Color': aqua,
        'group10Color': lime
      };
      for (_i = 0, _len = markerList.length; _i < _len; _i++) {
        marker = markerList[_i];
        circleIcon = {
          path: google.maps.SymbolPath.CIRCLE,
          fillColor: colors["group" + this.genomeGroupColor[marker.feature_id] + "Color"],
          fillOpacity: 0.8,
          scale: 5,
          strokeColor: colors["group" + this.genomeGroupColor[marker.feature_id] + "Color"],
          strokeWeight: 1
        };
        marker.setMap(this.map);
        marker.setIcon(circleIcon);
      }
      mcOptions = {
        gridSize: 50,
        maxZoom: 15
      };
      this.markerClusterer = new MarkerClusterer(this.map, markerList, mcOptions);
      return true;
    };

    return GeophyCartographer;

  })(SatelliteCartographer);


  /*
    CLASS InfoSatelliteCartographer
  
    Handles map drawing and location searching
    Displays multiple markers on map
    Handles marker clustering
    Displays list of genomes 
    Alters genome list when map viewport changes
    Highlights selected genome on map from search query
   */

  InfoSatelliteCartographer = (function(_super) {
    __extends(InfoSatelliteCartographer, _super);

    function InfoSatelliteCartographer(infoSatelliteCartographDiv, infoSatelliteCartograhOpt) {
      var _ref;
      this.infoSatelliteCartographDiv = infoSatelliteCartographDiv;
      this.infoSatelliteCartograhOpt = infoSatelliteCartograhOpt;
      InfoSatelliteCartographer.__super__.constructor.call(this, this.infoSatelliteCartographDiv, this.infoSatelliteCartograhOpt);
      this.selectedGenomeId = this.infoSatelliteCartograhOpt[1];
      this.selectedGenome = (_ref = window.viewController.genomeController.private_genomes[this.selectedGenomeId]) != null ? _ref : window.viewController.genomeController.public_genomes[this.selectedGenomeId];
      this.selectedGenomeLocation = this.locationController._parseLocation(this.selectedGenome);
    }

    InfoSatelliteCartographer.prototype.cartograPhy = function() {
      InfoSatelliteCartographer.__super__.cartograPhy.apply(this, arguments);
      this.showSelectedGenome(this.selectedGenomeLocation, this.map);
      return this.showLegend();
    };

    InfoSatelliteCartographer.prototype.showSelectedGenome = function(location, map) {
      var markerLatLng, maxZndex, overlay, zInd;
      if (location == null) {
        throw new SuperphyError('Location cannot be determined or location is undefined (not specified)!');
        return 0;
      }
      maxZndex = google.maps.Marker.MAX_ZINDEX;
      zInd = maxZndex + 1;
      markerLatLng = new google.maps.LatLng(location.centerLatLng);
      return overlay = new CartographerOverlay(map, location.centerLatLng, location.locationFormattedAddress);
    };

    InfoSatelliteCartographer.prototype.showLegend = function() {
      return jQuery('.map-search-table').append('<tr> <td> <div class="map-legend"> <div class="col-md-3"> <div class="row"> <div class="col-xs-3"> <img class="map-legend-marker-img" src="/App/Pictures/marker_icon_green.png"> </div> <div class="col-xs-9"> <p class="legendlabel1">Target genome</p> </div> </div> </div> </div> </td> </tr>');
    };

    return InfoSatelliteCartographer;

  })(SatelliteCartographer);

  CartographerOverlay = (function() {
    function CartographerOverlay(map, latLng, title) {
      this.map = map;
      this.latLng = latLng;
      this.title = title;
      this.setMap(this.map);
      this.div = null;
    }

    CartographerOverlay.prototype = new google.maps.OverlayView();

    CartographerOverlay.prototype.onAdd = function() {
      var div, panes, selectedMarker, svg;
      div = document.createElement('div');
      div.id = "selectedGenome";
      div.style.borderStyle = 'none';
      div.style.borderWidth = '0px';
      div.style.position = 'absolute';
      div.style.width = '15px';
      div.style.height = '15px';
      div.style.cursor = 'pointer';
      svg = d3.select(div).append('svg').attr('height', '15px').attr('width', '15px');
      selectedMarker = svg.append("g").attr('transform', 'translate(0,0)');
      selectedMarker.append("circle").attr('cx', 7.5).attr('cy', 7.5).attr('r', '5px').style({
        'fill': '#ffc966',
        'stroke': '#ffa500',
        'stroke-width': '3px',
        'fill-opacity': '0.5'
      });
      selectedMarker.append("title").text(this.title);
      this.div = div;
      panes = this.getPanes();
      return panes.floatPane.appendChild(div);
    };

    CartographerOverlay.prototype.onRemove = function() {
      this.div.parentNode.removeChild(this.div);
      return this.div = null;
    };

    CartographerOverlay.prototype.draw = function() {
      var div, location, overlayProjection;
      overlayProjection = this.getProjection();
      location = overlayProjection.fromLatLngToDivPixel(this.latLng);
      div = this.div;
      div.style.left = (location.x - 7.5) + 'px';
      return div.style.top = (location.y - 7.5) + 'px';
    };

    return CartographerOverlay;

  })();

  LocationController = (function() {
    function LocationController(genomeController, parentElem, viewNum) {
      this.genomeController = genomeController;
      this.parentElem = parentElem;
      this.viewNum = viewNum;
      this._populateLocations(this.genomeController);
    }

    LocationController.prototype.pubLocations = null;

    LocationController.prototype.pvtLocations = null;

    LocationController.prototype.pubNoLocations = null;

    LocationController.prototype.pvtNoLocations = null;

    LocationController.prototype.pubMarkers = null;

    LocationController.prototype.pvtMarkers = null;

    LocationController.prototype._populateLocations = function(genomes) {
      var private_genome, pubGenomeId, pubMarker, pubMarkerObj, public_genome, pvtGenomeId, pvtMarker, pvtMarkerObj, _ref, _ref1;
      this.pubLocations = [];
      this.pvtLocations = [];
      this.pubNoLocations = [];
      this.pvtNoLocations = [];
      this.pubMarkers = {};
      this.pvtMarkers = {};
      _ref = genomes.public_genomes;
      for (pubGenomeId in _ref) {
        public_genome = _ref[pubGenomeId];
        if (!((public_genome.isolation_location != null) && public_genome.isolation_location !== "")) {
          this.pubNoLocations.push(pubGenomeId);
        } else {
          pubMarkerObj = this._parseLocation(public_genome);
          this.pubLocations.push(pubGenomeId);
          public_genome.isolation_country = pubMarkerObj['locationCountry'];
          public_genome.isolation_province_state = pubMarkerObj['locationProvinceState'];
          public_genome.isolation_city = pubMarkerObj['locationCity'];
          pubMarker = new google.maps.Marker({
            position: pubMarkerObj['centerLatLng'],
            title: public_genome.uniquename,
            feature_id: pubGenomeId,
            uniquename: public_genome.uniquename,
            location: pubMarkerObj['locationFormattedAddress'],
            isolation_country: pubMarkerObj['locationCountry'],
            isolation_province_state: pubMarkerObj['locationProvinceState'],
            isolation_city: pubMarkerObj['locationCity'],
            privacy: 'public'
          });
          this.pubMarkers[pubGenomeId] = pubMarker;
        }
      }
      _ref1 = genomes.private_genomes;
      for (pvtGenomeId in _ref1) {
        private_genome = _ref1[pvtGenomeId];
        if (!((private_genome.isolation_location != null) && private_genome.isolation_location !== "")) {
          this.pvtNoLocations.push(pvtGenomeId);
        } else {
          pvtMarkerObj = this._parseLocation(private_genome);
          this.pvtLocations.push(pvtGenomeId);
          private_genome.isolation_country = pvtMarkerObj['locationCountry'];
          private_genome.isolation_province_state = pvtMarkerObj['locationProvinceState'];
          private_genome.isolation_city = pvtMarkerObj['locationCity'];
          pvtMarker = new google.maps.Marker({
            position: pvtMarkerObj['centerLatLng'],
            title: private_genome.uniquename,
            feature_id: pvtGenomeId,
            uniquename: private_genome.uniquename,
            location: pvtMarkerObj['locationFormattedAddress'],
            isolation_country: pvtMarkerObj['locationCountry'],
            isolation_province_state: pvtMarkerObj['locationProvinceState'],
            isolation_city: pvtMarkerObj['locationCity'],
            privacy: 'private'
          });
          this.pvtMarkers[pvtGenomeId] = pvtMarker;
        }
      }
      return true;
    };

    LocationController.prototype._parseLocation = function(genome) {
      var add_cmp, centerLatLng, genomeLocation, locationAddressComponents, locationCenter, locationCenterLat, locationCenterLng, locationCoordinates, locationFormattedAddress, locationViewPortNE, locationViewPortNELat, locationViewPortNELng, locationViewPortSW, locationViewPortSWLat, locationViewPortSWLng, markerBounds, markerObj, neLatLng, swLatLng, _i, _len, _ref, _ref1;
      genomeLocation = JSON.parse(genome.isolation_location[0]);
      locationFormattedAddress = genomeLocation.formatted_address;
      locationCoordinates = genomeLocation.geometry;
      locationCenter = locationCoordinates.location;
      locationCenterLat = locationCenter.lat;
      locationCenterLng = locationCenter.lng;
      locationViewPortSW = locationCoordinates.bounds.southwest;
      locationViewPortSWLat = locationViewPortSW.lat;
      locationViewPortSWLng = locationViewPortSW.lng;
      locationViewPortNE = locationCoordinates.bounds.northeast;
      locationViewPortNELat = locationViewPortNE.lat;
      locationViewPortNELng = locationViewPortNE.lng;
      locationAddressComponents = {
        'country': void 0,
        'administrative_area_level_1': void 0,
        'locality': void 0
      };
      _ref = genomeLocation.address_components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        add_cmp = _ref[_i];
        if (_ref1 = add_cmp.types[0], __indexOf.call(Object.keys(locationAddressComponents), _ref1) >= 0) {
          locationAddressComponents[add_cmp.types[0]] = add_cmp.long_name;
        }
      }
      centerLatLng = new google.maps.LatLng(locationCenterLat, locationCenterLng);
      swLatLng = new google.maps.LatLng(locationViewPortSWLat, locationViewPortSWLng);
      neLatLng = new google.maps.LatLng(locationViewPortNELat, locationViewPortNELng);
      markerBounds = new google.maps.LatLngBounds(swLatLng, neLatLng);
      markerObj = {};
      markerObj['locationFormattedAddress'] = locationFormattedAddress;
      markerObj['locationCountry'] = locationAddressComponents['country'];
      markerObj['locationProvinceState'] = locationAddressComponents['administrative_area_level_1'];
      markerObj['locationCity'] = locationAddressComponents['locality'];
      markerObj['centerLatLng'] = centerLatLng;
      markerObj['markerBounds'] = markerBounds;
      return markerObj;
    };

    return LocationController;

  })();

  GeoPhy = (function() {
    function GeoPhy(publicGenomes, privateGenomes, viewController, userGroups, treeDiv, mapDiv) {
      this.publicGenomes = publicGenomes;
      this.privateGenomes = privateGenomes;
      this.viewController = viewController;
      this.userGroups = userGroups;
      this.treeDiv = treeDiv;
      this.mapDiv = mapDiv;
    }

    GeoPhy.prototype.publicSubsetGenomes = {};

    GeoPhy.prototype.privateSubsetGenomes = {};

    GeoPhy.prototype.genomeController = null;

    GeoPhy.prototype.init = function(boolShowall) {
      if ((this.userGroups == null) || (this.userGroups != null) && boolShowall) {
        this._showall();
      } else if ((this.userGroups != null) && !boolShowall) {
        this._filter();
      }
      this.viewController.sideBar($('#search-utilities'));
      this.viewController.createView('tree', this.treeDiv, tree);
      this._createSubmitForm();
      return true;
    };

    GeoPhy.prototype._getPublicSubset = function(public_genomes, selected_groups) {
      var public_subset_genomes;
      public_subset_genomes = {};
      jQuery.each(selected_groups, function(gp_num, gp) {
        return jQuery.each(gp, function(i, v) {
          if (public_genomes[v]) {
            return public_subset_genomes[v] = public_genomes[v];
          }
        });
      });
      return public_subset_genomes;
    };

    GeoPhy.prototype._getPrivateSubset = function(private_genomes, selected_groups) {
      var private_subset_genomes;
      private_subset_genomes = {};
      jQuery.each(selected_groups, function(gp_num, gp) {
        return jQuery.each(gp, function(i, v) {
          if (private_genomes[v]) {
            return private_subset_genomes[v] = private_genomes[v];
          }
        });
      });
      return private_subset_genomes;
    };

    GeoPhy.prototype._appendLegend = function(divEl, groups) {
      var aqua, blue, brown, buttonEl, clearFormEl, colors, div, gList, gNum, green, grey, hiddenFormEl, legendEl, lime, markerLegend, orange, panelEl, pink, purple, red, rowEl, submitEl, svg;
      blue = '#1f77b4';
      orange = '#ff7f0e';
      green = '#2ca02c';
      red = '#d62728';
      purple = '#9467bd';
      brown = '#8c564b';
      pink = '#e377c2';
      grey = '#7f7f7f';
      lime = '#bcbd22';
      aqua = '#17becf';
      colors = {
        'group1Color': blue,
        'group2Color': orange,
        'group3Color': green,
        'group4Color': red,
        'group5Color': purple,
        'group6Color': pink,
        'group7Color': brown,
        'group8Color': grey,
        'group9Color': aqua,
        'group10Color': lime
      };
      legendEl = jQuery('<div class="col-md-12 panel panel-default"></div>');
      panelEl = jQuery('<div class="panel-body"></div>').appendTo(legendEl);
      rowEl = jQuery('<div class="row"></div>').appendTo(panelEl);
      divEl.prepend(legendEl);
      for (gNum in groups) {
        gList = groups[gNum];
        console.log(gNum);
        div = document.createElement('div');
        div.className = "col-md-1";
        svg = d3.select(div).append('svg').attr('height', '20px').attr('width', '100px');
        markerLegend = svg.append("g").attr('transform', 'translate(0,0)');
        markerLegend.append("circle").attr('cx', 10).attr('cy', 10).attr('r', '5px').style({
          'fill': colors["group" + gNum + "Color"],
          'fill-opacity': '1.0'
        });
        markerLegend.append("text").attr("class", "legendlabel2").attr("dx", 20).attr("dy", 15).attr("text-anchor", "start").text("Group " + gNum);
        rowEl.append(div);
      }
      submitEl = jQuery("<div class='compare-genome-groups row'></div>").appendTo(panelEl);
      divEl = jQuery("<div class='col-md-12'></div>").appendTo(submitEl);
      clearFormEl = jQuery("<button class='btn btn-danger' onclick='location.reload()'><span class='fa fa-times'></span> Reset Form</button>").appendTo(divEl);
      buttonEl = jQuery("<button type='submit' class='btn btn-primary' value='Submit' form='groups-compare-form'><span class='fa fa-check'></span> Show All Groups</button>").appendTo(divEl);
      hiddenFormEl = jQuery('#groups-compare-form');
      buttonEl.click((function(_this) {
        return function(e) {
          var genome, groupGenomes, i, _i, _j, _len, _ref;
          e.preventDefault();
          jQuery("<input type='hidden' name='show-all' value='1'>").appendTo(hiddenFormEl);
          for (i = _i = 1, _ref = _this.viewController.groups.length; _i <= _ref; i = _i += 1) {
            groupGenomes = jQuery("#genome_group" + i + " .genome_group_item");
            for (_j = 0, _len = groupGenomes.length; _j < _len; _j++) {
              genome = groupGenomes[_j];
              jQuery("<input type='hidden' name='group" + i + "-genome' value='" + (jQuery(genome).find('a').data('genome')) + "'>").appendTo(hiddenFormEl);
            }
          }
          jQuery("<input type='hidden' name='num-groups' value='" + _this.viewController.groups.length + "'>").appendTo(hiddenFormEl);
          return hiddenFormEl.submit();
        };
      })(this));
      return true;
    };

    GeoPhy.prototype._showall = function() {
      var gpColors;
      this._setViewController(this.publicGenomes, this.privateGenomes);
      if (this.userGroups != null) {
        gpColors = this._prepareGroups();
      }
      this.viewController.createView('map', this.mapDiv, ['satellite']);
      return true;
    };

    GeoPhy.prototype._filter = function() {
      var gpColors;
      this.publicSubsetGenomes = this._getPublicSubset(this.publicGenomes, this.userGroups);
      this.privateSubsetGenomes = this._getPrivateSubset(this.privateGenomes, this.userGroups);
      this._setViewController(this.publicSubsetGenomes, this.privateSubsetGenomes);
      jQuery('#groups-compare').hide();
      gpColors = this._prepareGroups();
      this.viewController.createView('map', this.mapDiv, ['geophy'], gpColors);
      this._appendLegend(jQuery('#groups-geophy'), this.userGroups);
      return true;
    };

    GeoPhy.prototype._setViewController = function(pubList, pvtList) {
      var addMore, filter, submit;
      this.viewController.init(pubList, pvtList, 'multi_select', '/groups/geophy');
      addMore = true;
      submit = true;
      filter = true;
      return true;
    };

    GeoPhy.prototype._createSubmitForm = function() {
      var elem, form, parentTarget, resetButtonEl, submitButtonEl, submitEl, wrapper;
      elem = jQuery('#geophy-control');
      parentTarget = 'geophy-control-panel-body';
      wrapper = jQuery('<div class="panel panel-default" id="geophy-control-panel"></div>');
      elem.append(wrapper);
      form = jQuery("<div class='panel-body' id='" + parentTarget + "'></div>");
      wrapper.append(form);
      submitEl = jQuery('<div class="row"></div>');
      submitButtonEl = jQuery('<div class="col-md-2 col-md-offset-4"><button type="submit" value="Submit" form="geophy-form" class="btn btn-success"><span class="fa fa-exchange"></span> Highlight Genomes</button></div>').appendTo(submitEl);
      resetButtonEl = jQuery('<div class="col-md-2"><button type="button" form="geophy-form" class="btn btn-danger"><span class="fa fa-times"></span> Reset Views</button></div>').appendTo(submitEl);
      submitButtonEl.click((function(_this) {
        return function(e) {
          e.preventDefault();
          console.log("Button Clicked");
          _this.viewController.filterViews('selection');
          return true;
        };
      })(this));
      resetButtonEl.click((function(_this) {
        return function(e) {
          var g, _i, _j, _len, _len1, _ref, _ref1;
          e.preventDefault();
          _this.viewController.resetFilter();
          _ref = _this.viewController.genomeController.pubVisible;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            g = _ref[_i];
            _this.viewController.select(g, false);
          }
          _ref1 = _this.viewController.genomeController.pvtVisible;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            g = _ref1[_j];
            _this.viewController.select(g, false);
          }
          jQuery('#reset-map-view').click();
          return true;
        };
      })(this));
      form.append(submitEl);
      return true;
    };

    GeoPhy.prototype._prepareGroups = function() {
      var gId, gList, gNum, genomeGroupColor, userMaxGroupNum, _i, _len, _ref;
      genomeGroupColor = {};
      userMaxGroupNum = Math.max.apply(Math, Object.keys(this.userGroups));
      while (userMaxGroupNum > this.viewController.groups.length) {
        this.viewController.addGroupFormRow($("#group-form-block"));
      }
      _ref = this.userGroups;
      for (gNum in _ref) {
        gList = _ref[gNum];
        for (_i = 0, _len = gList.length; _i < _len; _i++) {
          gId = gList[_i];
          this.viewController.select(gId, true);
          genomeGroupColor[gId] = gNum;
        }
        this.viewController.addToGroup(parseInt(gNum));
      }
      return genomeGroupColor;
    };

    if (!root.GeoPhy) {
      root.GeoPhy = GeoPhy;
    }

    return GeoPhy;

  })();

}).call(this);
