#!/usr/bin/env perl

=pod

=head1 NAME

Modules::Upload

=head1 DESCRIPTION

Genome Submission module

=head1 COPYRIGHT

This work is released under the GNU General Public License v3  http://www.gnu.org/licenses/gpl.htm

=head1 AVAILABILITY

The most recent version of the code may be found at:

=head1 AUTHORS

Akiff Manji (akiff.manji@gmail.com)
Matt Whiteside (mawhites@phac-aspc.gov.ca)

=head1 Methods

=cut

package Modules::Upload;

use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/../";
use IO::File;
use IO::Dir;
use Bio::SeqIO;
use parent 'Modules::App_Super';
use Log::Log4perl qw/get_logger/;
use Carp qw/croak carp/;
use CGI::Application::Plugin::ValidateRM;
use CGI::Application::Plugin::AutoRunmode;
use Data::FormValidator::Constraints qw(FV_length_between);
use File::Temp;
use File::Copy qw/copy/;
use Data::Dumper;
use DateTime qw(ymd);
use JSON;
use Sequences::GenodoDateTime;
use Modules::Footprint;
use HTML::FillInForm;
use Modules::LocationManager;
use Role::Tiny::With;
with 'Roles::Hosts';

my $dbic;

my @analysis_steps = ('Queued', 'Processing', 'Completed', 'Completed');
my %tracker_step_values = (
	pending => 1,
	processing => 2,
	completed => 3,
	notified => 4
);

=head2 setup

=cut

sub setup {
    my $self=shift;
     
    $self->authen->protected_runmodes(
		qw/submit_genome upload_genome status list delete_genome edit_genome update_genome/
	);
    
    get_logger->debug("Initializing Modules::Upload");
}

=head2 submit_genome

Display upload genome form page to create new genome upload

=cut

sub submit_genome : Runmode {
    my $self = shift;
    my $errs = shift; # Errors generated by form validation

  
    croak 'Cannot submit a genome unless logged in.' unless $self->authen->is_authenticated;
    
    my $t = $self->load_tmpl ( 'genome_uploader.tmpl' , die_on_bad_params=>0 );
    
    # Populate the drop downs with valid options
    # Hosts
    my @hosts = map { { host_name => $self->hostList->{$_}, host_value => $_ } } keys %{$self->hostList};
    $t->param(hosts => \@hosts);
    
    my $json = JSON->new;
    $t->param(json_categories => $json->encode($self->hostCategories));
    $t->param(json_sources => $json->encode($self->sourceList));
  
    # Set defaults in radio buttons
    $t->param(g_public => 1); # Check the public radio button
    $t->param(g_unkn_finished => 1); # Check unknown radio button
    $t->param(g_dna_mtype => 1); # Check dna radio button
    
    $t->param(new_genome => 1); # Display new genome version of form
    $t->param(set_privacy => 1); # All new genomes must have privacy set
    
    foreach my $category (@{$self->categoryList}) {
    	my @syndromes = map { { syndrome_name => $self->syndromeList->{$category}{$_}, syndrome_value => $_ } } keys %{$self->syndromeList->{$category}};
    	my $param = "$category\_syndromes";
    	$t->param($param => \@syndromes);
    }
    
    $t->param(rm    => '/superphy/upload/upload_genome');
	$t->param(title => 'Upload a genome');
	
	# Error detected, fill in old values and error messages
	if($errs) {
		$t->param($errs);    # created by rm upload_genome
		
		# The HTML::FillInForm only partially completes the form
		# Need to populate the javascript-generated fields
		$t->param(selected_host => $self->query->param('g_host'));
		$t->param(selected_source => $self->query->param('g_source'));
		$t->param(selected_release_date => $self->query->param('g_release_date'));
		my @syndromes = $self->query->param('g_syndrome');
		my @syndrome_list = map { { syndrome_value => $_ } } @syndromes;
		$t->param(selected_syndromes => \@syndrome_list);
		$t->param(selected_location => $self->query->param('geocode_id'));
	}

	#my $t = $self->load_tmpl ( 'unavailable.tmpl' , die_on_bad_params=>0 );
	#$t->param(title => 'Upload a genome');
	
	return $t->output;
}

=head2 upload_genome

Validate form and upload genome to DB

=cut

sub upload_genome : Runmode {
    my $self = shift;

    get_logger->debug('UPLOADING GENOME');
    
    croak 'Cannot upload a genome unless logged in.' unless $self->authen->is_authenticated;

    $dbic = $self->dbixSchema;
    
    # Validate form and fasta file
	my $results = $self->check_rm( 'submit_genome', $self->_dfv_submit_genome_rules )
		|| return $self->check_rm_error_page;

	# Everything is good to go, initiate a new job
	my $user = $self->dbixSchema->resultset('Login')->find( { username => $self->authen->username } );
	
	# Create job record in tracking table
	# tracking_id is used as unique identifier for all files related to this job
	my $tracking_row = $self->dbixSchema->resultset('Tracker')->create({ login_id => $user->login_id, step => 0});
	my $tracking_id = $tracking_row->tracker_id;
	
	# Prepare inputs for loading script
	my $q = $self->query;
	
	# Fasta file
	# Copy to persistent tmp file
	# The CGI upload tmp file is auto-deleted
	# Save parameters to tmp file
	my $file_path = $self->config_param('dir.seq');
	croak "Missing config parameter for sequence directory." unless $file_path;
     
	my $tmpFastaFile = $file_path . "genodo-fasta-$tracking_id.ffn";
	
	# Copy upload tmp file to our tmp file
	my $filename = $q->param('g_file');
	my $uploadFile = $q->tmpFileName($filename);
	copy($uploadFile, $tmpFastaFile) or croak "Copy from $uploadFile to $tmpFastaFile failed: $!";
	
	# User info
	my %upload_params = (
		category => $results->valid('g_privacy'),
		login_id => $user->login_id		
	);
	if($results->valid('g_release_date')) {
		$upload_params{'release_date'} = $results->valid('g_release_date')->ymd;
	}
	if($results->valid('g_group')) {
		$upload_params{'tag'} = $results->valid('g_group');
	}
	
	# Genome properties
	# required
	my $host;
	if($results->valid('g_host') eq 'other') {
		$host = $results->valid('g_host_genus') . ' ' . $results->valid('g_host_species') . ' ('.
			$results->valid('g_host_name').')';
	} else {
		$host = $self->hostList->{$results->valid('g_host')};
		croak "Unrecognized host ".$results->valid('g_host') unless $host;
	}
	
	my $host_category = $self->hostCategories->{$results->valid('g_host')};
	
	my $source;
	if($results->valid('g_source') eq 'other') {
		$source = $results->valid('g_other_source');
	} else {
		$source = $self->sourceList->{ $host_category }->{ $results->valid('g_source') };
		croak "Unrecognized source ".$results->valid('g_source')." for provided host ".$results->valid('g_host') unless $source;
	}
	
	my %genome_params = (
		uniquename => $results->valid('g_name'),
		serotype => $results->valid('g_serotype'),
		strain => $results->valid('g_strain'),
		isolation_host => $host,
		isolation_source => $source,
		isolation_date => $results->valid('g_date')->ymd,
		mol_type => $results->valid('g_mol_type')
	);
	
	# Save under proper hash term recognized by loading pipeline
	if($results->valid('geocode_id')) {
		$genome_params{'isolation_location'} = $results->valid('geocode_id');
	}
	
	if($results->valid('g_syndrome')) {
		my @syndrome_keys = $results->valid('g_syndrome');
		my @syndromes;
		foreach my $key (@syndrome_keys) {
			my $syndrome = $self->syndromeList->{ $host_category }->{ $key };
			croak "Unrecognized disease $key for provided host ".$results->valid('g_host') unless $syndrome;
			push @syndromes, $syndrome;
		}
		$genome_params{'syndrome'} = \@syndromes;
	} elsif($results->valid('g_asymptomatic')) {
		$genome_params{'syndrome'} = ['Asymptomatic'];
	}
	
	if($results->valid('g_other_syndrome_cb')) {
		$genome_params{'syndrome'} ||= [];
		push @{$genome_params{'syndrome'}}, $results->valid('g_other_syndrome');
	}
	
	if($results->valid('g_age')) {
		# Store everthing in day units
		my $days = Sequences::GenodoDateTime::ageIn($results->valid('g_age'), $results->valid('g_age_unit'));
		$genome_params{isolation_age} = $days;
	}
	
	if($results->valid('g_pmid')) {
		my @pmids = split(/,/, $results->valid('g_pmid'));
		my @final_pmids;
		foreach my $item(@pmids){
			push @final_pmids, ($item =~ s/(^\s*)|(\s*$)//);
		}
		$genome_params{pmid} = \@final_pmids;
	}
	
	if($results->valid('g_description')) {
		$genome_params{'description'} = $results->valid('g_description');
	}
	
	if($results->valid('g_comments')) {
		$genome_params{'comment'} = $results->valid('g_comments');
	}
	
	if($results->valid('g_keywords')) {
		$genome_params{'keywords'} = $results->valid('g_keywords');
	}
	
	if($results->valid('g_owner')) {
		$genome_params{'owner'} = $results->valid('g_owner');
	}

	if($results->valid('g_synonym')) {
		$genome_params{'synonym'} = $results->valid('g_synonym');
	}
    
    if($results->valid('g_finished') && $results->valid('g_finished') ne 'unknown') {
		$genome_params{'finished'} = $results->valid('g_finished');
	}
	
	if($results->valid('g_dbxref_acc')) {
		my $primary_dbxref = {
			db  => $results->valid('g_dbxref_db'),
			acc => $results->valid('g_dbxref_acc'),
		};
		$primary_dbxref->{ver} = $results->valid('g_dbxref_ver') if $results->valid('g_dbxref_ver');
		$genome_params{'primary_dbxref'} = $primary_dbxref;
	}
	
	# Database connection params
	my $configFile = $self->config_file;
	
	# Save parameters to tmp file
	my $tmpfile = $file_path . "genodo-form-params-$tracking_id.txt";
	# chmod 0644, $tmpfile
	
	open my $outFH, '>', $tmpfile or die "Could not open $tmpfile\n";
	$outFH->print(Data::Dumper->Dump([\%genome_params, \%upload_params], ['contig_collection_properties', 'upload_parameters']));
	$outFH->close();

	# Save arguments to main config file
	my $optFile = $file_path . "genodo-options-$tracking_id.cfg";
	my $opt = new Config::Simple(syntax => 'ini') or croak "Cannot create config object " . Config::Simple->error();
	
	# Save all options in config file
	$opt->param(
		-block => 'load', 
		-values => {
			'fastafile'    => $tmpFastaFile,
			'propfile'     => $tmpfile,
			'configfile'   => $configFile,
			#'addon_args'   => '--save_tmpfiles --debug'
		}
	);
	$opt->param(
		-block => 'main',
		-values => {
			'tracking_id'  => $tracking_id
		}
	);
	$opt->write($optFile);

	croak "Error: genome checksum parameter missing (g_footprint). Valid g_footprint parameter gets set in call to _valid_fasta_file() method."
		unless $results->valid('g_footprint');
	

	$tracking_row->feature_name($results->valid('g_name'));
	$tracking_row->access_category($upload_params{category});
	$tracking_row->footprint($results->valid('g_footprint'));
	$tracking_row->step(1); # Step 1 complete
	$tracking_row->update;
	
	# Send user to status page
	$self->redirect( "/superphy/upload/status?tracking_id=$tracking_id" );
}

=head2 status

Display current progress of genome analysis

=cut

sub status : Runmode {
    my $self = shift;
    
    croak 'Cannot submit a genome unless logged in.' unless $self->authen->is_authenticated;
    
    my $tracking_id = $self->query->param('tracking_id');
    croak 'Missing query parameter: tracking_id' unless $tracking_id;
    my $tracker_row = $self->dbixSchema->resultset('Tracker')->find($tracking_id);
    croak "No record matching tracking ID $tracking_id was found." unless defined($tracker_row);
    
    # Check if any funny business is going on
    my $user = $self->dbixSchema->resultset('Login')->find( { username => $self->authen->username } );
    croak 'You are not authorized to view this genome record.' unless $tracker_row->login_id == $user->login_id;
    
    
    my $tot = scalar(@analysis_steps)-1; # Subtract the email notification from step, users dont need that info
    my $step_value = $tracker_row->step;
    $step_value = $tot if $step_value > $tot;
    my $i = $step_value-1;
    
    my $t = $self->load_tmpl ( 'genome_status.tmpl' , die_on_bad_params=>0 );
    $t->param(tracking_id => $tracking_id);
    $t->param(feature_name => $tracker_row->feature_name);
    $t->param(start_date => _format_time($tracker_row->start_date));
    $t->param(analysis_step => $analysis_steps[$i]);
    $t->param(current_step => $step_value);
    $t->param(total_steps => $tot);
    $t->param(failed => $tracker_row->failed);
    
    # Job completed
    if($tracker_row->end_date) {
    	$t->param(end_date => _format_time($tracker_row->end_date));
    	
    	# retrieve contig_collection for this record
    	my $feature_rs = $self->dbixSchema->resultset('PrivateFeature')->search(
			{
				upload_id => $tracker_row->upload_id,
				'type.name'      => 'contig_collection'
			},
	    	{
	    		columns => [qw/feature_id/],
	    		join => [
	    			'type'
	    		]
	    	}
	    );
    	
    	my $feature_row = $feature_rs->first();
    	
    	if($feature_row) {
    		$t->param(strain_link => '/superphy/strains/info?genome=private_'.$feature_row->feature_id);
    		$t->param(not_found => 0);
    	} else {
    		$t->param(strain_link => 0);
    		$t->param(not_found => 1);
    	}
    	
    } else {
    	$t->param(end_date => 0);
    	$t->param(strain_link => 0);
    	$t->param(not_found => 0)
    }
    
    $t->param(rm    => $self->home_page);
	$t->param(title => 'Status of Genome Analysis');
	
	return $t->output;
}

=head2 list

Display all uploaded genomes for a user

=cut

sub list : Runmode {
    my $self = shift;
  
    croak 'Cannot list uploaded genomes unless logged in.' unless $self->authen->is_authenticated;
    
    my $t = $self->load_tmpl ( 'genome_list.tmpl' , die_on_bad_params=>0 );
    
    # Retrieve uploaded entries from database for this user
	# In this step, get all entries
	# and later identify those genome for which the user has 'modify' permissions
	my $upload_rs = $self->dbixSchema->resultset('Upload')->search(
		{
			'login.username'            => $self->authen->username,
			'type.name'                 => 'contig_collection',
		},
		{
			join => [
				{ 'permissions'      => 'login' },
				{ 'private_features' => 'type' },
			],
			columns   => [qw/me.upload_id me.tag me.upload_date/],
			'+select' => [qw/private_features.uniquename private_features.feature_id permissions.can_modify permissions.can_share/],
			'+as'     => [qw/name feature_id can_modify can_share/],
		}
	);

	# Group upload entries by tag
	# Indicate which the user can modify
	my %form_hash;
	while ( my $upload_row = $upload_rs->next ) {

		my $group_nm = ( $upload_row->tag eq '' ) ? 'Uncategorized' : $upload_row->tag;
		$form_hash{$group_nm} = [] unless defined $form_hash{$group_nm};
		push @{ $form_hash{$group_nm} },
			{
				name => $upload_row->get_column('name'),
				date => _strip_time( $upload_row->upload_date ),
				#uid  => $upload_row->upload_id,
				#feature_id => $upload_row->get_column('feature_id'),
				can_modify => $upload_row->get_column('can_modify'),
				view_rm => '/superphy/strains/info?genome=private_' . $upload_row->get_column('feature_id'),
				edit_rm => '/superphy/upload/edit_genome?upload_id=' . $upload_row->upload_id,
			};
	}

	# Convert to loops for template
	my @form_list;
	foreach my $group ( keys %form_hash ) {
		push @form_list,
		  { group_name => $group, group_rows => $form_hash{$group} };
	}
	$t->param( uploads => \@form_list );

	# User has no sequences
	# Redirect to home page with status message indicating problem
	unless ( scalar @form_list ) {
		$self->session->param( status => '<strong>No Genomes!</strong> You have not uploaded any genome sequences.');
		$self->redirect( $self->home_page );
	}
	
	# Give user indication of success
	my $status = 0;
	$status = $self->param('operation_status') if $self->param('operation_status');
	if($self->session->param('operation_status')) {
		$status = $self->session->param('operation_status');
		$self->session->clear('operation_status');
	}    				
	$t->param( operation_status => $status );
    
    $t->param(go_home  => $self->home_page );
	$t->param(title    => 'Uploaded Genomes');
	
	return $t->output;
}

=head2 edit_genome

Display upload genome form page to edit uploaded genome attributes

=cut

sub edit_genome : Runmode {
    my $self = shift;
    my $errs = shift; # Errors generated by form validation
    
    croak 'Cannot edit a genome unless logged in.' unless $self->authen->is_authenticated;
    
    my $upload_id = $self->query->param('upload_id');
    croak 'Missing query parameter: upload_id' unless $upload_id;
    
	# Check if user has sufficient permissions to edit provided upload_id
	my $test_rs = _getModifiableGenomes($self->dbixSchema, $self->authen->username, $upload_id);
	
	my $test_row = $test_rs->first();
	
	unless($test_row) {
		$self->session->param( operation_status => '<strong>Access Denied.</strong> You do not have sufficient permissions to edit this genome.');
		$self->redirect('/superphy/upload/list');
	}
    
    # Grab everything!!
    my %text_featureprop_map = qw(
		serotype           g_serotype
		strain             g_strain
		keywords           g_keywords
		description        g_description
		owner              g_owner
		synonym            g_synonym
		mol_type           g_mol_type 
		finished           g_finished
		comment            g_comments
	);
    
    # Assumes that each contig_collection feature only has one dbxref
    # and this dbxref is defined in the dbxref_id column in the feature
    # table.  Additional dbxrefs for a feature are stored in feature_dbxref.
    # If this changes in the future, then a join with feature_dbxref is needed.
    my $feature_rs = $self->dbixSchema->resultset('PrivateFeature')->search(
    	{
    		'me.feature_id' => $test_row->get_column('feature_id'),
    	},
    	{
    		prefetch => [
    			{'private_featureprops' => 'type'}, 
    			'upload', 
    			{'dbxref' => 'db'},
    			'private_genome_locations'
    		]
    	}
    );
    
    my $t = $self->load_tmpl ( 'genome_uploader.tmpl' , die_on_bad_params=>0 );
    
    # Make sure hidden parameter upload_id is filled in. Method update_genome
    # requires id.
    $t->param(upload_id => $upload_id);
    
    # Only admins can change privacy settings, this section of the form will be hidden
    #$t->param(set_privacy => $test_row->get_column('can_share'));
    $t->param(set_privacy => 0); # TODO Currently not working now
    
    # Hosts
    my @hosts = map { { host_name => $self->hostList->{$_}, host_value => $_ } } keys %{$self->hostList};
    $t->param(hosts => \@hosts);
    
    my $json = JSON->new;
    $t->param(json_categories => $json->encode($self->hostCategories));
    $t->param(json_sources => $json->encode($self->sourceList));
    
	foreach my $category (@{$self->categoryList}) {
    	my @syndromes = map { { syndrome_name => $self->syndromeList->{$category}{$_}, syndrome_value => $_ } } keys %{$self->syndromeList->{$category}};
    	my $param = "$category\_syndromes";
    	$t->param($param => \@syndromes);
    }
    
    my %param_hash;
    
    # Get the data in feature table and tables with a 'belongs_to' relationship
    my $feature_row = $feature_rs->first();
    
    # Set name param
    %param_hash = (g_name => $feature_row->uniquename);
    
    # Set dbxref params
    if($feature_row->dbxref) {
    	%param_hash = (
	    	g_dbxref_acc => $feature_row->dbxref->accession,
			g_dbxref_ver => $feature_row->dbxref->version,
			g_dbxref_db => $feature_row->dbxref->db->name, 
			%param_hash );
    }
    
    # Set upload params
    $param_hash{g_group} = $feature_row->upload->tag if $feature_row->upload->tag && $feature_row->upload->tag ne 'Unclassified';
    $param_hash{g_privacy} = $feature_row->upload->category;
    
    if($feature_row->upload->category eq 'release') {
    	my $date = $feature_row->upload->release_date;
    	
    	$param_hash{g_release_date} = _strip_time($date);
    	$t->param(selected_release_date => 1);
    }
    
    # Get the data in the featureprop table (has_many relationship)
   
    # Set default value, override later if value found in featureprop table
    $param_hash{g_finished} = 'unknown'; # Check unknown radio button
		
    my $featureprops_rs = $feature_row->private_featureprops;  # Can only call once!!
    my $host_value;
    my $source_value;
    my @syndrome_values;
    my @pmids;
    while(my $featureprop_row = $featureprops_rs->next) {
    	
    	my $property = $featureprop_row->type->name;
    	my $value = $featureprop_row->value;
    	
    	# Complex form fields, HTML::FillInForm will not work here
    	if($property eq 'isolation_host') {
    		$host_value = $value;
    		
    	} elsif($property eq 'isolation_source') {
    		$source_value = $value;
    		
    	} elsif($property eq 'syndrome') {
    		push @syndrome_values, $value;
    	
    	} elsif($property eq 'isolation_age') {
    		my ($age, $units) = Sequences::GenodoDateTime::ageOut($value);
    		
    		$param_hash{g_age} = $age;
    		$param_hash{g_age_unit} = $units;
    		
    	} elsif($property eq 'isolation_date') {
    		$param_hash{g_date} = $value;
    		
    	} elsif($property eq 'pmid') {
    		push @pmids, $value;
    		
    	} elsif($text_featureprop_map{$property}) {
    		# Text property, no conversion needed
    		$param_hash{ $text_featureprop_map{$property} } = $value;
    		
    	} else {
    		croak "Unrecognized featureprop type $property."; 
    	}
    }
    
    $param_hash{g_pmid} = join(', ', @pmids);
    
    # Map host, source, syndrome to checkboxes in form
    
    # Host
    croak "Required data host not found" unless $host_value;
   
    my $host_key = $self->hostUniquename($host_value);
    if($host_key) {
    	$t->param(selected_host => $host_key);
    } else {
    	$host_key = 'other';
    	$t->param(selected_host => $host_key);
    	my ($genus, $species, $name) = ($host_value =~ m/^(\S+)\s(.+)\s\(.+\)$/);
    	$param_hash{g_host_name} = $name;
    	$param_hash{g_host_genus} = $genus;
    	$param_hash{g_host_species} = $species;
    }
    
    # Source
    my $host_cat = $self->hostCategories->{$host_key};
    my $source_key = $self->sourceUniquename($host_cat, $source_value);
    if($source_key) {
    	$t->param(selected_source => $source_key);
    } else {
    	$source_key = 'other';
    	$t->param(selected_source => $source_key);
    	$param_hash{g_other_source} = $source_value;
    }
    
    # Syndromes
    my @syndrome_keys;
    foreach my $disease (@syndrome_values) {
    	get_logger->debug('LOADING DISEASE: ',$disease);
    	if(my $synd_key = $self->syndromeUniquename($host_cat, $source_value)) {
    		push @syndrome_keys, { syndrome_value => $synd_key };
    		get_logger->debug('recognized');
    	} elsif($disease eq 'Asymptomatic') {
    		$param_hash{g_asymptomatic} = 'asymptomatic';
    		get_logger->debug('asymptomatic');
    	} else {
    		get_logger->debug('unrecognized');
    
    		if(defined $param_hash{g_other_syndrome_cb}) {
    			croak "Multiple non-standard syndromes found. Can only have one 'other' syndrome.";
    		} else {
    			$param_hash{g_other_syndrome_cb} = 'other';
    			$param_hash{g_other_syndrome} = $disease;
    		}
    	}
    }
    $t->param(selected_syndromes => \@syndrome_keys);

    # Location
   	my $location_row = $feature_row->private_genome_locations->first;
   	if($location_row) {
   		my $geocode_id = $location_row->geocode_id;
    	$t->param(selected_location => $geocode_id);
   	}
   	
    $t->param(new_genome => 0);
    $t->param(rm    => '/superphy/upload/update_genome');
	$t->param(title => 'Modify Genome Attributes');
	$t->param($errs) if $errs;    # created by rm update_genome
	
	return HTML::FillInForm->fill( \($t->output),   \%param_hash );
}

=head2 update_genome

Commit the user submitted changes to an uploaded genome's attributes

=cut

sub update_genome : Runmode {
    my $self = shift;
    
    croak 'Cannot update a genome unless logged in.' unless $self->authen->is_authenticated;
    
    my $upload_id = $self->query->param('upload_id');
    croak 'Missing query parameter: upload_id' unless $upload_id;

    $dbic = $self->dbixSchema;
       
    get_logger->debug('UPLOADID: '.$upload_id);
    
	# Check if user has sufficient permissions to edit provided upload_id
	my $test_rs = _getModifiableGenomes($self->dbixSchema, $self->authen->username, $upload_id);
	
	my $test_row = $test_rs->first();
	
	unless($test_row) {
		$self->session->param( operation_status => '<strong>Access Denied.</strong> You do not have sufficient permissions to update this genome.');
		$self->redirect('/superphy/upload/list');
	}
    
    # Validate form and fasta file
	my $results = $self->check_rm( 'edit_genome', $self->_dfv_edit_genome_rules($test_row->get_column('name')) )
		|| return $self->check_rm_error_page;
		
	# Everything is good to go, update all required tables
	
	# NOTE: this may involve creating new featureprop or dbxref entries
	# if they do not exist and were added in this edit form.
	
	# Grab everything!!
    # Assumes that each contig_collection feature only has one dbxref
    # and this dbxref is defined in the dbxref_id column in the feature
    # table.  Additional dbxrefs for a feature are stored in feature_dbxref.
    # If this changes in the future, than a join with feature_dbxref is needed.
    my $feature_id = $test_row->get_column('feature_id');
    my $feature_rs = $self->dbixSchema->resultset('PrivateFeature')->search(
    	{
    		'me.feature_id' => $feature_id,
    	},
    	{
    		prefetch => [
    			{'private_featureprops' => 'type'}, 
    			'upload', 
    			{'dbxref' => 'db'},
    			'private_genome_locations'
    		]
    	}
    );
    
    my $feature_row = $feature_rs->first();
    
    # Feature table
    
    # Update if user has changed name
    # Form checks ensure new name is unique.
    if($results->valid('g_name') ne $feature_row->uniquename) {
    	$feature_row->name($results->valid('g_name'));
    	$feature_row->uniquename($results->valid('g_name'));
    }
    
    # Upload table
    
    # Privacy setting can only be changed by admin
    if($results->valid('g_privacy') &&  $results->valid('g_privacy') ne $feature_row->upload->category) {
    	# Attempt to change privacy
    	unless($test_row->get_column('can_share')) {
    		$self->session->param( operation_status => '<strong>Access Denied.</strong> You do not have sufficient permissions to modify the privacy settings for this genome.');
			$self->redirect('/superphy/upload/list');
    	} else {
    		$feature_row->upload->category($results->valid('g_privacy'));
    	}
    }
    # I don't worry about the release date as much. We only consider it
    # when the category = 'release', so field won't affect permissions.
    # Never needs to be deleted, only updated if changed to a new valid date.
    if($results->valid('g_release_date')) {
    	$feature_row->upload->release_date($results->valid('g_release_date')->ymd);
    }
    
    if($results->valid('g_group')) {
    	$feature_row->upload->tag($results->valid('g_group'));
    } else {
    	$feature_row->upload->tag('Unclassified');
    }
    
    $feature_row->upload->update;
    
	# Dbxref table

	if($results->valid('g_dbxref_acc')) {
		# Dbxref form field has value
		my $db = $results->valid('g_dbxref_db');
		my $acc = $results->valid('g_dbxref_acc');
		my $ver = $results->valid('g_dbxref_ver');
		
		$ver = '' unless $ver;
		
		if($feature_row->dbxref && 
			($feature_row->dbxref->db->name ne $db ||
		     $feature_row->dbxref->accession ne $acc ||
		     $feature_row->dbxref->accession ne $ver)) {

			# dbxref in DB does not match submitted value
			
			# Other features with this dbxref?
			my $dbxref_rs = $self->dbixSchema->resultset('PrivateFeature')->search(
				[
					{ 'me.dbxref_id' => $feature_row->dbxref->dbxref_id },
					{ 'private_feature_dbxrefs.dbxref_id' => $feature_row->dbxref->dbxref_id }
					
				],
				{
					join => 'private_feature_dbxrefs',
					columns => 'dbxref_id'
				}
			);
			
			if($dbxref_rs->count > 1) {
				# Other features use this dbxref,
				# Need to create a new dbxref instead of changing this one
				
				my $dbxref_row = _createDbxref($self->dbixSchema, $db, $acc, $ver);
				$feature_row->dbxref_id($dbxref_row->dbxref_id);
				
			} else {
				# No other features with dbxref, can safely update
				my $dbxref_row = $feature_row->dbxref;
				
				# Update database value
				if($dbxref_row->db->name ne $db) {
					# Database changed
					# I don't delete DB records, only add new ones
					
					my $db_row = $self->dbixSchema->resultset('Db')->find({ name => $db });
					
					unless($db_row) {
						# Db not in DB, need to create record
						$db_row = $self->dbixSchema->resultset('Db')->create(
							{
								name => $db,
								description => "autocreated:$db"
							}
						);
					}
					
					$dbxref_row->db_id( $db_row->db_id );
				}
				
				# Update other dbxref values
				$dbxref_row->update({
					accession => $acc,
					version => $ver,
				});
			}
			
		} else {
			# User is adding a new dbxref
			my $dbxref_row = _createDbxref($self->dbixSchema, $db, $acc, $ver);
			$feature_row->dbxref_id($dbxref_row->dbxref_id);
		}
		
	} else {
		# Form field is empty
		
		if($feature_row->dbxref) {
			# User is deleting dbxref
			
			# Other features with this dbxref?
			my $dbxref_rs = $self->dbixSchema->resultset('PrivateFeature')->search(
				[
					{ 'me.dbxref_id' => $feature_row->dbxref->dbxref_id },
					{ 'private_feature_dbxrefs.dbxref_id' => $feature_row->dbxref->dbxref_id }
					
				],
				{
					join => 'private_feature_dbxrefs',
					columns => 'dbxref_id'
				}
			);
			
			if($dbxref_rs->count > 1) {
				# Other features use this dbxref,
				# Set dbxref_id column for this feature to null
				$feature_row->update({dbxref_id => undef});
			} else {
				# No other features with dbxref, can safely delete.
				# Deleting will automagically set feature dbxref_id column to null, YEAH Postgres!!
				# I don't delete DB records.
				$feature_row->dbxref->delete;
			}
				
		}
	}
	
	# Commit all updates
	$feature_row->update;
		
	# Featureprop table
	
	# Convert form into DB values
	# required
	my $host;
	if($results->valid('g_host') eq 'other') {
		$host = $results->valid('g_host_genus') . ' ' . $results->valid('g_host_species') . ' ('.
			$results->valid('g_host_name').')';
	} else {
		$host = $self->hostList->{$results->valid('g_host')};
		croak "Unrecognized host ".$results->valid('g_host') unless $host;
	}
	
	my $host_category = $self->hostCategories->{$results->valid('g_host')};
	
	my $source;
	if($results->valid('g_source') eq 'other') {
		$source = $results->valid('g_other_source');
	} else {
		$source = $self->sourceList->{ $host_category }->{ $results->valid('g_source') };
		croak "Unrecognized source ".$results->valid('g_source')." for provided host ".$results->valid('g_host') unless $source;
	}
	
	my %form_values = (
		serotype => $results->valid('g_serotype'),
		strain => $results->valid('g_strain'),
		isolation_host => $host,
		isolation_source => $source,
		isolation_date => $results->valid('g_date')->ymd,
		mol_type => $results->valid('g_mol_type')
	);

	if($results->valid('g_syndrome')) {
		my @syndrome_keys = $results->valid('g_syndrome');
		my @syndromes;
		foreach my $key (@syndrome_keys) {
			my $syndrome = $self->syndromeList->{ $host_category }->{ $key };
			croak "Unrecognized disease $key for provided host ".$results->valid('g_host') unless $syndrome;
			push @syndromes, $syndrome;
		}
		$form_values{'syndrome'} = \@syndromes;
	} elsif($results->valid('g_asymptomatic')) {
		$form_values{'syndrome'} = ['Asymptomatic'];
	}
	
	if($results->valid('g_other_syndrome_cb')) {
		$form_values{'syndrome'} ||= [];
		push @{$form_values{'syndrome'}}, $results->valid('g_other_syndrome');
	}
	
	if($results->valid('g_age')) {
		# Store everthing in day units
		my $days = Sequences::GenodoDateTime::ageIn($results->valid('g_age'), $results->valid('g_age_unit'));
		$form_values{isolation_age} = $days;
	}
	
	if($results->valid('g_pmid')) {
		my @pmids = split(/,/, $results->valid('g_pmid'));
		my @final_pmids;
		foreach my $item (@pmids){
			push @final_pmids, ($item =~ s/(^\s*)|(\s*$)//);
		}
		$form_values{pmid} = \@final_pmids;
	}
	
	if($results->valid('g_description')) {
		$form_values{'description'} = $results->valid('g_description');
	}
	
	if($results->valid('g_comments')) {
		$form_values{'comment'} = $results->valid('g_comments');
	}
	
	if($results->valid('g_keywords')) {
		$form_values{'keywords'} = $results->valid('g_keywords');
	}
	
	if($results->valid('g_owner')) {
		$form_values{'owner'} = $results->valid('g_owner');
	}

	if($results->valid('g_synonym')) {
		$form_values{'synonym'} = $results->valid('g_synonym');
	}
    
    if($results->valid('g_finished') && $results->valid('g_finished') ne 'unknown') {
		$form_values{'finished'} = $results->valid('g_finished');
	}
	
	
    # Need to keep track of modified vs new featureprops
    my %updated;
    map { $updated{$_}=0} keys %form_values;
  
  	# Perform insertion of Featureprops as single transaction
  	my $txn_guard = $self->dbixSchema->storage->txn_scope_guard;
  	
    # Update existing values in featureprop table
    my $featureprops_rs = $feature_row->private_featureprops;
    while(my $featureprop_row = $featureprops_rs->next) {
    	my $property = $featureprop_row->type->name;
    	
    	get_logger->debug("Property $property");
    	
    	if($property eq 'syndrome' || $property eq 'pmid') {
    		# Delete all existing syndromes and pmid
    		# Will re-insert all syndromes from the form again.
    		# Need to do this to maintain proper rank
    		$featureprop_row->delete;
    		
    	} elsif($form_values{$property}) {
    		
    		# Setting new value 
    		get_logger->debug("...set to ".$form_values{$property});
    		$featureprop_row->value($form_values{$property});
    		$featureprop_row->update;
    		
    	} elsif($featureprop_row->value) {
    		# Form field was deleted by user.
    		# Deleting existing value in DB.
    		# Don't worry, won't delete required fields because
    		# we checked required fields contained a value in form checks.
    		$featureprop_row->delete;
    		get_logger->debug("...deleted ");
    	}
    	
    	$updated{$property} = 1;
    }
    
    # Creating new featureprop entries defined for the first time in this form
    my %fp_cv = (
		mol_type => 'feature_property',
		keywords => 'feature_property',
		description => 'feature_property',
		owner => 'feature_property',
		finished => 'feature_property',
		strain => 'local',
		serotype => 'local',
		isolation_host => 'local',
		isolation_date => 'local',
		synonym => 'feature_property',
		comment => 'feature_property',
		isolation_source => 'local',
		isolation_age => 'local',
		syndrome => 'local',
		pmid     => 'local',
	);
	
	# Update syndromes
	if($form_values{syndrome}) {
		# Find type_id
	    my $syndrome_type_rs = $self->dbixSchema->resultset('Cvterm')->search(
	    	{
	    		'me.name' => 'syndrome', 
	    		'cv.name' => $fp_cv{'syndrome'}
	    	},
	    	{
	    		join => 'cv',
	    		columns => ['cvterm_id']
	    	}
	    );
	    my $syndrome_type_row = $syndrome_type_rs->first;
	    croak "Form field syndrome not defined in cvterm table." unless $syndrome_type_row;
	    
	    my $rank = 0;
		foreach my $form_syndrome (@{$form_values{syndrome}}) {
			
			# Add syndrome 
			get_logger->debug("Property syndrome");
	    		
	    	# Create featureprop
	    	$self->dbixSchema->resultset('PrivateFeatureprop')->create(
		    	{
		    		feature_id => $feature_id,
		    		upload_id => $upload_id,
		    		value => $form_syndrome,
		    		rank => $rank,
		    		type_id => $syndrome_type_row->cvterm_id
		    	}
	    	);
	    	$rank++;
	    	get_logger->debug("...created with value ".$form_values{'syndrome'});
			
		}
		$updated{syndrome}=1
	}
	
	# Update PMIDs
	if($form_values{pmid}) {
		# Find type_id
	    my $pmid_type_rs = $self->dbixSchema->resultset('Cvterm')->search(
	    	{
	    		'me.name' => 'pmid', 
	    		'cv.name' => $fp_cv{'pmid'}
	    	},
	    	{
	    		join => 'cv',
	    		columns => ['cvterm_id']
	    	}
	    );
	    my $pmid_type_row = $pmid_type_rs->first;
	    croak "Form field pmid not defined in cvterm table." unless $pmid_type_row;
	    
	    my $rank = 0;
		foreach my $form_pmid (@{$form_values{pmid}}) {
			# Add pmid 
			get_logger->debug("Property pmid");
	    		
	    	# Create featureprop
	    	$self->dbixSchema->resultset('PrivateFeatureprop')->create(
		    	{
		    		feature_id => $feature_id,
		    		upload_id => $upload_id,
		    		value => $form_pmid,
		    		rank => $rank,
		    		type_id => $pmid_type_row->cvterm_id
		    	}
	    	);
	    	$rank++;
	    	get_logger->debug("...created with value ".$form_values{pmid});
			
		}
		$updated{pmid}=1
	}
	
    foreach my $property (keys %form_values) {
    	if(!$updated{$property}) {
    		get_logger->debug("Property $property");
    		
    		# Find type_id
    		my $type_rs = $self->dbixSchema->resultset('Cvterm')->search(
    			{
    				'me.name' => $property, 
    				'cv.name' => $fp_cv{$property}
    			},
    			{
    				join => 'cv',
    				columns => ['cvterm_id']
    			}
    		);
    		
    		my $type_row = $type_rs->first;
    		croak "Form field $property not defined in cvterm table." unless $type_row;
    		
    		# Create featureprop
    		$self->dbixSchema->resultset('PrivateFeatureprop')->create(
	    		{
	    			feature_id => $feature_id,
	    			upload_id => $upload_id,
	    			value => $form_values{$property},
	    			rank => 0, # New feature, so rank = 0
	    			type_id => $type_row->cvterm_id
	    		}
    		);
    		get_logger->debug("...created with value ".$form_values{$property});
    	}
    }

    # Update location
    if($results->valid('geocode_id')) {
    	get_logger->debug('UPLOADID: '.$upload_id);
    	my $genome_location_row = $feature_row->private_genome_locations->first;
    	if($genome_location_row) {
    		# Update
    		$genome_location_row->geocode_id($results->valid('geocode_id'));
    		$genome_location_row->update;
    	}
    	else {
    		# Create
    		$self->dbixSchema->resultset('PrivateGenomeLocation')->create(
	    		{
	    			feature_id => $feature_id,
	    			geocode_id => $results->valid('geocode_id')
	    		}
    		);
    	}
    	
    }
    
    $txn_guard->commit;
	
	# Redirect to genome list page
	$self->session->param( operation_status => '<strong>Success!</strong> Genome has been updated.' );
	$self->redirect('/superphy/upload/list');
}

=head2 meta_ontology

This is not really a run-mode, just a helper method to query the database
and return a text-based JSON object of the current meta-ontology terms.

Paste this text in the superphy.coffee file to update standardized meta-data terms.

=cut

sub meta_ontology : Runmode {
	my $self = shift;
	
	my %ontology;
	
	# Hosts
	my $hosts = $self->hostList;
	foreach my $term (values %$hosts) {
		next if $term =~ m'^Other ';
		$ontology{hosts}{$term}=1;
	}
	
	# Sources
	my $sources = $self->sourceList;
	foreach my $cat (keys %$sources) {
		foreach my $term (values %{$sources->{$cat}}) {
			next if $term =~ m'^Other ';
			$ontology{sources}{$term}=1;
		}
	}
	
	# Syndromes
	my $syndromes = $self->syndromeList;
	foreach my $cat (keys %$sources) {
		foreach my $term (values %{$syndromes->{$cat}}) {
			next if $term =~ m'^Other ';
			$ontology{syndromes}{$term}=1;
		}
	}
	
	# Sort
	$ontology{hosts} = [sort keys %{$ontology{hosts}}];
	$ontology{sources} = [sort keys %{$ontology{sources}}];
	$ontology{syndromes} = [sort keys %{$ontology{syndromes}}];
	
	my $json = JSON->new->utf8(1)->pretty(1)->encode(\%ontology);
	
	$self->header_add( 
		-type => 'text/plain');
		
	return $json;
}

=head2 _getModifiableFeatures

Return a result set corresponding to upload_id
argument.  Checks user has can_modify permissions on upload.
The uploading user always has full access 
no matter what the permissions.

=cut

sub _getModifiableGenomes {
	my ($schema, $username, $upload_id) = @_;
	
	# Retrieve upload entry from database for this user.
	# Must be able to modify
	my $upload_rs = $schema->resultset('Upload')->search(
		{
			'login.username'            => $username,
			'login_2.username'          => $username,
			'type.name'                 => 'contig_collection',
			'permissions.can_modify'    => 1,
			'me.upload_id'              => $upload_id
		},
		{
			join => [
				'login',
				{ 'permissions'      => 'login' },
				{ 'private_features' => 'type' },
			],
			columns   => [qw/me.tag me.upload_date/],
			'+select' => [qw/private_features.uniquename private_features.feature_id permissions.can_share/],
			'+as'     => [qw/name feature_id can_share/],
		}
	);
	
	return($upload_rs);
}

=head2 _createDbxref

Find or create a dbxref record, possibly
with a new associated db record.

=cut
sub _createDbxref {
	my ($dbix, $db, $acc, $ver) = @_;
	
	# Find or create db record
	my $db_row = $dbix->resultset('Db')->find({ name => $db });
		
	unless($db_row) {
		# Db not in DB, need to create record
		$db_row = $dbix->resultset('Db')->create(
			{
				name => $db,
				description => "autocreated:$db"
			}
		);
	}
		
	# Create dbxref record
	my $dbxref_row = $dbix->resultset('Dbxref')->find_or_create({
		accession => $acc,
		version => $ver,
		db_id => $db_row->db_id,
	});
	
	return($dbxref_row);
}

###############
# Form Validation
###############

=head2 _dfv_common_rules

Validates genome submission/edit form parameters not covered by Javascript checks

=cut

sub _dfv_common_rules {
	my $self = shift;
	
	return {
		required           => [qw(g_name g_host g_source g_date g_strain g_serotype g_mol_type geocode_id)],
		#required           => [qw(g_name g_host g_source g_date g_strain g_serotype g_mol_type)],
		optional           => [qw(g_description g_keywords g_owner g_synonym g_finished g_release_date g_dbxref_db 
								  g_dbxref_acc g_dbxref_ver g_group g_pmid g_comments g_host_name g_host_genus g_host_species
								  g_other_source g_age g_age_unit g_syndrome g_other_syndrome_cb g_other_syndrome 
								  g_comments g_pmid g_asymptomatic)],
		dependency_groups  => {
			dbxref_group => [qw(g_dbxref_db g_dbxref_acc)],
			dbxref_group => [qw(g_host_name g_host_species g_host_genus)],
		},
		dependencies       => {
			dbxref_ver => [qw(g_dbxref_db g_dbxref_acc)],
			g_other_syndrome_cb => [qw(g_other_syndrome)], # If the other sydrome checkbox is checked, other textbox must be defined
			g_host => { 'other' => [qw(g_host_name g_host_genus g_host_species)] },
			g_source => { 'other' => [qw(g_other_source)] },
			g_privacy => { 'release' => [qw/g_release_date/] },
			g_age => [qw(g_age_unit)],
			
		},
		filters            => [qw(trim strip)],
		field_filters      => {
			g_finished     => sub { my $val = shift; $val =~ s/unknown//; return $val; } # unknown radio button is the equivalent of empty value
		},
		constraint_methods => {
			g_date             => &_valid_past_date,
			g_release_date     => &_valid_future_date,
			g_finished         => qr/^yes|no$/,
			g_mol_type         => qr/^wgs|genome|chromosome|plasmid|dna$/,
			g_privacy          => qr/^public|private|release$/,
			g_age_unit         => qr/^years|months|days$/,
			g_age              => qr/^(?:\d+\.?|\.\d)\d*\z/,
			g_dbxref_acc       => FV_length_between( 2, 255 ),
			g_dbxref_db        => FV_length_between( 2, 255 ),
			g_dbxref_ver       => qr/\d+/,
			g_asymptomatic     => \&_healthy_or_sick,
			g_host_genus       => qr/^\S+$/,
			g_host_species     => qr/[^\(\)]+/,
			g_host_name        => qr/[^\(\)]+/,
			geocode_id         => &_valid_geocode
		},
		msgs => {
			format      => '<span class="help-inline"><span class="text-error"><strong>%s</strong></span></span>',
			any_errors  => 'some_errors',
			prefix      => 'err_',
			constraints => {
				'length_between' => 'Too many or too few characters (max characters: 255)',
				'genomename_does_not_exist' => 'A genome with that name already exists in database',
				'valid_fasta_file' => 'Fasta file upload failed',
				'healthy_or_sick' => 'Cannot select both asymptomatic and diseases/symptomes',
				'valid_future_date' => 'Invalid date',
				'valid_past_date' => 'Invalid date',
				'valid_geocode' => 'Invalid genome location'
			}
		},
		untaint_constraint_fields => [qw/g_date g_release_date g_finished g_mol_type/]
	};
}

=head2 _dfv_submit_genome_rules

Validates form parameters not covered by Javascript checks for new genome submission

Adds additional checks over common rules for FASTA file.

=cut

sub _dfv_submit_genome_rules {
	my $self = shift;
	
	my $dfv_rules = $self->_dfv_common_rules;
	
	# Add checks on FASTA file
	# Privacy setting is always required for new genomes
	push @{$dfv_rules->{required}}, 'g_file', 'g_privacy';
	$dfv_rules->{constraint_methods}->{g_file} = _valid_fasta_file(
		$self->query->upload('g_file'), 
		$self->dbh,
		$self->authen->username,
	);
	
	# Check name is unique for every newly submitted genome
	$dfv_rules->{constraint_methods}->{g_name} = [ FV_length_between( 5, 255 ), \&_genomename_does_not_exist ];
	
	return($dfv_rules);
}

=head2 _dfv_edit_genome_rules

Validates form parameters not covered by Javascript checks for modifying genome attributes

Privacy setting is optional because it can only be changed by an admin

=cut

sub _dfv_edit_genome_rules {
	my ($self, $old_gname) = @_;
	
	my $dfv_rules = $self->_dfv_common_rules;
	
	# Privacy setting can only be changed by admins
	push @{$dfv_rules->{optional}}, 'g_privacy';
	
	# Only check if name is unique when it has been changed
	$dfv_rules->{constraint_methods}->{g_name} = [ FV_length_between( 5, 255 ), _new_genomename_does_not_exist($old_gname)];
	
	return($dfv_rules);
}

=head2 _genomename_does_not_exist

Check if genome name is unique.

=cut

sub _genomename_does_not_exist {
	my ( $dfv, $gname ) = @_;

	$dfv->name_this('genomename_does_not_exist');

	my $pub_rv = $dbic->resultset('Feature')->find( { uniquename => $gname } );
	my $pri_rv = $dbic->resultset('PrivateFeature')->find( { uniquename => $gname } );
	
	my $exists = defined($pub_rv) || defined($pri_rv);

	return ( !$exists );
}

=head2 _new_genomename_does_not_exist

Checks if genome name has changed, and if so, if it is unique.

=cut

sub _new_genomename_does_not_exist {
	my ( $oldname ) = @_;
	
	return sub {
		my $dfv = shift;
		
		$dfv->name_this('new_genomename_does_not_exist');
		
		my $gname = $dfv->get_current_constraint_value();
	
		return(1) if $gname eq $oldname; # hasn't changed
		
		# if name changed, verify that its unique
		my $pub_rv = $dbic->resultset('Feature')->find( { uniquename => $gname } );
		my $pri_rv = $dbic->resultset('PrivateFeature')->find( { uniquename => $gname } );
		
		my $exists = defined($pub_rv) || defined($pri_rv);
	
		return ( !$exists );
	}
}

=head2 _valid_fasta_file

Check if uploaded file is valid

=cut

sub _valid_fasta_file {
	my ($upload_handle, $dbh, $username) = @_;
	
	return sub {
		my $dfv = shift;

		$dfv->name_this('valid_fasta_file');
		
		# Make sure upload was not interupted
		unless($upload_handle) {
			get_logger->error("Upload failed.");
			return;
		}; 
		
		my $fh = $upload_handle->handle;
		
	 	# Should be a valid handle type
	    require Scalar::Util;
	
	    unless ( Scalar::Util::blessed($fh) && $fh->isa('IO::Handle') ) {
	        get_logger->error("Field is not a file handle.");
	        return;
	    } 
		
		my $seqio;
		my $total_length = 0;
		my $too_short = 3500000;
		my $too_long = 7500000;
		my $too_many_contigs = 10000;

		eval {
			$dfv->{profile}{msgs} ||= {};
			$seqio = Bio::SeqIO->new(-fh => $fh, -format => 'fasta');
			my $num_contigs = 0;
			my @contigs;
			while(my $seq = $seqio->next_seq) {
				$total_length += $seq->length;
				# Check if nucleotide sequence (allow any IUPAC symbols)
				unless($seq->seq =~ m/^[ACGTUNXRYSWKMBDHVacgtunxryswkmbdhv\.-]+$/) {
					
					if($seq->seq =~ m/([^ACGTUNXRYSWKMBDHVacgtunxryswkmbdhv\.-])/) {
						my $message = "DNA sequence " . $seq->display_id . " contains invalid nucleotide characters: ".$1;
						get_logger->error($message);
						
						# Dynamically change the profile error message for valid_fasta_file
						$dfv->{profile}{msgs}{constraints}{valid_fasta_file} = $message;
						
					}
					
					return;
				}
				
				$num_contigs++;
				push @contigs, $seq->seq;
				
				if($num_contigs > $too_many_contigs) {
					my $message = "Detected over $too_many_contigs sequences in FASTA file. Only assembled genomes can be submitted";
					get_logger->error($message);
					
					# Dynamically change the profile error message for valid_fasta_file
					$dfv->{profile}{msgs}{constraints}{valid_fasta_file} = $message;
					return;
				}
			}
			
			if($total_length < $too_short) {
				my $message = "Sequence too short (total length: $total_length). Only whole genome sequences can be submitted\n";
				get_logger->error($message);
				
				# Dynamically change the profile error message for valid_fasta_file
				$dfv->{profile}{msgs}{constraints}{valid_fasta_file} = $message;

				return;
			}

			if($total_length > $too_long) {
				my $message = "Genome sequence too long (total length: $total_length). Only assembled genomes can be submitted";
				get_logger->error($message);
				
				# Dynamically change the profile error message for valid_fasta_file
				$dfv->{profile}{msgs}{constraints}{valid_fasta_file} = $message;

				return;
			}

			# Make sure no dublicates
			my $inputs = $dfv->get_filtered_data;
			my $access = $inputs->{g_privacy};
			unless($access) {
				my $message = "Cannot validate genome checksum unless genome access (e.g. public|private|release) is provided.";
				get_logger->error($message);
				
				# Dynamically change the profile error message for valid_fasta_file
				$dfv->{profile}{msgs}{constraints}{valid_fasta_file} = $message;

				return;
			}

			my $fp = Modules::Footprint->new(dbh => $dbh);
			my $footprint = $fp->digest(\@contigs);
			my @dups = $fp->validateFootprint(username => $username, footprint => $footprint, privacy => $access);
			$dfv->valid('g_footprint', $footprint);
			if(@dups) {
				my $message = "Duplicate of genome currently in database";
				$message .= '. Genome is duplicate of '.join(', ', @dups);
				get_logger->error($message);
				
				# Dynamically change the profile error message for valid_fasta_file
				$dfv->{profile}{msgs}{constraints}{valid_fasta_file} = $message;

				return;
			}


			
		};
		if($@) {
			get_logger->error("Error reading fasta file:\n$@\n");
			return();
		}
		
		return(1);
	}
}

=head2 _valid_future_date

Check if date is in one of three valid formats:

1) YYYY-MM-DD
2) YYYY-MM
3) YYYY

And is in the future

Return DateTime obj.

=cut

sub _valid_future_date {
	
	return sub {
		my $dfv = shift;
		
		$dfv->name_this('valid_future_date');
		$dfv->{profile}{msgs} ||= {};
		
		my $date = $dfv->get_current_constraint_value();
		my $datetime;
		
		eval {
			$datetime = Sequences::GenodoDateTime->parse_datetime($date);
		};
		if($@ || !$datetime) {
			my $message = "Invalid date (date format: YYYY-MM-DD)";
			get_logger->error($message);
			
			# Dynamically change the profile error message for valid_fasta_file
			$dfv->{profile}{msgs}{constraints}{valid_future_date} = $message;
			return();
		}
		if(Sequences::GenodoDateTime::beforeToday($datetime)) {
			my $message = "Date must be in the future";
			get_logger->error($message);
			
			# Dynamically change the profile error message for valid_fasta_file
			$dfv->{profile}{msgs}{constraints}{valid_future_date} = $message;
			return();
		}
		
		return($datetime);
	}
}

=head2 _valid_future_date

Check if date is in one of three valid formats:

1) YYYY-MM-DD
2) YYYY-MM
3) YYYY

And is in the past

Return DateTime obj.

=cut

sub _valid_past_date {
	
	return sub {
		my $dfv = shift;
		
		$dfv->name_this('valid_past_date');
		$dfv->{profile}{msgs} ||= {};
		
		my $date = $dfv->get_current_constraint_value();
		my $datetime;
		
		eval {
			$datetime = Sequences::GenodoDateTime->parse_datetime($date);
		};
		if($@ || !$datetime) {
			my $message = "Invalid date (date format: YYYY-MM-DD)";
			get_logger->error($message);
			
			# Dynamically change the profile error message for valid_fasta_file
			$dfv->{profile}{msgs}{constraints}{valid_past_date} = $message;
			return();
		}
		if(Sequences::GenodoDateTime::afterToday($datetime)) {
			my $message = "Date must be in the past";
			get_logger->error($message);
			
			# Dynamically change the profile error message for valid_fasta_file
			$dfv->{profile}{msgs}{constraints}{valid_past_date} = $message;
			return();
		}
		
		return($datetime);
	}
}


=head2 _healthy_or_sick

If asymptomatic is checked, make sure no other symptoms are

=cut

sub _healthy_or_sick {
	my ( $dfv, $is_asymptomatic ) = @_;

	$dfv->name_this('healthy_or_sick');

	if($is_asymptomatic) {
		my $data = $dfv->get_filtered_data;
		return(0) if $data->{g_syndromes};
		return(1);
	} else {
		return(1);
	}
}

=head2 _format_time

Strip off the seconds in a Timestamp

=cut

sub _format_time {
	my $timestamp = shift;
	
	my ($date, $time) = ($timestamp =~ m/(\d{4}\-\d{2}-\d{2}) (\d{2}\:\d{2})/);
	
	return("$date $time");
}

=head2 _strip_time

Remove the time from a date time string returned by DB query

=cut

sub _strip_time {
	my $datetime = shift;

	if($datetime =~ m/(\d{4}\-\d{2}\-\d{2})\s?/) {
		return $1;
	}
}

=head2 _valid_geocode

Make sure geocode ID exists in the geocoded_location table

=cut

sub _valid_geocode {
	
	return sub {

		my $dfv = shift;

		warn "TRYING SO HARD.".$dfv->get_current_constraint_value();

		$dfv->name_this('valid_geocode');
		
		# Search for geocode ID in geocoded_location table
		my $geocode_id = $dfv->get_current_constraint_value();
		return unless $geocode_id =~ m/^\d+$/;
		my $row = $dbic->resultset('GeocodedLocation')->find($geocode_id);
			
		return(defined($row));
	}
}

1;
